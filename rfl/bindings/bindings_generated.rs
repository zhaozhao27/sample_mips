#[allow(non_upper_case_globals)]
/* automatically generated by rust-bindgen 0.70.1 */

pub const __FD_SETSIZE: u32 = 1024;
pub const _MIPS_ISA_MIPS1: u32 = 1;
pub const _MIPS_ISA_MIPS2: u32 = 2;
pub const _MIPS_ISA_MIPS3: u32 = 3;
pub const _MIPS_ISA_MIPS4: u32 = 4;
pub const _MIPS_ISA_MIPS5: u32 = 5;
pub const _MIPS_ISA_MIPS32: u32 = 6;
pub const _MIPS_ISA_MIPS64: u32 = 7;
pub const _MIPS_SIM_ABI32: u32 = 1;
pub const _MIPS_SIM_NABI32: u32 = 2;
pub const _MIPS_SIM_ABI64: u32 = 3;
pub const ASM_INPUT_G: &[u8; 2] = b"g\0";
pub const ASM_INPUT_RM: &[u8; 3] = b"rm\0";
pub const KERN_SOH: &[u8; 2] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &[u8; 3] = b"\x010\0";
pub const KERN_ALERT: &[u8; 3] = b"\x011\0";
pub const KERN_CRIT: &[u8; 3] = b"\x012\0";
pub const KERN_ERR: &[u8; 3] = b"\x013\0";
pub const KERN_WARNING: &[u8; 3] = b"\x014\0";
pub const KERN_NOTICE: &[u8; 3] = b"\x015\0";
pub const KERN_INFO: &[u8; 3] = b"\x016\0";
pub const KERN_DEBUG: &[u8; 3] = b"\x017\0";
pub const KERN_DEFAULT: &[u8; 1] = b"\0";
pub const KERN_CONT: &[u8; 3] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const BITS_PER_BYTE: u32 = 8;
pub const ___GFP_SKIP_ZERO: u32 = 0;
pub const ___GFP_SKIP_KASAN: u32 = 0;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const ___GFP_NO_OBJ_EXT: u32 = 0;
pub type __s8 = libc::c_schar;
pub type __u8 = libc::c_uchar;
pub type __s16 = libc::c_short;
pub type __u16 = libc::c_ushort;
pub type __s32 = libc::c_int;
pub type __u32 = libc::c_uint;
pub type __s64 = libc::c_longlong;
pub type __u64 = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [libc::c_ulong; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::core::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::core::mem::align_of::<__kernel_fd_set>() - 4usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::core::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
pub type __kernel_key_t = libc::c_int;
pub type __kernel_mqd_t = libc::c_int;
pub type __kernel_daddr_t = libc::c_long;
pub type __kernel_long_t = libc::c_long;
pub type __kernel_ulong_t = libc::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = libc::c_uint;
pub type __kernel_pid_t = libc::c_int;
pub type __kernel_ipc_pid_t = libc::c_int;
pub type __kernel_uid_t = libc::c_uint;
pub type __kernel_gid_t = libc::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_uid32_t = libc::c_uint;
pub type __kernel_gid32_t = libc::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_old_dev_t = libc::c_uint;
pub type __kernel_size_t = libc::c_uint;
pub type __kernel_ssize_t = libc::c_int;
pub type __kernel_ptrdiff_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::core::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::core::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::core::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = libc::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = libc::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = libc::c_int;
pub type __kernel_clockid_t = libc::c_int;
pub type __kernel_caddr_t = *mut libc::c_char;
pub type __kernel_uid16_t = libc::c_ushort;
pub type __kernel_gid16_t = libc::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = libc::c_uint;
pub type __kernel_dev_t = libc::c_uint;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ulong_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = libc::c_ushort;
pub type nlink_t = libc::c_uint;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type loff_t = __kernel_loff_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = libc::c_uchar;
pub type u_short = libc::c_ushort;
pub type u_int = libc::c_uint;
pub type u_long = libc::c_ulong;
pub type unchar = libc::c_uchar;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type ulong = libc::c_ulong;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulong;
pub type ktime_t = libc::c_long;
#[doc = " The type used for indexing onto a disc or disc partition.\n\n Linux always considers sectors to be 512 bytes long independently\n of the devices real block size.\n\n blkcnt_t is the type of the inode's block count."]
pub type sector_t = libc::c_ulong;
pub type blkcnt_t = libc::c_ulong;
pub type dma_addr_t = libc::c_uint;
pub type gfp_t = libc::c_uint;
pub type slab_flags_t = libc::c_uint;
pub type fmode_t = libc::c_uint;
pub type phys_addr_t = libc::c_uint;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of atomic_t"][::core::mem::size_of::<atomic_t>() - 4usize];
    ["Alignment of atomic_t"][::core::mem::align_of::<atomic_t>() - 4usize];
    ["Offset of field: atomic_t::counter"][::core::mem::offset_of!(atomic_t, counter) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rcuref_t {
    pub refcnt: atomic_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rcuref_t"][::core::mem::size_of::<rcuref_t>() - 4usize];
    ["Alignment of rcuref_t"][::core::mem::align_of::<rcuref_t>() - 4usize];
    ["Offset of field: rcuref_t::refcnt"][::core::mem::offset_of!(rcuref_t, refcnt) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of list_head"][::core::mem::size_of::<list_head>() - 8usize];
    ["Alignment of list_head"][::core::mem::align_of::<list_head>() - 4usize];
    ["Offset of field: list_head::next"][::core::mem::offset_of!(list_head, next) - 0usize];
    ["Offset of field: list_head::prev"][::core::mem::offset_of!(list_head, prev) - 4usize];
};
impl Default for list_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hlist_head"][::core::mem::size_of::<hlist_head>() - 4usize];
    ["Alignment of hlist_head"][::core::mem::align_of::<hlist_head>() - 4usize];
    ["Offset of field: hlist_head::first"][::core::mem::offset_of!(hlist_head, first) - 0usize];
};
impl Default for hlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of hlist_node"][::core::mem::size_of::<hlist_node>() - 8usize];
    ["Alignment of hlist_node"][::core::mem::align_of::<hlist_node>() - 4usize];
    ["Offset of field: hlist_node::next"][::core::mem::offset_of!(hlist_node, next) - 0usize];
    ["Offset of field: hlist_node::pprev"][::core::mem::offset_of!(hlist_node, pprev) - 4usize];
};
impl Default for hlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: libc::c_ulong,
    pub f_fname: [libc::c_char; 6usize],
    pub f_fpack: [libc::c_char; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ustat"][::core::mem::size_of::<ustat>() - 20usize];
    ["Alignment of ustat"][::core::mem::align_of::<ustat>() - 4usize];
    ["Offset of field: ustat::f_tfree"][::core::mem::offset_of!(ustat, f_tfree) - 0usize];
    ["Offset of field: ustat::f_tinode"][::core::mem::offset_of!(ustat, f_tinode) - 4usize];
    ["Offset of field: ustat::f_fname"][::core::mem::offset_of!(ustat, f_fname) - 8usize];
    ["Offset of field: ustat::f_fpack"][::core::mem::offset_of!(ustat, f_fpack) - 14usize];
};
#[doc = " struct callback_head - callback structure for use with RCU and task_work\n @next: next update requests in a list\n @func: actual update function to call after the grace period.\n\n The struct is aligned to size of pointer. On most architectures it happens\n naturally due ABI requirements, but some architectures (like CRIS) have\n weird ABI and we need to ask it explicitly.\n\n The alignment is required to guarantee that bit 0 of @next will be\n clear under normal conditions -- as long as we use call_rcu() or\n call_srcu() to queue the callback.\n\n This guarantee is important for few reasons:\n  - future call_rcu_lazy() will make use of lower bits in the pointer;\n  - the structure shares storage space in struct page with @compound_head,\n    which encode PageTail() in bit 0. The guarantee is needed to avoid\n    false-positive PageTail()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of callback_head"][::core::mem::size_of::<callback_head>() - 8usize];
    ["Alignment of callback_head"][::core::mem::align_of::<callback_head>() - 4usize];
    ["Offset of field: callback_head::next"][::core::mem::offset_of!(callback_head, next) - 0usize];
    ["Offset of field: callback_head::func"][::core::mem::offset_of!(callback_head, func) - 4usize];
};
impl Default for callback_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rcu_callback_t = ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
pub type swap_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *mut libc::c_void,
        b: *mut libc::c_void,
        size: libc::c_int,
        priv_: *const libc::c_void,
    ),
>;
pub type swap_func_t = ::core::option::Option<
    unsafe extern "C" fn(a: *mut libc::c_void, b: *mut libc::c_void, size: libc::c_int),
>;
pub type cmp_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const libc::c_void,
        b: *const libc::c_void,
        priv_: *const libc::c_void,
    ) -> libc::c_int,
>;
pub type cmp_func_t = ::core::option::Option<
    unsafe extern "C" fn(a: *const libc::c_void, b: *const libc::c_void) -> libc::c_int,
>;
pub const ___GFP_DMA_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_DMA_BIT;
pub const ___GFP_HIGHMEM_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_HIGHMEM_BIT;
pub const ___GFP_DMA32_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_DMA32_BIT;
pub const ___GFP_MOVABLE_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_MOVABLE_BIT;
pub const ___GFP_RECLAIMABLE_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_RECLAIMABLE_BIT;
pub const ___GFP_HIGH_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_HIGH_BIT;
pub const ___GFP_IO_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_IO_BIT;
pub const ___GFP_FS_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_FS_BIT;
pub const ___GFP_ZERO_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_ZERO_BIT;
pub const ___GFP_UNUSED_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_UNUSED_BIT;
pub const ___GFP_DIRECT_RECLAIM_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_DIRECT_RECLAIM_BIT;
pub const ___GFP_KSWAPD_RECLAIM_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_KSWAPD_RECLAIM_BIT;
pub const ___GFP_WRITE_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_WRITE_BIT;
pub const ___GFP_NOWARN_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_NOWARN_BIT;
pub const ___GFP_RETRY_MAYFAIL_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_RETRY_MAYFAIL_BIT;
pub const ___GFP_NOFAIL_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_NOFAIL_BIT;
pub const ___GFP_NORETRY_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_NORETRY_BIT;
pub const ___GFP_MEMALLOC_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_MEMALLOC_BIT;
pub const ___GFP_COMP_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_COMP_BIT;
pub const ___GFP_NOMEMALLOC_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_NOMEMALLOC_BIT;
pub const ___GFP_HARDWALL_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_HARDWALL_BIT;
pub const ___GFP_THISNODE_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_THISNODE_BIT;
pub const ___GFP_ACCOUNT_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_ACCOUNT_BIT;
pub const ___GFP_ZEROTAGS_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_ZEROTAGS_BIT;
pub const ___GFP_LAST_BIT: _bindgen_ty_1 = _bindgen_ty_1::___GFP_LAST_BIT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    ___GFP_DMA_BIT = 0,
    ___GFP_HIGHMEM_BIT = 1,
    ___GFP_DMA32_BIT = 2,
    ___GFP_MOVABLE_BIT = 3,
    ___GFP_RECLAIMABLE_BIT = 4,
    ___GFP_HIGH_BIT = 5,
    ___GFP_IO_BIT = 6,
    ___GFP_FS_BIT = 7,
    ___GFP_ZERO_BIT = 8,
    ___GFP_UNUSED_BIT = 9,
    ___GFP_DIRECT_RECLAIM_BIT = 10,
    ___GFP_KSWAPD_RECLAIM_BIT = 11,
    ___GFP_WRITE_BIT = 12,
    ___GFP_NOWARN_BIT = 13,
    ___GFP_RETRY_MAYFAIL_BIT = 14,
    ___GFP_NOFAIL_BIT = 15,
    ___GFP_NORETRY_BIT = 16,
    ___GFP_MEMALLOC_BIT = 17,
    ___GFP_COMP_BIT = 18,
    ___GFP_NOMEMALLOC_BIT = 19,
    ___GFP_HARDWALL_BIT = 20,
    ___GFP_THISNODE_BIT = 21,
    ___GFP_ACCOUNT_BIT = 22,
    ___GFP_ZEROTAGS_BIT = 23,
    ___GFP_LAST_BIT = 24,
}
