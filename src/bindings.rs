#[allow(non_upper_case_globals)]
/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const _SGIDEFS_H: u32 = 1;
pub const _MIPS_ISA_MIPS1: u32 = 1;
pub const _MIPS_ISA_MIPS2: u32 = 2;
pub const _MIPS_ISA_MIPS3: u32 = 3;
pub const _MIPS_ISA_MIPS4: u32 = 4;
pub const _MIPS_ISA_MIPS5: u32 = 5;
pub const _MIPS_ISA_MIPS32: u32 = 6;
pub const _MIPS_ISA_MIPS64: u32 = 7;
pub const _ABIN32: u32 = 2;
pub const _MIPS_SIM_NABI32: u32 = 2;
pub const _ABI64: u32 = 3;
pub const _MIPS_SIM_ABI64: u32 = 3;
pub const _ABIO64: u32 = 4;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __NO_LONG_DOUBLE_MATH: u32 = 1;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const IMP_IVS_MOVE_MAX_ROI_CNT: u32 = 52;
pub const _PTHREAD_H: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 36;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 24;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 20;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 0;
pub const __PTHREAD_RWLOCK_ELISION_EXTRA: u32 = 0;
pub const __PTHREAD_SPINS: u32 = 0;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 0;
pub const __have_pthread_attr_t: u32 = 1;
pub const _MIPS_BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _SYS_TIME_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _IOC_SIZEBITS: u32 = 13;
pub const _IOC_DIRBITS: u32 = 3;
pub const _IOC_NONE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const _IOC_WRITE: u32 = 4;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 8191;
pub const _IOC_DIRMASK: u32 = 7;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 29;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 536805376;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const V4L2_SEL_TGT_CROP: u32 = 0;
pub const V4L2_SEL_TGT_CROP_DEFAULT: u32 = 1;
pub const V4L2_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SEL_TGT_NATIVE_SIZE: u32 = 3;
pub const V4L2_SEL_TGT_COMPOSE: u32 = 256;
pub const V4L2_SEL_TGT_COMPOSE_DEFAULT: u32 = 257;
pub const V4L2_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SEL_TGT_COMPOSE_PADDED: u32 = 259;
pub const V4L2_SEL_FLAG_GE: u32 = 1;
pub const V4L2_SEL_FLAG_LE: u32 = 2;
pub const V4L2_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_SEL_TGT_CROP_ACTIVE: u32 = 0;
pub const V4L2_SEL_TGT_COMPOSE_ACTIVE: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_ACTUAL: u32 = 0;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_ACTUAL: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_GE: u32 = 1;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_LE: u32 = 2;
pub const V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_CTRL_CLASS_USER: u32 = 9961472;
pub const V4L2_CTRL_CLASS_MPEG: u32 = 10027008;
pub const V4L2_CTRL_CLASS_CAMERA: u32 = 10092544;
pub const V4L2_CTRL_CLASS_FM_TX: u32 = 10158080;
pub const V4L2_CTRL_CLASS_FLASH: u32 = 10223616;
pub const V4L2_CTRL_CLASS_JPEG: u32 = 10289152;
pub const V4L2_CTRL_CLASS_IMAGE_SOURCE: u32 = 10354688;
pub const V4L2_CTRL_CLASS_IMAGE_PROC: u32 = 10420224;
pub const V4L2_CTRL_CLASS_DV: u32 = 10485760;
pub const V4L2_CTRL_CLASS_FM_RX: u32 = 10551296;
pub const V4L2_CTRL_CLASS_RF_TUNER: u32 = 10616832;
pub const V4L2_CTRL_CLASS_DETECT: u32 = 10682368;
pub const V4L2_CID_BASE: u32 = 9963776;
pub const V4L2_CID_USER_BASE: u32 = 9963776;
pub const V4L2_CID_USER_CLASS: u32 = 9961473;
pub const V4L2_CID_BRIGHTNESS: u32 = 9963776;
pub const V4L2_CID_CONTRAST: u32 = 9963777;
pub const V4L2_CID_SATURATION: u32 = 9963778;
pub const V4L2_CID_HUE: u32 = 9963779;
pub const V4L2_CID_AUDIO_VOLUME: u32 = 9963781;
pub const V4L2_CID_AUDIO_BALANCE: u32 = 9963782;
pub const V4L2_CID_AUDIO_BASS: u32 = 9963783;
pub const V4L2_CID_AUDIO_TREBLE: u32 = 9963784;
pub const V4L2_CID_AUDIO_MUTE: u32 = 9963785;
pub const V4L2_CID_AUDIO_LOUDNESS: u32 = 9963786;
pub const V4L2_CID_BLACK_LEVEL: u32 = 9963787;
pub const V4L2_CID_AUTO_WHITE_BALANCE: u32 = 9963788;
pub const V4L2_CID_DO_WHITE_BALANCE: u32 = 9963789;
pub const V4L2_CID_RED_BALANCE: u32 = 9963790;
pub const V4L2_CID_BLUE_BALANCE: u32 = 9963791;
pub const V4L2_CID_GAMMA: u32 = 9963792;
pub const V4L2_CID_WHITENESS: u32 = 9963792;
pub const V4L2_CID_EXPOSURE: u32 = 9963793;
pub const V4L2_CID_AUTOGAIN: u32 = 9963794;
pub const V4L2_CID_GAIN: u32 = 9963795;
pub const V4L2_CID_HFLIP: u32 = 9963796;
pub const V4L2_CID_VFLIP: u32 = 9963797;
pub const V4L2_CID_POWER_LINE_FREQUENCY: u32 = 9963800;
pub const V4L2_CID_HUE_AUTO: u32 = 9963801;
pub const V4L2_CID_WHITE_BALANCE_TEMPERATURE: u32 = 9963802;
pub const V4L2_CID_SHARPNESS: u32 = 9963803;
pub const V4L2_CID_BACKLIGHT_COMPENSATION: u32 = 9963804;
pub const V4L2_CID_CHROMA_AGC: u32 = 9963805;
pub const V4L2_CID_COLOR_KILLER: u32 = 9963806;
pub const V4L2_CID_COLORFX: u32 = 9963807;
pub const V4L2_CID_AUTOBRIGHTNESS: u32 = 9963808;
pub const V4L2_CID_BAND_STOP_FILTER: u32 = 9963809;
pub const V4L2_CID_ROTATE: u32 = 9963810;
pub const V4L2_CID_BG_COLOR: u32 = 9963811;
pub const V4L2_CID_CHROMA_GAIN: u32 = 9963812;
pub const V4L2_CID_ILLUMINATORS_1: u32 = 9963813;
pub const V4L2_CID_ILLUMINATORS_2: u32 = 9963814;
pub const V4L2_CID_MIN_BUFFERS_FOR_CAPTURE: u32 = 9963815;
pub const V4L2_CID_MIN_BUFFERS_FOR_OUTPUT: u32 = 9963816;
pub const V4L2_CID_ALPHA_COMPONENT: u32 = 9963817;
pub const V4L2_CID_COLORFX_CBCR: u32 = 9963818;
pub const V4L2_CID_LASTP1: u32 = 9963819;
pub const V4L2_CID_USER_MEYE_BASE: u32 = 9967872;
pub const V4L2_CID_USER_BTTV_BASE: u32 = 9967888;
pub const V4L2_CID_USER_S2255_BASE: u32 = 9967920;
pub const V4L2_CID_USER_SI476X_BASE: u32 = 9967936;
pub const V4L2_CID_USER_TI_VPE_BASE: u32 = 9967952;
pub const V4L2_CID_USER_SAA7134_BASE: u32 = 9967968;
pub const V4L2_CID_USER_ADV7180_BASE: u32 = 9967984;
pub const V4L2_CID_USER_TC358743_BASE: u32 = 9968000;
pub const V4L2_CID_USER_MAX217X_BASE: u32 = 9968016;
pub const V4L2_CID_USER_IMX_BASE: u32 = 9968048;
pub const V4L2_CID_MPEG_BASE: u32 = 10029312;
pub const V4L2_CID_MPEG_CLASS: u32 = 10027009;
pub const V4L2_CID_MPEG_STREAM_TYPE: u32 = 10029312;
pub const V4L2_CID_MPEG_STREAM_PID_PMT: u32 = 10029313;
pub const V4L2_CID_MPEG_STREAM_PID_AUDIO: u32 = 10029314;
pub const V4L2_CID_MPEG_STREAM_PID_VIDEO: u32 = 10029315;
pub const V4L2_CID_MPEG_STREAM_PID_PCR: u32 = 10029316;
pub const V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: u32 = 10029317;
pub const V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: u32 = 10029318;
pub const V4L2_CID_MPEG_STREAM_VBI_FMT: u32 = 10029319;
pub const V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: u32 = 10029412;
pub const V4L2_CID_MPEG_AUDIO_ENCODING: u32 = 10029413;
pub const V4L2_CID_MPEG_AUDIO_L1_BITRATE: u32 = 10029414;
pub const V4L2_CID_MPEG_AUDIO_L2_BITRATE: u32 = 10029415;
pub const V4L2_CID_MPEG_AUDIO_L3_BITRATE: u32 = 10029416;
pub const V4L2_CID_MPEG_AUDIO_MODE: u32 = 10029417;
pub const V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: u32 = 10029418;
pub const V4L2_CID_MPEG_AUDIO_EMPHASIS: u32 = 10029419;
pub const V4L2_CID_MPEG_AUDIO_CRC: u32 = 10029420;
pub const V4L2_CID_MPEG_AUDIO_MUTE: u32 = 10029421;
pub const V4L2_CID_MPEG_AUDIO_AAC_BITRATE: u32 = 10029422;
pub const V4L2_CID_MPEG_AUDIO_AC3_BITRATE: u32 = 10029423;
pub const V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK: u32 = 10029424;
pub const V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: u32 = 10029425;
pub const V4L2_CID_MPEG_VIDEO_ENCODING: u32 = 10029512;
pub const V4L2_CID_MPEG_VIDEO_ASPECT: u32 = 10029513;
pub const V4L2_CID_MPEG_VIDEO_B_FRAMES: u32 = 10029514;
pub const V4L2_CID_MPEG_VIDEO_GOP_SIZE: u32 = 10029515;
pub const V4L2_CID_MPEG_VIDEO_GOP_CLOSURE: u32 = 10029516;
pub const V4L2_CID_MPEG_VIDEO_PULLDOWN: u32 = 10029517;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_MODE: u32 = 10029518;
pub const V4L2_CID_MPEG_VIDEO_BITRATE: u32 = 10029519;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: u32 = 10029520;
pub const V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: u32 = 10029521;
pub const V4L2_CID_MPEG_VIDEO_MUTE: u32 = 10029522;
pub const V4L2_CID_MPEG_VIDEO_MUTE_YUV: u32 = 10029523;
pub const V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE: u32 = 10029524;
pub const V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER: u32 = 10029525;
pub const V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB: u32 = 10029526;
pub const V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE: u32 = 10029527;
pub const V4L2_CID_MPEG_VIDEO_HEADER_MODE: u32 = 10029528;
pub const V4L2_CID_MPEG_VIDEO_MAX_REF_PIC: u32 = 10029529;
pub const V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE: u32 = 10029530;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES: u32 = 10029531;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB: u32 = 10029532;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE: u32 = 10029533;
pub const V4L2_CID_MPEG_VIDEO_VBV_SIZE: u32 = 10029534;
pub const V4L2_CID_MPEG_VIDEO_DEC_PTS: u32 = 10029535;
pub const V4L2_CID_MPEG_VIDEO_DEC_FRAME: u32 = 10029536;
pub const V4L2_CID_MPEG_VIDEO_VBV_DELAY: u32 = 10029537;
pub const V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER: u32 = 10029538;
pub const V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE: u32 = 10029539;
pub const V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE: u32 = 10029540;
pub const V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME: u32 = 10029541;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL: u32 = 10029582;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE: u32 = 10029583;
pub const V4L2_CID_FWHT_I_FRAME_QP: u32 = 10029602;
pub const V4L2_CID_FWHT_P_FRAME_QP: u32 = 10029603;
pub const V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP: u32 = 10029612;
pub const V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP: u32 = 10029613;
pub const V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP: u32 = 10029614;
pub const V4L2_CID_MPEG_VIDEO_H263_MIN_QP: u32 = 10029615;
pub const V4L2_CID_MPEG_VIDEO_H263_MAX_QP: u32 = 10029616;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP: u32 = 10029662;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP: u32 = 10029663;
pub const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP: u32 = 10029664;
pub const V4L2_CID_MPEG_VIDEO_H264_MIN_QP: u32 = 10029665;
pub const V4L2_CID_MPEG_VIDEO_H264_MAX_QP: u32 = 10029666;
pub const V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM: u32 = 10029667;
pub const V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE: u32 = 10029668;
pub const V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE: u32 = 10029669;
pub const V4L2_CID_MPEG_VIDEO_H264_I_PERIOD: u32 = 10029670;
pub const V4L2_CID_MPEG_VIDEO_H264_LEVEL: u32 = 10029671;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA: u32 = 10029672;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA: u32 = 10029673;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE: u32 = 10029674;
pub const V4L2_CID_MPEG_VIDEO_H264_PROFILE: u32 = 10029675;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT: u32 = 10029676;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH: u32 = 10029677;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE: u32 = 10029678;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC: u32 = 10029679;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING: u32 = 10029680;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0: u32 = 10029681;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE: u32 = 10029682;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO: u32 = 10029683;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE: u32 = 10029684;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP: u32 = 10029685;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION: u32 = 10029686;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE: u32 = 10029687;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH: u32 = 10029688;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO: u32 = 10029689;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER: u32 = 10029690;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING: u32 = 10029691;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE: u32 = 10029692;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER: u32 = 10029693;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP: u32 = 10029694;
pub const V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION: u32 = 10029695;
pub const V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET: u32 = 10029696;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MIN_QP: u32 = 10029697;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MAX_QP: u32 = 10029698;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MIN_QP: u32 = 10029699;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MAX_QP: u32 = 10029700;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP: u32 = 10029712;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP: u32 = 10029713;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP: u32 = 10029714;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP: u32 = 10029715;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP: u32 = 10029716;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL: u32 = 10029717;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE: u32 = 10029718;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_QPEL: u32 = 10029719;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS: u32 = 10029812;
pub const V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4: u32 = 10029813;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES: u32 = 10029814;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL: u32 = 10029815;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS: u32 = 10029816;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD: u32 = 10029817;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL: u32 = 10029818;
pub const V4L2_CID_MPEG_VIDEO_VPX_MIN_QP: u32 = 10029819;
pub const V4L2_CID_MPEG_VIDEO_VPX_MAX_QP: u32 = 10029820;
pub const V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP: u32 = 10029821;
pub const V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP: u32 = 10029822;
pub const V4L2_CID_MPEG_VIDEO_VP8_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VPX_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VP9_PROFILE: u32 = 10029824;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP: u32 = 10029912;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP: u32 = 10029913;
pub const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP: u32 = 10029914;
pub const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP: u32 = 10029915;
pub const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP: u32 = 10029916;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP: u32 = 10029917;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE: u32 = 10029918;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER: u32 = 10029919;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP: u32 = 10029920;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP: u32 = 10029921;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP: u32 = 10029922;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP: u32 = 10029923;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP: u32 = 10029924;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP: u32 = 10029925;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP: u32 = 10029926;
pub const V4L2_CID_MPEG_VIDEO_HEVC_PROFILE: u32 = 10029927;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LEVEL: u32 = 10029928;
pub const V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION: u32 = 10029929;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TIER: u32 = 10029930;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH: u32 = 10029931;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE: u32 = 10029932;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2: u32 = 10029933;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2: u32 = 10029934;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE: u32 = 10029935;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD: u32 = 10029936;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU: u32 = 10029937;
pub const V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED: u32 = 10029938;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT: u32 = 10029939;
pub const V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB: u32 = 10029940;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID: u32 = 10029941;
pub const V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING: u32 = 10029942;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1: u32 = 10029943;
pub const V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT: u32 = 10029944;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION: u32 = 10029945;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE: u32 = 10029946;
pub const V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD: u32 = 10029947;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR: u32 = 10029948;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR: u32 = 10029949;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR: u32 = 10029950;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR: u32 = 10029951;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR: u32 = 10029952;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR: u32 = 10029953;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR: u32 = 10029954;
pub const V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES: u32 = 10029955;
pub const V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR: u32 = 10029956;
pub const V4L2_CID_MPEG_CX2341X_BASE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER: u32 = 10031105;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE: u32 = 10031106;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE: u32 = 10031107;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE: u32 = 10031108;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER: u32 = 10031109;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE: u32 = 10031110;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM: u32 = 10031111;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP: u32 = 10031112;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM: u32 = 10031113;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP: u32 = 10031114;
pub const V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS: u32 = 10031115;
pub const V4L2_CID_MPEG_MFC51_BASE: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE: u32 = 10031361;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE: u32 = 10031362;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE: u32 = 10031363;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING: u32 = 10031364;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV: u32 = 10031365;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT: u32 = 10031366;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF: u32 = 10031367;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY: u32 = 10031410;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK: u32 = 10031411;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH: u32 = 10031412;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC: u32 = 10031413;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P: u32 = 10031414;
pub const V4L2_CID_CAMERA_CLASS_BASE: u32 = 10094848;
pub const V4L2_CID_CAMERA_CLASS: u32 = 10092545;
pub const V4L2_CID_EXPOSURE_AUTO: u32 = 10094849;
pub const V4L2_CID_EXPOSURE_ABSOLUTE: u32 = 10094850;
pub const V4L2_CID_EXPOSURE_AUTO_PRIORITY: u32 = 10094851;
pub const V4L2_CID_PAN_RELATIVE: u32 = 10094852;
pub const V4L2_CID_TILT_RELATIVE: u32 = 10094853;
pub const V4L2_CID_PAN_RESET: u32 = 10094854;
pub const V4L2_CID_TILT_RESET: u32 = 10094855;
pub const V4L2_CID_PAN_ABSOLUTE: u32 = 10094856;
pub const V4L2_CID_TILT_ABSOLUTE: u32 = 10094857;
pub const V4L2_CID_FOCUS_ABSOLUTE: u32 = 10094858;
pub const V4L2_CID_FOCUS_RELATIVE: u32 = 10094859;
pub const V4L2_CID_FOCUS_AUTO: u32 = 10094860;
pub const V4L2_CID_ZOOM_ABSOLUTE: u32 = 10094861;
pub const V4L2_CID_ZOOM_RELATIVE: u32 = 10094862;
pub const V4L2_CID_ZOOM_CONTINUOUS: u32 = 10094863;
pub const V4L2_CID_PRIVACY: u32 = 10094864;
pub const V4L2_CID_IRIS_ABSOLUTE: u32 = 10094865;
pub const V4L2_CID_IRIS_RELATIVE: u32 = 10094866;
pub const V4L2_CID_AUTO_EXPOSURE_BIAS: u32 = 10094867;
pub const V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: u32 = 10094868;
pub const V4L2_CID_WIDE_DYNAMIC_RANGE: u32 = 10094869;
pub const V4L2_CID_IMAGE_STABILIZATION: u32 = 10094870;
pub const V4L2_CID_ISO_SENSITIVITY: u32 = 10094871;
pub const V4L2_CID_ISO_SENSITIVITY_AUTO: u32 = 10094872;
pub const V4L2_CID_EXPOSURE_METERING: u32 = 10094873;
pub const V4L2_CID_SCENE_MODE: u32 = 10094874;
pub const V4L2_CID_3A_LOCK: u32 = 10094875;
pub const V4L2_LOCK_EXPOSURE: u32 = 1;
pub const V4L2_LOCK_WHITE_BALANCE: u32 = 2;
pub const V4L2_LOCK_FOCUS: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_START: u32 = 10094876;
pub const V4L2_CID_AUTO_FOCUS_STOP: u32 = 10094877;
pub const V4L2_CID_AUTO_FOCUS_STATUS: u32 = 10094878;
pub const V4L2_AUTO_FOCUS_STATUS_IDLE: u32 = 0;
pub const V4L2_AUTO_FOCUS_STATUS_BUSY: u32 = 1;
pub const V4L2_AUTO_FOCUS_STATUS_REACHED: u32 = 2;
pub const V4L2_AUTO_FOCUS_STATUS_FAILED: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_RANGE: u32 = 10094879;
pub const V4L2_CID_PAN_SPEED: u32 = 10094880;
pub const V4L2_CID_TILT_SPEED: u32 = 10094881;
pub const V4L2_CID_FM_TX_CLASS_BASE: u32 = 10160384;
pub const V4L2_CID_FM_TX_CLASS: u32 = 10158081;
pub const V4L2_CID_RDS_TX_DEVIATION: u32 = 10160385;
pub const V4L2_CID_RDS_TX_PI: u32 = 10160386;
pub const V4L2_CID_RDS_TX_PTY: u32 = 10160387;
pub const V4L2_CID_RDS_TX_PS_NAME: u32 = 10160389;
pub const V4L2_CID_RDS_TX_RADIO_TEXT: u32 = 10160390;
pub const V4L2_CID_RDS_TX_MONO_STEREO: u32 = 10160391;
pub const V4L2_CID_RDS_TX_ARTIFICIAL_HEAD: u32 = 10160392;
pub const V4L2_CID_RDS_TX_COMPRESSED: u32 = 10160393;
pub const V4L2_CID_RDS_TX_DYNAMIC_PTY: u32 = 10160394;
pub const V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT: u32 = 10160395;
pub const V4L2_CID_RDS_TX_TRAFFIC_PROGRAM: u32 = 10160396;
pub const V4L2_CID_RDS_TX_MUSIC_SPEECH: u32 = 10160397;
pub const V4L2_CID_RDS_TX_ALT_FREQS_ENABLE: u32 = 10160398;
pub const V4L2_CID_RDS_TX_ALT_FREQS: u32 = 10160399;
pub const V4L2_CID_AUDIO_LIMITER_ENABLED: u32 = 10160448;
pub const V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: u32 = 10160449;
pub const V4L2_CID_AUDIO_LIMITER_DEVIATION: u32 = 10160450;
pub const V4L2_CID_AUDIO_COMPRESSION_ENABLED: u32 = 10160464;
pub const V4L2_CID_AUDIO_COMPRESSION_GAIN: u32 = 10160465;
pub const V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: u32 = 10160466;
pub const V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: u32 = 10160467;
pub const V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: u32 = 10160468;
pub const V4L2_CID_PILOT_TONE_ENABLED: u32 = 10160480;
pub const V4L2_CID_PILOT_TONE_DEVIATION: u32 = 10160481;
pub const V4L2_CID_PILOT_TONE_FREQUENCY: u32 = 10160482;
pub const V4L2_CID_TUNE_PREEMPHASIS: u32 = 10160496;
pub const V4L2_CID_TUNE_POWER_LEVEL: u32 = 10160497;
pub const V4L2_CID_TUNE_ANTENNA_CAPACITOR: u32 = 10160498;
pub const V4L2_CID_FLASH_CLASS_BASE: u32 = 10225920;
pub const V4L2_CID_FLASH_CLASS: u32 = 10223617;
pub const V4L2_CID_FLASH_LED_MODE: u32 = 10225921;
pub const V4L2_CID_FLASH_STROBE_SOURCE: u32 = 10225922;
pub const V4L2_CID_FLASH_STROBE: u32 = 10225923;
pub const V4L2_CID_FLASH_STROBE_STOP: u32 = 10225924;
pub const V4L2_CID_FLASH_STROBE_STATUS: u32 = 10225925;
pub const V4L2_CID_FLASH_TIMEOUT: u32 = 10225926;
pub const V4L2_CID_FLASH_INTENSITY: u32 = 10225927;
pub const V4L2_CID_FLASH_TORCH_INTENSITY: u32 = 10225928;
pub const V4L2_CID_FLASH_INDICATOR_INTENSITY: u32 = 10225929;
pub const V4L2_CID_FLASH_FAULT: u32 = 10225930;
pub const V4L2_FLASH_FAULT_OVER_VOLTAGE: u32 = 1;
pub const V4L2_FLASH_FAULT_TIMEOUT: u32 = 2;
pub const V4L2_FLASH_FAULT_OVER_TEMPERATURE: u32 = 4;
pub const V4L2_FLASH_FAULT_SHORT_CIRCUIT: u32 = 8;
pub const V4L2_FLASH_FAULT_OVER_CURRENT: u32 = 16;
pub const V4L2_FLASH_FAULT_INDICATOR: u32 = 32;
pub const V4L2_FLASH_FAULT_UNDER_VOLTAGE: u32 = 64;
pub const V4L2_FLASH_FAULT_INPUT_VOLTAGE: u32 = 128;
pub const V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE: u32 = 256;
pub const V4L2_CID_FLASH_CHARGE: u32 = 10225931;
pub const V4L2_CID_FLASH_READY: u32 = 10225932;
pub const V4L2_CID_JPEG_CLASS_BASE: u32 = 10291456;
pub const V4L2_CID_JPEG_CLASS: u32 = 10289153;
pub const V4L2_CID_JPEG_CHROMA_SUBSAMPLING: u32 = 10291457;
pub const V4L2_CID_JPEG_RESTART_INTERVAL: u32 = 10291458;
pub const V4L2_CID_JPEG_COMPRESSION_QUALITY: u32 = 10291459;
pub const V4L2_CID_JPEG_ACTIVE_MARKER: u32 = 10291460;
pub const V4L2_JPEG_ACTIVE_MARKER_APP0: u32 = 1;
pub const V4L2_JPEG_ACTIVE_MARKER_APP1: u32 = 2;
pub const V4L2_JPEG_ACTIVE_MARKER_COM: u32 = 65536;
pub const V4L2_JPEG_ACTIVE_MARKER_DQT: u32 = 131072;
pub const V4L2_JPEG_ACTIVE_MARKER_DHT: u32 = 262144;
pub const V4L2_CID_IMAGE_SOURCE_CLASS_BASE: u32 = 10356992;
pub const V4L2_CID_IMAGE_SOURCE_CLASS: u32 = 10354689;
pub const V4L2_CID_VBLANK: u32 = 10356993;
pub const V4L2_CID_HBLANK: u32 = 10356994;
pub const V4L2_CID_ANALOGUE_GAIN: u32 = 10356995;
pub const V4L2_CID_TEST_PATTERN_RED: u32 = 10356996;
pub const V4L2_CID_TEST_PATTERN_GREENR: u32 = 10356997;
pub const V4L2_CID_TEST_PATTERN_BLUE: u32 = 10356998;
pub const V4L2_CID_TEST_PATTERN_GREENB: u32 = 10356999;
pub const V4L2_CID_IMAGE_PROC_CLASS_BASE: u32 = 10422528;
pub const V4L2_CID_IMAGE_PROC_CLASS: u32 = 10420225;
pub const V4L2_CID_LINK_FREQ: u32 = 10422529;
pub const V4L2_CID_PIXEL_RATE: u32 = 10422530;
pub const V4L2_CID_TEST_PATTERN: u32 = 10422531;
pub const V4L2_CID_DEINTERLACING_MODE: u32 = 10422532;
pub const V4L2_CID_DIGITAL_GAIN: u32 = 10422533;
pub const V4L2_CID_DV_CLASS_BASE: u32 = 10488064;
pub const V4L2_CID_DV_CLASS: u32 = 10485761;
pub const V4L2_CID_DV_TX_HOTPLUG: u32 = 10488065;
pub const V4L2_CID_DV_TX_RXSENSE: u32 = 10488066;
pub const V4L2_CID_DV_TX_EDID_PRESENT: u32 = 10488067;
pub const V4L2_CID_DV_TX_MODE: u32 = 10488068;
pub const V4L2_CID_DV_TX_RGB_RANGE: u32 = 10488069;
pub const V4L2_CID_DV_TX_IT_CONTENT_TYPE: u32 = 10488070;
pub const V4L2_CID_DV_RX_POWER_PRESENT: u32 = 10488164;
pub const V4L2_CID_DV_RX_RGB_RANGE: u32 = 10488165;
pub const V4L2_CID_DV_RX_IT_CONTENT_TYPE: u32 = 10488166;
pub const V4L2_CID_FM_RX_CLASS_BASE: u32 = 10553600;
pub const V4L2_CID_FM_RX_CLASS: u32 = 10551297;
pub const V4L2_CID_TUNE_DEEMPHASIS: u32 = 10553601;
pub const V4L2_CID_RDS_RECEPTION: u32 = 10553602;
pub const V4L2_CID_RDS_RX_PTY: u32 = 10553603;
pub const V4L2_CID_RDS_RX_PS_NAME: u32 = 10553604;
pub const V4L2_CID_RDS_RX_RADIO_TEXT: u32 = 10553605;
pub const V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT: u32 = 10553606;
pub const V4L2_CID_RDS_RX_TRAFFIC_PROGRAM: u32 = 10553607;
pub const V4L2_CID_RDS_RX_MUSIC_SPEECH: u32 = 10553608;
pub const V4L2_CID_RF_TUNER_CLASS_BASE: u32 = 10619136;
pub const V4L2_CID_RF_TUNER_CLASS: u32 = 10616833;
pub const V4L2_CID_RF_TUNER_BANDWIDTH_AUTO: u32 = 10619147;
pub const V4L2_CID_RF_TUNER_BANDWIDTH: u32 = 10619148;
pub const V4L2_CID_RF_TUNER_RF_GAIN: u32 = 10619168;
pub const V4L2_CID_RF_TUNER_LNA_GAIN_AUTO: u32 = 10619177;
pub const V4L2_CID_RF_TUNER_LNA_GAIN: u32 = 10619178;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO: u32 = 10619187;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN: u32 = 10619188;
pub const V4L2_CID_RF_TUNER_IF_GAIN_AUTO: u32 = 10619197;
pub const V4L2_CID_RF_TUNER_IF_GAIN: u32 = 10619198;
pub const V4L2_CID_RF_TUNER_PLL_LOCK: u32 = 10619227;
pub const V4L2_CID_DETECT_CLASS_BASE: u32 = 10684672;
pub const V4L2_CID_DETECT_CLASS: u32 = 10682369;
pub const V4L2_CID_DETECT_MD_MODE: u32 = 10684673;
pub const V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD: u32 = 10684674;
pub const V4L2_CID_DETECT_MD_THRESHOLD_GRID: u32 = 10684675;
pub const V4L2_CID_DETECT_MD_REGION_GRID: u32 = 10684676;
pub const VIDEO_MAX_FRAME: u32 = 32;
pub const VIDEO_MAX_PLANES: u32 = 8;
pub const V4L2_CAP_VIDEO_CAPTURE: u32 = 1;
pub const V4L2_CAP_VIDEO_OUTPUT: u32 = 2;
pub const V4L2_CAP_VIDEO_OVERLAY: u32 = 4;
pub const V4L2_CAP_VBI_CAPTURE: u32 = 16;
pub const V4L2_CAP_VBI_OUTPUT: u32 = 32;
pub const V4L2_CAP_SLICED_VBI_CAPTURE: u32 = 64;
pub const V4L2_CAP_SLICED_VBI_OUTPUT: u32 = 128;
pub const V4L2_CAP_RDS_CAPTURE: u32 = 256;
pub const V4L2_CAP_VIDEO_OUTPUT_OVERLAY: u32 = 512;
pub const V4L2_CAP_HW_FREQ_SEEK: u32 = 1024;
pub const V4L2_CAP_RDS_OUTPUT: u32 = 2048;
pub const V4L2_CAP_VIDEO_CAPTURE_MPLANE: u32 = 4096;
pub const V4L2_CAP_VIDEO_OUTPUT_MPLANE: u32 = 8192;
pub const V4L2_CAP_VIDEO_M2M_MPLANE: u32 = 16384;
pub const V4L2_CAP_VIDEO_M2M: u32 = 32768;
pub const V4L2_CAP_TUNER: u32 = 65536;
pub const V4L2_CAP_AUDIO: u32 = 131072;
pub const V4L2_CAP_RADIO: u32 = 262144;
pub const V4L2_CAP_MODULATOR: u32 = 524288;
pub const V4L2_CAP_SDR_CAPTURE: u32 = 1048576;
pub const V4L2_CAP_EXT_PIX_FORMAT: u32 = 2097152;
pub const V4L2_CAP_SDR_OUTPUT: u32 = 4194304;
pub const V4L2_CAP_META_CAPTURE: u32 = 8388608;
pub const V4L2_CAP_READWRITE: u32 = 16777216;
pub const V4L2_CAP_ASYNCIO: u32 = 33554432;
pub const V4L2_CAP_STREAMING: u32 = 67108864;
pub const V4L2_CAP_META_OUTPUT: u32 = 134217728;
pub const V4L2_CAP_TOUCH: u32 = 268435456;
pub const V4L2_CAP_DEVICE_CAPS: u32 = 2147483648;
pub const V4L2_PIX_FMT_PRIV_MAGIC: u32 = 4276996862;
pub const V4L2_PIX_FMT_FLAG_PREMUL_ALPHA: u32 = 1;
pub const V4L2_FMT_FLAG_COMPRESSED: u32 = 1;
pub const V4L2_FMT_FLAG_EMULATED: u32 = 2;
pub const V4L2_TC_TYPE_24FPS: u32 = 1;
pub const V4L2_TC_TYPE_25FPS: u32 = 2;
pub const V4L2_TC_TYPE_30FPS: u32 = 3;
pub const V4L2_TC_TYPE_50FPS: u32 = 4;
pub const V4L2_TC_TYPE_60FPS: u32 = 5;
pub const V4L2_TC_FLAG_DROPFRAME: u32 = 1;
pub const V4L2_TC_FLAG_COLORFRAME: u32 = 2;
pub const V4L2_TC_USERBITS_field: u32 = 12;
pub const V4L2_TC_USERBITS_USERDEFINED: u32 = 0;
pub const V4L2_TC_USERBITS_8BITCHARS: u32 = 8;
pub const V4L2_JPEG_MARKER_DHT: u32 = 8;
pub const V4L2_JPEG_MARKER_DQT: u32 = 16;
pub const V4L2_JPEG_MARKER_DRI: u32 = 32;
pub const V4L2_JPEG_MARKER_COM: u32 = 64;
pub const V4L2_JPEG_MARKER_APP: u32 = 128;
pub const V4L2_BUF_CAP_SUPPORTS_MMAP: u32 = 1;
pub const V4L2_BUF_CAP_SUPPORTS_USERPTR: u32 = 2;
pub const V4L2_BUF_CAP_SUPPORTS_DMABUF: u32 = 4;
pub const V4L2_BUF_CAP_SUPPORTS_REQUESTS: u32 = 8;
pub const V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS: u32 = 16;
pub const V4L2_BUF_FLAG_MAPPED: u32 = 1;
pub const V4L2_BUF_FLAG_QUEUED: u32 = 2;
pub const V4L2_BUF_FLAG_DONE: u32 = 4;
pub const V4L2_BUF_FLAG_KEYFRAME: u32 = 8;
pub const V4L2_BUF_FLAG_PFRAME: u32 = 16;
pub const V4L2_BUF_FLAG_BFRAME: u32 = 32;
pub const V4L2_BUF_FLAG_ERROR: u32 = 64;
pub const V4L2_BUF_FLAG_IN_REQUEST: u32 = 128;
pub const V4L2_BUF_FLAG_TIMECODE: u32 = 256;
pub const V4L2_BUF_FLAG_PREPARED: u32 = 1024;
pub const V4L2_BUF_FLAG_NO_CACHE_INVALIDATE: u32 = 2048;
pub const V4L2_BUF_FLAG_NO_CACHE_CLEAN: u32 = 4096;
pub const V4L2_BUF_FLAG_TIMESTAMP_MASK: u32 = 57344;
pub const V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN: u32 = 0;
pub const V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC: u32 = 8192;
pub const V4L2_BUF_FLAG_TIMESTAMP_COPY: u32 = 16384;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_MASK: u32 = 458752;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_EOF: u32 = 0;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_SOE: u32 = 65536;
pub const V4L2_BUF_FLAG_LAST: u32 = 1048576;
pub const V4L2_BUF_FLAG_REQUEST_FD: u32 = 8388608;
pub const V4L2_FBUF_CAP_EXTERNOVERLAY: u32 = 1;
pub const V4L2_FBUF_CAP_CHROMAKEY: u32 = 2;
pub const V4L2_FBUF_CAP_LIST_CLIPPING: u32 = 4;
pub const V4L2_FBUF_CAP_BITMAP_CLIPPING: u32 = 8;
pub const V4L2_FBUF_CAP_LOCAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_CAP_GLOBAL_ALPHA: u32 = 32;
pub const V4L2_FBUF_CAP_LOCAL_INV_ALPHA: u32 = 64;
pub const V4L2_FBUF_CAP_SRC_CHROMAKEY: u32 = 128;
pub const V4L2_FBUF_FLAG_PRIMARY: u32 = 1;
pub const V4L2_FBUF_FLAG_OVERLAY: u32 = 2;
pub const V4L2_FBUF_FLAG_CHROMAKEY: u32 = 4;
pub const V4L2_FBUF_FLAG_LOCAL_ALPHA: u32 = 8;
pub const V4L2_FBUF_FLAG_GLOBAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_FLAG_LOCAL_INV_ALPHA: u32 = 32;
pub const V4L2_FBUF_FLAG_SRC_CHROMAKEY: u32 = 64;
pub const V4L2_MODE_HIGHQUALITY: u32 = 1;
pub const V4L2_CAP_TIMEPERFRAME: u32 = 4096;
pub const V4L2_STD_UNKNOWN: u32 = 0;
pub const V4L2_DV_PROGRESSIVE: u32 = 0;
pub const V4L2_DV_INTERLACED: u32 = 1;
pub const V4L2_DV_VSYNC_POS_POL: u32 = 1;
pub const V4L2_DV_HSYNC_POS_POL: u32 = 2;
pub const V4L2_DV_BT_STD_CEA861: u32 = 1;
pub const V4L2_DV_BT_STD_DMT: u32 = 2;
pub const V4L2_DV_BT_STD_CVT: u32 = 4;
pub const V4L2_DV_BT_STD_GTF: u32 = 8;
pub const V4L2_DV_BT_STD_SDI: u32 = 16;
pub const V4L2_DV_FL_REDUCED_BLANKING: u32 = 1;
pub const V4L2_DV_FL_CAN_REDUCE_FPS: u32 = 2;
pub const V4L2_DV_FL_REDUCED_FPS: u32 = 4;
pub const V4L2_DV_FL_HALF_LINE: u32 = 8;
pub const V4L2_DV_FL_IS_CE_VIDEO: u32 = 16;
pub const V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE: u32 = 32;
pub const V4L2_DV_FL_HAS_PICTURE_ASPECT: u32 = 64;
pub const V4L2_DV_FL_HAS_CEA861_VIC: u32 = 128;
pub const V4L2_DV_FL_HAS_HDMI_VIC: u32 = 256;
pub const V4L2_DV_FL_CAN_DETECT_REDUCED_FPS: u32 = 512;
pub const V4L2_DV_BT_656_1120: u32 = 0;
pub const V4L2_DV_BT_CAP_INTERLACED: u32 = 1;
pub const V4L2_DV_BT_CAP_PROGRESSIVE: u32 = 2;
pub const V4L2_DV_BT_CAP_REDUCED_BLANKING: u32 = 4;
pub const V4L2_DV_BT_CAP_CUSTOM: u32 = 8;
pub const V4L2_INPUT_TYPE_TUNER: u32 = 1;
pub const V4L2_INPUT_TYPE_CAMERA: u32 = 2;
pub const V4L2_INPUT_TYPE_TOUCH: u32 = 3;
pub const V4L2_IN_ST_NO_POWER: u32 = 1;
pub const V4L2_IN_ST_NO_SIGNAL: u32 = 2;
pub const V4L2_IN_ST_NO_COLOR: u32 = 4;
pub const V4L2_IN_ST_HFLIP: u32 = 16;
pub const V4L2_IN_ST_VFLIP: u32 = 32;
pub const V4L2_IN_ST_NO_H_LOCK: u32 = 256;
pub const V4L2_IN_ST_COLOR_KILL: u32 = 512;
pub const V4L2_IN_ST_NO_V_LOCK: u32 = 1024;
pub const V4L2_IN_ST_NO_STD_LOCK: u32 = 2048;
pub const V4L2_IN_ST_NO_SYNC: u32 = 65536;
pub const V4L2_IN_ST_NO_EQU: u32 = 131072;
pub const V4L2_IN_ST_NO_CARRIER: u32 = 262144;
pub const V4L2_IN_ST_MACROVISION: u32 = 16777216;
pub const V4L2_IN_ST_NO_ACCESS: u32 = 33554432;
pub const V4L2_IN_ST_VTR: u32 = 67108864;
pub const V4L2_IN_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_STD: u32 = 4;
pub const V4L2_IN_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_OUTPUT_TYPE_MODULATOR: u32 = 1;
pub const V4L2_OUTPUT_TYPE_ANALOG: u32 = 2;
pub const V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY: u32 = 3;
pub const V4L2_OUT_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_STD: u32 = 4;
pub const V4L2_OUT_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_CTRL_ID_MASK: u32 = 268435455;
pub const V4L2_CTRL_MAX_DIMS: u32 = 4;
pub const V4L2_CTRL_WHICH_CUR_VAL: u32 = 0;
pub const V4L2_CTRL_WHICH_DEF_VAL: u32 = 251658240;
pub const V4L2_CTRL_WHICH_REQUEST_VAL: u32 = 251723776;
pub const V4L2_CTRL_FLAG_DISABLED: u32 = 1;
pub const V4L2_CTRL_FLAG_GRABBED: u32 = 2;
pub const V4L2_CTRL_FLAG_READ_ONLY: u32 = 4;
pub const V4L2_CTRL_FLAG_UPDATE: u32 = 8;
pub const V4L2_CTRL_FLAG_INACTIVE: u32 = 16;
pub const V4L2_CTRL_FLAG_SLIDER: u32 = 32;
pub const V4L2_CTRL_FLAG_WRITE_ONLY: u32 = 64;
pub const V4L2_CTRL_FLAG_VOLATILE: u32 = 128;
pub const V4L2_CTRL_FLAG_HAS_PAYLOAD: u32 = 256;
pub const V4L2_CTRL_FLAG_EXECUTE_ON_WRITE: u32 = 512;
pub const V4L2_CTRL_FLAG_MODIFY_LAYOUT: u32 = 1024;
pub const V4L2_CTRL_FLAG_NEXT_CTRL: u32 = 2147483648;
pub const V4L2_CTRL_FLAG_NEXT_COMPOUND: u32 = 1073741824;
pub const V4L2_CID_MAX_CTRLS: u32 = 1024;
pub const V4L2_CID_PRIVATE_BASE: u32 = 134217728;
pub const V4L2_TUNER_CAP_LOW: u32 = 1;
pub const V4L2_TUNER_CAP_NORM: u32 = 2;
pub const V4L2_TUNER_CAP_HWSEEK_BOUNDED: u32 = 4;
pub const V4L2_TUNER_CAP_HWSEEK_WRAP: u32 = 8;
pub const V4L2_TUNER_CAP_STEREO: u32 = 16;
pub const V4L2_TUNER_CAP_LANG2: u32 = 32;
pub const V4L2_TUNER_CAP_SAP: u32 = 32;
pub const V4L2_TUNER_CAP_LANG1: u32 = 64;
pub const V4L2_TUNER_CAP_RDS: u32 = 128;
pub const V4L2_TUNER_CAP_RDS_BLOCK_IO: u32 = 256;
pub const V4L2_TUNER_CAP_RDS_CONTROLS: u32 = 512;
pub const V4L2_TUNER_CAP_FREQ_BANDS: u32 = 1024;
pub const V4L2_TUNER_CAP_HWSEEK_PROG_LIM: u32 = 2048;
pub const V4L2_TUNER_CAP_1HZ: u32 = 4096;
pub const V4L2_TUNER_SUB_MONO: u32 = 1;
pub const V4L2_TUNER_SUB_STEREO: u32 = 2;
pub const V4L2_TUNER_SUB_LANG2: u32 = 4;
pub const V4L2_TUNER_SUB_SAP: u32 = 4;
pub const V4L2_TUNER_SUB_LANG1: u32 = 8;
pub const V4L2_TUNER_SUB_RDS: u32 = 16;
pub const V4L2_TUNER_MODE_MONO: u32 = 0;
pub const V4L2_TUNER_MODE_STEREO: u32 = 1;
pub const V4L2_TUNER_MODE_LANG2: u32 = 2;
pub const V4L2_TUNER_MODE_SAP: u32 = 2;
pub const V4L2_TUNER_MODE_LANG1: u32 = 3;
pub const V4L2_TUNER_MODE_LANG1_LANG2: u32 = 4;
pub const V4L2_BAND_MODULATION_VSB: u32 = 2;
pub const V4L2_BAND_MODULATION_FM: u32 = 4;
pub const V4L2_BAND_MODULATION_AM: u32 = 8;
pub const V4L2_RDS_BLOCK_MSK: u32 = 7;
pub const V4L2_RDS_BLOCK_A: u32 = 0;
pub const V4L2_RDS_BLOCK_B: u32 = 1;
pub const V4L2_RDS_BLOCK_C: u32 = 2;
pub const V4L2_RDS_BLOCK_D: u32 = 3;
pub const V4L2_RDS_BLOCK_C_ALT: u32 = 4;
pub const V4L2_RDS_BLOCK_INVALID: u32 = 7;
pub const V4L2_RDS_BLOCK_CORRECTED: u32 = 64;
pub const V4L2_RDS_BLOCK_ERROR: u32 = 128;
pub const V4L2_AUDCAP_STEREO: u32 = 1;
pub const V4L2_AUDCAP_AVL: u32 = 2;
pub const V4L2_AUDMODE_AVL: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_I: u32 = 0;
pub const V4L2_ENC_IDX_FRAME_P: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_B: u32 = 2;
pub const V4L2_ENC_IDX_FRAME_MASK: u32 = 15;
pub const V4L2_ENC_IDX_ENTRIES: u32 = 64;
pub const V4L2_ENC_CMD_START: u32 = 0;
pub const V4L2_ENC_CMD_STOP: u32 = 1;
pub const V4L2_ENC_CMD_PAUSE: u32 = 2;
pub const V4L2_ENC_CMD_RESUME: u32 = 3;
pub const V4L2_ENC_CMD_STOP_AT_GOP_END: u32 = 1;
pub const V4L2_DEC_CMD_START: u32 = 0;
pub const V4L2_DEC_CMD_STOP: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE: u32 = 2;
pub const V4L2_DEC_CMD_RESUME: u32 = 3;
pub const V4L2_DEC_CMD_START_MUTE_AUDIO: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_IMMEDIATELY: u32 = 2;
pub const V4L2_DEC_START_FMT_NONE: u32 = 0;
pub const V4L2_DEC_START_FMT_GOP: u32 = 1;
pub const V4L2_VBI_UNSYNC: u32 = 1;
pub const V4L2_VBI_INTERLACED: u32 = 2;
pub const V4L2_VBI_ITU_525_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_525_F2_START: u32 = 264;
pub const V4L2_VBI_ITU_625_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_625_F2_START: u32 = 314;
pub const V4L2_SLICED_TELETEXT_B: u32 = 1;
pub const V4L2_SLICED_VPS: u32 = 1024;
pub const V4L2_SLICED_CAPTION_525: u32 = 4096;
pub const V4L2_SLICED_WSS_625: u32 = 16384;
pub const V4L2_SLICED_VBI_525: u32 = 4096;
pub const V4L2_SLICED_VBI_625: u32 = 17409;
pub const V4L2_MPEG_VBI_IVTV_TELETEXT_B: u32 = 1;
pub const V4L2_MPEG_VBI_IVTV_CAPTION_525: u32 = 4;
pub const V4L2_MPEG_VBI_IVTV_WSS_625: u32 = 5;
pub const V4L2_MPEG_VBI_IVTV_VPS: u32 = 7;
pub const V4L2_MPEG_VBI_IVTV_MAGIC0: &[u8; 5] = b"itv0\0";
pub const V4L2_MPEG_VBI_IVTV_MAGIC1: &[u8; 5] = b"ITV0\0";
pub const V4L2_EVENT_ALL: u32 = 0;
pub const V4L2_EVENT_VSYNC: u32 = 1;
pub const V4L2_EVENT_EOS: u32 = 2;
pub const V4L2_EVENT_CTRL: u32 = 3;
pub const V4L2_EVENT_FRAME_SYNC: u32 = 4;
pub const V4L2_EVENT_SOURCE_CHANGE: u32 = 5;
pub const V4L2_EVENT_MOTION_DET: u32 = 6;
pub const V4L2_EVENT_PRIVATE_START: u32 = 134217728;
pub const V4L2_EVENT_CTRL_CH_VALUE: u32 = 1;
pub const V4L2_EVENT_CTRL_CH_FLAGS: u32 = 2;
pub const V4L2_EVENT_CTRL_CH_RANGE: u32 = 4;
pub const V4L2_EVENT_SRC_CH_RESOLUTION: u32 = 1;
pub const V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ: u32 = 1;
pub const V4L2_EVENT_SUB_FL_SEND_INITIAL: u32 = 1;
pub const V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK: u32 = 2;
pub const V4L2_CHIP_MATCH_BRIDGE: u32 = 0;
pub const V4L2_CHIP_MATCH_SUBDEV: u32 = 4;
pub const V4L2_CHIP_MATCH_HOST: u32 = 0;
pub const V4L2_CHIP_MATCH_I2C_DRIVER: u32 = 1;
pub const V4L2_CHIP_MATCH_I2C_ADDR: u32 = 2;
pub const V4L2_CHIP_MATCH_AC97: u32 = 3;
pub const V4L2_CHIP_FL_READABLE: u32 = 1;
pub const V4L2_CHIP_FL_WRITABLE: u32 = 2;
pub const BASE_VIDIOC_PRIVATE: u32 = 192;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const IMP_IVS_DEFAULT_TIMEOUTMS: i32 = -1;
pub const IMP_LOG_OUT_STDOUT: u32 = 0;
pub const IMP_LOG_OUT_LOCAL_FILE: u32 = 1;
pub const IMP_LOG_OUT_SERVER: u32 = 2;
pub const IMP_LOG_OUT_DEFAULT: u32 = 0;
pub const IMP_LOG_OP_PID_SHIFT: u32 = 0;
pub const IMP_LOG_OP_USTIME_SHIFT: u32 = 1;
pub const IMP_LOG_OP_MODULE_SHIFT: u32 = 2;
pub const IMP_LOG_OP_FILE_SHIFT: u32 = 3;
pub const IMP_LOG_OP_FUNC_SHIFT: u32 = 4;
pub const IMP_LOG_OP_LINE_SHIFT: u32 = 5;
pub const IMP_LOG_OP_PID: u32 = 1;
pub const IMP_LOG_OP_USTIME: u32 = 2;
pub const IMP_LOG_OP_MODULE: u32 = 4;
pub const IMP_LOG_OP_FILE: u32 = 8;
pub const IMP_LOG_OP_FUNC: u32 = 16;
pub const IMP_LOG_OP_LINE: u32 = 32;
pub const IMP_LOG_OP_NONE: u32 = 0;
pub const IMP_LOG_OP_ALL: u32 = 63;
pub const IMP_LOG_OP_DEFAULT: u32 = 63;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _SEMAPHORE_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 16;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 0;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 0;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 0;
pub const __FP_LOGBNAN_IS_MIN: u32 = 0;
pub const FP_ILOGB0: i32 = -2147483647;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: u32 = 1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: u32 = 1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 43] = b"-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_LINUX_OLD: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 1;
pub const _STAT_VER_SVR4: u32 = 2;
pub const _STAT_VER_LINUX: u32 = 3;
pub const _STAT_VER: u32 = 3;
pub const _MKNOD_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_SVR4: u32 = 2;
pub const _MKNOD_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _FCNTL_H: u32 = 1;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 16400;
pub const O_NONBLOCK: u32 = 128;
pub const O_CREAT: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_EXCL: u32 = 1024;
pub const O_NOCTTY: u32 = 2048;
pub const O_ASYNC: u32 = 4096;
pub const __O_DIRECT: u32 = 32768;
pub const __O_DSYNC: u32 = 16;
pub const __O_LARGEFILE: u32 = 8192;
pub const F_GETLK: u32 = 14;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_GETLK64: u32 = 33;
pub const F_SETLK64: u32 = 34;
pub const F_SETLKW64: u32 = 35;
pub const __F_SETOWN: u32 = 24;
pub const __F_GETOWN: u32 = 23;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_NDELAY: u32 = 128;
pub const O_FSYNC: u32 = 16400;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4259840;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 16;
pub const O_RSYNC: u32 = 16400;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_SETOWN: u32 = 24;
pub const F_GETOWN: u32 = 23;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 8;
pub const FFSYNC: u32 = 16400;
pub const FASYNC: u32 = 4096;
pub const FNONBLOCK: u32 = 128;
pub const FNDELAY: u32 = 128;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const MAXSUPCHNMUN: u32 = 2;
pub const MAXISPOSDPIC: u32 = 8;
pub const INVHANDLE: i32 = -1;
pub const MAX_AUDIO_FRAME_NUM: u32 = 50;
pub const REINIT: i32 = -10;
pub const INIT_FAILED: i32 = -11;
pub const FAILED_GETHANDLE: i32 = -12;
pub const INVALID_PARA: i32 = -13;
pub const SET_PARA_FAILED: i32 = -14;
pub const FAILURE: i32 = -15;
pub const SET_DATALEN_ERR: i32 = -16;
pub const EXIT_ERR: i32 = -17;
pub const UNINIT: i32 = -18;
pub const FAILED_DESHANDLE: i32 = -19;
pub const DEVICE_ID_MAGIC: &[u8; 5] = b"53ef\0";
pub const DEVICE_ID_MAGIC_LEN: u32 = 4;
pub const DEVICE_ID_LEN: u32 = 32;
pub const MAX_INFO_LEN: u32 = 64;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_longlong;
pub type __u_quad_t = libc::c_ulonglong;
pub type __intmax_t = libc::c_longlong;
pub type __uintmax_t = libc::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = libc::c_int;
pub type __ssize_t = libc::c_int;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_int;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type __time64_t = __int64_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_int;
pub type int_fast32_t = libc::c_int;
pub type int_fast64_t = libc::c_longlong;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_uint;
pub type uint_fast32_t = libc::c_uint;
pub type uint_fast64_t = libc::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitmapinfo {
    pub width: u32,
    pub pdata: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bitmapinfo"][::core::mem::size_of::<bitmapinfo>() - 8usize];
    ["Alignment of bitmapinfo"][::core::mem::align_of::<bitmapinfo>() - 4usize];
    ["Offset of field: bitmapinfo::width"][::core::mem::offset_of!(bitmapinfo, width) - 0usize];
    ["Offset of field: bitmapinfo::pdata"][::core::mem::offset_of!(bitmapinfo, pdata) - 4usize];
};
impl Default for bitmapinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bitmapinfo_t = bitmapinfo;
pub const gBgramapHight: libc::c_int = 34;
pub const gBgramapWidthMax: libc::c_int = 32;
extern "C" {
    pub static mut num0_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num1_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num2_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num3_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num4_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num5_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num6_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num7_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num8_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num9_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut minus_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut blank_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut colon_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut gBgramap: [bitmapinfo_t; 13usize];
}
pub const gBgramapHight_sec: libc::c_int = 18;
pub const gBgramapWidthMax_sec: libc::c_int = 16;
extern "C" {
    pub static mut num0_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num1_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num2_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num3_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num4_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num5_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num6_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num7_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num8_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num9_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut minus_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut blank_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut colon_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut gBgramap_sec: [bitmapinfo_t; 13usize];
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 8usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 4usize];
    ["Offset of field: timespec::tv_sec"][::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::core::mem::offset_of!(timespec, tv_nsec) - 4usize];
};
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::core::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::core::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::core::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
pub type __cpu_mask = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::core::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::core::mem::align_of::<cpu_set_t>() - 4usize];
    ["Offset of field: cpu_set_t::__bits"][::core::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> libc::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn sched_yield() -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> libc::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::core::mem::size_of::<tm>() - 44usize];
    ["Alignment of tm"][::core::mem::align_of::<tm>() - 4usize];
    ["Offset of field: tm::tm_sec"][::core::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::core::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::core::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::core::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::core::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::core::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::core::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::core::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::core::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::core::mem::offset_of!(tm, tm_gmtoff) - 36usize];
    ["Offset of field: tm::tm_zone"][::core::mem::offset_of!(tm, tm_zone) - 40usize];
};
impl Default for tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::core::mem::size_of::<itimerspec>() - 16usize];
    ["Alignment of itimerspec"][::core::mem::align_of::<itimerspec>() - 4usize];
    ["Offset of field: itimerspec::it_interval"]
        [::core::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::core::mem::offset_of!(itimerspec, it_value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::core::mem::size_of::<__locale_struct>() - 116usize];
    ["Alignment of __locale_struct"][::core::mem::align_of::<__locale_struct>() - 4usize];
    ["Offset of field: __locale_struct::__locales"]
        [::core::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::core::mem::offset_of!(__locale_struct, __ctype_b) - 52usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::core::mem::offset_of!(__locale_struct, __ctype_tolower) - 56usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::core::mem::offset_of!(__locale_struct, __ctype_toupper) - 60usize];
    ["Offset of field: __locale_struct::__names"]
        [::core::mem::offset_of!(__locale_struct, __names) - 64usize];
};
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> libc::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __flags: libc::c_uchar,
    pub __shared: libc::c_uchar,
    pub __pad1: libc::c_uchar,
    pub __pad2: libc::c_uchar,
    pub __cur_writer: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"]
        [::core::mem::size_of::<__pthread_rwlock_arch_t>() - 32usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::core::mem::align_of::<__pthread_rwlock_arch_t>() - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 25usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 26usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 27usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::core::mem::size_of::<__pthread_internal_slist>() - 4usize];
    ["Alignment of __pthread_internal_slist"]
        [::core::mem::align_of::<__pthread_internal_slist>() - 4usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::core::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __kind: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __anon1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __spins: libc::c_int,
    pub __list: __pthread_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_mutex_s__bindgen_ty_1>() - 4usize];
    ["Alignment of __pthread_mutex_s__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_mutex_s__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_mutex_s__bindgen_ty_1::__spins"]
        [::core::mem::offset_of!(__pthread_mutex_s__bindgen_ty_1, __spins) - 0usize];
    ["Offset of field: __pthread_mutex_s__bindgen_ty_1::__list"]
        [::core::mem::offset_of!(__pthread_mutex_s__bindgen_ty_1, __list) - 0usize];
};
impl Default for __pthread_mutex_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::core::mem::size_of::<__pthread_mutex_s>() - 24usize];
    ["Alignment of __pthread_mutex_s"][::core::mem::align_of::<__pthread_mutex_s>() - 4usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::core::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::core::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::core::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::core::mem::offset_of!(__pthread_mutex_s, __kind) - 12usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::core::mem::offset_of!(__pthread_mutex_s, __nusers) - 16usize];
};
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __anon1: __pthread_cond_s__bindgen_ty_1,
    pub __anon2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__low"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__high"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq32"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq32) - 0usize];
};
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__low"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__high"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start32"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start32) - 0usize];
};
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::core::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::core::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::core::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::core::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::core::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::core::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::core::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::core::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::core::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::core::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::core::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::core::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 36usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::core::mem::size_of::<pthread_attr_t>() - 36usize];
    ["Alignment of pthread_attr_t"][::core::mem::align_of::<pthread_attr_t>() - 4usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::core::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::core::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 24usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::core::mem::size_of::<pthread_mutex_t>() - 24usize];
    ["Alignment of pthread_mutex_t"][::core::mem::align_of::<pthread_mutex_t>() - 4usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::core::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::core::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::core::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::core::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::core::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::core::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::core::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::core::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::core::mem::size_of::<pthread_rwlock_t>() - 32usize];
    ["Alignment of pthread_rwlock_t"][::core::mem::align_of::<pthread_rwlock_t>() - 4usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::core::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::core::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::core::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::core::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::core::mem::align_of::<pthread_rwlockattr_t>() - 4usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::core::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::core::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 20usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::core::mem::size_of::<pthread_barrier_t>() - 20usize];
    ["Alignment of pthread_barrier_t"][::core::mem::align_of::<pthread_barrier_t>() - 4usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::core::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::core::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::core::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::core::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::core::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::core::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_internal_tag {
    pub __pc: *mut libc::c_void,
    pub __sp: *mut libc::c_void,
    pub __regs: [libc::c_int; 8usize],
    pub __fp: *mut libc::c_void,
    pub __gp: *mut libc::c_void,
    pub __glibc_reserved1: libc::c_int,
    pub __fpregs: [f64; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_internal_tag"][::core::mem::size_of::<__jmp_buf_internal_tag>() - 104usize];
    ["Alignment of __jmp_buf_internal_tag"]
        [::core::mem::align_of::<__jmp_buf_internal_tag>() - 8usize];
    ["Offset of field: __jmp_buf_internal_tag::__pc"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __pc) - 0usize];
    ["Offset of field: __jmp_buf_internal_tag::__sp"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __sp) - 4usize];
    ["Offset of field: __jmp_buf_internal_tag::__regs"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __regs) - 8usize];
    ["Offset of field: __jmp_buf_internal_tag::__fp"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __fp) - 40usize];
    ["Offset of field: __jmp_buf_internal_tag::__gp"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __gp) - 44usize];
    ["Offset of field: __jmp_buf_internal_tag::__glibc_reserved1"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __glibc_reserved1) - 48usize];
    ["Offset of field: __jmp_buf_internal_tag::__fpregs"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __fpregs) - 56usize];
};
impl Default for __jmp_buf_internal_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __jmp_buf = [__jmp_buf_internal_tag; 1usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = _bindgen_ty_1::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = _bindgen_ty_1::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = _bindgen_ty_6::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = _bindgen_ty_6::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = _bindgen_ty_7::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = _bindgen_ty_7::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = _bindgen_ty_8::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = _bindgen_ty_8::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __canceltype: libc::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"]
        [::core::mem::size_of::<_pthread_cleanup_buffer>() - 16usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::core::mem::align_of::<_pthread_cleanup_buffer>() - 4usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 4usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 12usize];
};
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = _bindgen_ty_9::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = _bindgen_ty_9::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = _bindgen_ty_10::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = _bindgen_ty_10::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_10 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut libc::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t, __scope: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut libc::c_void,
        __stacksize: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut libc::c_void,
        __stacksize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut libc::c_int,
        __param: *mut sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: libc::c_int,
        __oldstate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: libc::c_int, __oldtype: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut libc::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() - 112usize];
    ["Alignment of __pthread_unwind_buf_t__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t__bindgen_ty_1::__cancel_jmp_buf"]
        [::core::mem::offset_of!(__pthread_unwind_buf_t__bindgen_ty_1, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t__bindgen_ty_1::__mask_was_saved"][::core::mem::offset_of!(
        __pthread_unwind_buf_t__bindgen_ty_1,
        __mask_was_saved
    ) - 104usize];
};
impl Default for __pthread_unwind_buf_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::core::mem::size_of::<__pthread_unwind_buf_t>() - 128usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::core::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::core::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::core::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 112usize];
};
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __cancel_arg: *mut libc::c_void,
    pub __do_it: libc::c_int,
    pub __cancel_type: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"]
        [::core::mem::size_of::<__pthread_cleanup_frame>() - 16usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::core::mem::align_of::<__pthread_cleanup_frame>() - 4usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 4usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 12usize];
};
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: libc::c_int,
        __old_ceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t, __pointer: *const libc::c_void)
        -> libc::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::core::mem::size_of::<timeval>() - 8usize];
    ["Alignment of timeval"][::core::mem::align_of::<timeval>() - 4usize];
    ["Offset of field: timeval::tv_sec"][::core::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::core::mem::offset_of!(timeval, tv_usec) - 4usize];
};
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::core::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::core::mem::align_of::<__sigset_t>() - 4usize];
    ["Offset of field: __sigset_t::__val"][::core::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::core::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::core::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::__fds_bits"][::core::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timezone"][::core::mem::size_of::<timezone>() - 8usize];
    ["Alignment of timezone"][::core::mem::align_of::<timezone>() - 4usize];
    ["Offset of field: timezone::tz_minuteswest"]
        [::core::mem::offset_of!(timezone, tz_minuteswest) - 0usize];
    ["Offset of field: timezone::tz_dsttime"]
        [::core::mem::offset_of!(timezone, tz_dsttime) - 4usize];
};
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerval"][::core::mem::size_of::<itimerval>() - 16usize];
    ["Alignment of itimerval"][::core::mem::align_of::<itimerval>() - 4usize];
    ["Offset of field: itimerval::it_interval"]
        [::core::mem::offset_of!(itimerval, it_interval) - 0usize];
    ["Offset of field: itimerval::it_value"][::core::mem::offset_of!(itimerval, it_value) - 8usize];
};
pub type __itimer_which_t = libc::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: libc::c_int, __tvp: *const timeval) -> libc::c_int;
}
pub type __s8 = libc::c_schar;
pub type __u8 = libc::c_uchar;
pub type __s16 = libc::c_short;
pub type __u16 = libc::c_ushort;
pub type __s32 = libc::c_int;
pub type __u32 = libc::c_uint;
pub type __s64 = libc::c_longlong;
pub type __u64 = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [libc::c_ulong; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::core::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::core::mem::align_of::<__kernel_fd_set>() - 4usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::core::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
pub type __kernel_key_t = libc::c_int;
pub type __kernel_mqd_t = libc::c_int;
pub type __kernel_daddr_t = libc::c_long;
pub type __kernel_long_t = libc::c_long;
pub type __kernel_ulong_t = libc::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = libc::c_uint;
pub type __kernel_pid_t = libc::c_int;
pub type __kernel_ipc_pid_t = libc::c_int;
pub type __kernel_uid_t = libc::c_uint;
pub type __kernel_gid_t = libc::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_uid32_t = libc::c_uint;
pub type __kernel_gid32_t = libc::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_old_dev_t = libc::c_uint;
pub type __kernel_size_t = libc::c_uint;
pub type __kernel_ssize_t = libc::c_int;
pub type __kernel_ptrdiff_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::core::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::core::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::core::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = libc::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = libc::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = libc::c_int;
pub type __kernel_clockid_t = libc::c_int;
pub type __kernel_caddr_t = *mut libc::c_char;
pub type __kernel_uid16_t = libc::c_ushort;
pub type __kernel_gid16_t = libc::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_edid {
    pub pad: __u32,
    pub start_block: __u32,
    pub blocks: __u32,
    pub reserved: [__u32; 5usize],
    pub edid: *mut __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_edid"][::core::mem::size_of::<v4l2_edid>() - 36usize];
    ["Alignment of v4l2_edid"][::core::mem::align_of::<v4l2_edid>() - 4usize];
    ["Offset of field: v4l2_edid::pad"][::core::mem::offset_of!(v4l2_edid, pad) - 0usize];
    ["Offset of field: v4l2_edid::start_block"]
        [::core::mem::offset_of!(v4l2_edid, start_block) - 4usize];
    ["Offset of field: v4l2_edid::blocks"][::core::mem::offset_of!(v4l2_edid, blocks) - 8usize];
    ["Offset of field: v4l2_edid::reserved"]
        [::core::mem::offset_of!(v4l2_edid, reserved) - 12usize];
    ["Offset of field: v4l2_edid::edid"][::core::mem::offset_of!(v4l2_edid, edid) - 32usize];
};
impl Default for v4l2_edid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_power_line_frequency {
    V4L2_CID_POWER_LINE_FREQUENCY_DISABLED = 0,
    V4L2_CID_POWER_LINE_FREQUENCY_50HZ = 1,
    V4L2_CID_POWER_LINE_FREQUENCY_60HZ = 2,
    V4L2_CID_POWER_LINE_FREQUENCY_AUTO = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_colorfx {
    V4L2_COLORFX_NONE = 0,
    V4L2_COLORFX_BW = 1,
    V4L2_COLORFX_SEPIA = 2,
    V4L2_COLORFX_NEGATIVE = 3,
    V4L2_COLORFX_EMBOSS = 4,
    V4L2_COLORFX_SKETCH = 5,
    V4L2_COLORFX_SKY_BLUE = 6,
    V4L2_COLORFX_GRASS_GREEN = 7,
    V4L2_COLORFX_SKIN_WHITEN = 8,
    V4L2_COLORFX_VIVID = 9,
    V4L2_COLORFX_AQUA = 10,
    V4L2_COLORFX_ART_FREEZE = 11,
    V4L2_COLORFX_SILHOUETTE = 12,
    V4L2_COLORFX_SOLARIZATION = 13,
    V4L2_COLORFX_ANTIQUE = 14,
    V4L2_COLORFX_SET_CBCR = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_stream_type {
    V4L2_MPEG_STREAM_TYPE_MPEG2_PS = 0,
    V4L2_MPEG_STREAM_TYPE_MPEG2_TS = 1,
    V4L2_MPEG_STREAM_TYPE_MPEG1_SS = 2,
    V4L2_MPEG_STREAM_TYPE_MPEG2_DVD = 3,
    V4L2_MPEG_STREAM_TYPE_MPEG1_VCD = 4,
    V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_stream_vbi_fmt {
    V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,
    V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_sampling_freq {
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_encoding {
    V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
    V4L2_MPEG_AUDIO_ENCODING_AAC = 3,
    V4L2_MPEG_AUDIO_ENCODING_AC3 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_l1_bitrate {
    V4L2_MPEG_AUDIO_L1_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L1_BITRATE_64K = 1,
    V4L2_MPEG_AUDIO_L1_BITRATE_96K = 2,
    V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
    V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
    V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
    V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
    V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
    V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
    V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
    V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
    V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
    V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
    V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_l2_bitrate {
    V4L2_MPEG_AUDIO_L2_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L2_BITRATE_48K = 1,
    V4L2_MPEG_AUDIO_L2_BITRATE_56K = 2,
    V4L2_MPEG_AUDIO_L2_BITRATE_64K = 3,
    V4L2_MPEG_AUDIO_L2_BITRATE_80K = 4,
    V4L2_MPEG_AUDIO_L2_BITRATE_96K = 5,
    V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
    V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
    V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
    V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
    V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
    V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
    V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
    V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_l3_bitrate {
    V4L2_MPEG_AUDIO_L3_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L3_BITRATE_40K = 1,
    V4L2_MPEG_AUDIO_L3_BITRATE_48K = 2,
    V4L2_MPEG_AUDIO_L3_BITRATE_56K = 3,
    V4L2_MPEG_AUDIO_L3_BITRATE_64K = 4,
    V4L2_MPEG_AUDIO_L3_BITRATE_80K = 5,
    V4L2_MPEG_AUDIO_L3_BITRATE_96K = 6,
    V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
    V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
    V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
    V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
    V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
    V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
    V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_mode {
    V4L2_MPEG_AUDIO_MODE_STEREO = 0,
    V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
    V4L2_MPEG_AUDIO_MODE_DUAL = 2,
    V4L2_MPEG_AUDIO_MODE_MONO = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_mode_extension {
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4 = 0,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8 = 1,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_emphasis {
    V4L2_MPEG_AUDIO_EMPHASIS_NONE = 0,
    V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
    V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_crc {
    V4L2_MPEG_AUDIO_CRC_NONE = 0,
    V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_ac3_bitrate {
    V4L2_MPEG_AUDIO_AC3_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_AC3_BITRATE_40K = 1,
    V4L2_MPEG_AUDIO_AC3_BITRATE_48K = 2,
    V4L2_MPEG_AUDIO_AC3_BITRATE_56K = 3,
    V4L2_MPEG_AUDIO_AC3_BITRATE_64K = 4,
    V4L2_MPEG_AUDIO_AC3_BITRATE_80K = 5,
    V4L2_MPEG_AUDIO_AC3_BITRATE_96K = 6,
    V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
    V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
    V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
    V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
    V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
    V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
    V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
    V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
    V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
    V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
    V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
    V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_dec_playback {
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO = 0,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO = 1,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT = 2,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT = 3,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO = 4,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_encoding {
    V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_aspect {
    V4L2_MPEG_VIDEO_ASPECT_1x1 = 0,
    V4L2_MPEG_VIDEO_ASPECT_4x3 = 1,
    V4L2_MPEG_VIDEO_ASPECT_16x9 = 2,
    V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_bitrate_mode {
    V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
    V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_header_mode {
    V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE = 0,
    V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME = 1,
}
impl v4l2_mpeg_video_multi_slice_mode {
    pub const V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB: v4l2_mpeg_video_multi_slice_mode =
        v4l2_mpeg_video_multi_slice_mode::V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB;
}
impl v4l2_mpeg_video_multi_slice_mode {
    pub const V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES: v4l2_mpeg_video_multi_slice_mode =
        v4l2_mpeg_video_multi_slice_mode::V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_multi_slice_mode {
    V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE = 0,
    V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB = 1,
    V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg2_level {
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_LOW = 0,
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_MAIN = 1,
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH_1440 = 2,
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg2_profile {
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_SIMPLE = 0,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_MAIN = 1,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_SNR_SCALABLE = 2,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_SPATIALLY_SCALABLE = 3,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH = 4,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_MULTIVIEW = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_entropy_mode {
    V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC = 0,
    V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_level {
    V4L2_MPEG_VIDEO_H264_LEVEL_1_0 = 0,
    V4L2_MPEG_VIDEO_H264_LEVEL_1B = 1,
    V4L2_MPEG_VIDEO_H264_LEVEL_1_1 = 2,
    V4L2_MPEG_VIDEO_H264_LEVEL_1_2 = 3,
    V4L2_MPEG_VIDEO_H264_LEVEL_1_3 = 4,
    V4L2_MPEG_VIDEO_H264_LEVEL_2_0 = 5,
    V4L2_MPEG_VIDEO_H264_LEVEL_2_1 = 6,
    V4L2_MPEG_VIDEO_H264_LEVEL_2_2 = 7,
    V4L2_MPEG_VIDEO_H264_LEVEL_3_0 = 8,
    V4L2_MPEG_VIDEO_H264_LEVEL_3_1 = 9,
    V4L2_MPEG_VIDEO_H264_LEVEL_3_2 = 10,
    V4L2_MPEG_VIDEO_H264_LEVEL_4_0 = 11,
    V4L2_MPEG_VIDEO_H264_LEVEL_4_1 = 12,
    V4L2_MPEG_VIDEO_H264_LEVEL_4_2 = 13,
    V4L2_MPEG_VIDEO_H264_LEVEL_5_0 = 14,
    V4L2_MPEG_VIDEO_H264_LEVEL_5_1 = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_loop_filter_mode {
    V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED = 0,
    V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED = 1,
    V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_profile {
    V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE = 0,
    V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE = 1,
    V4L2_MPEG_VIDEO_H264_PROFILE_MAIN = 2,
    V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED = 3,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH = 4,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10 = 5,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422 = 6,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE = 7,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA = 8,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA = 9,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA = 10,
    V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA = 11,
    V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE = 12,
    V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH = 13,
    V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA = 14,
    V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH = 15,
    V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_vui_sar_idc {
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED = 0,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1 = 1,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11 = 2,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11 = 3,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11 = 4,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33 = 5,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11 = 6,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11 = 7,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11 = 8,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33 = 9,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11 = 10,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11 = 11,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33 = 12,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99 = 13,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3 = 14,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2 = 15,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1 = 16,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED = 17,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_sei_fp_arrangement_type {
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHECKERBOARD = 0,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN = 1,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW = 2,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE = 3,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM = 4,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_fmo_map_type {
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES = 0,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES = 1,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER = 2,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT = 3,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN = 4,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN = 5,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_fmo_change_dir {
    V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT = 0,
    V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_hierarchical_coding_type {
    V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B = 0,
    V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg4_level {
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_0 = 0,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B = 1,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_1 = 2,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_2 = 3,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_3 = 4,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_3B = 5,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_4 = 6,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_5 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg4_profile {
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE = 0,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE = 1,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_CORE = 2,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE = 3,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_vp8_num_partitions {
    V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION = 0,
    V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS = 1,
    V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS = 2,
    V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_vp8_num_ref_frames {
    V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME = 0,
    V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME = 1,
    V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_vp8_golden_frame_sel {
    V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV = 0,
    V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_vp8_profile {
    V4L2_MPEG_VIDEO_VP8_PROFILE_0 = 0,
    V4L2_MPEG_VIDEO_VP8_PROFILE_1 = 1,
    V4L2_MPEG_VIDEO_VP8_PROFILE_2 = 2,
    V4L2_MPEG_VIDEO_VP8_PROFILE_3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_vp9_profile {
    V4L2_MPEG_VIDEO_VP9_PROFILE_0 = 0,
    V4L2_MPEG_VIDEO_VP9_PROFILE_1 = 1,
    V4L2_MPEG_VIDEO_VP9_PROFILE_2 = 2,
    V4L2_MPEG_VIDEO_VP9_PROFILE_3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_hier_coding_type {
    V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B = 0,
    V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_P = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_profile {
    V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN = 0,
    V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE = 1,
    V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_level {
    V4L2_MPEG_VIDEO_HEVC_LEVEL_1 = 0,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_2 = 1,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1 = 2,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_3 = 3,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1 = 4,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_4 = 5,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1 = 6,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_5 = 7,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1 = 8,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2 = 9,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_6 = 10,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1 = 11,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2 = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_tier {
    V4L2_MPEG_VIDEO_HEVC_TIER_MAIN = 0,
    V4L2_MPEG_VIDEO_HEVC_TIER_HIGH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_cid_mpeg_video_hevc_loop_filter_mode {
    V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED = 0,
    V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED = 1,
    V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_cid_mpeg_video_hevc_refresh_type {
    V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE = 0,
    V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA = 1,
    V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_cid_mpeg_video_hevc_size_of_length_field {
    V4L2_MPEG_VIDEO_HEVC_SIZE_0 = 0,
    V4L2_MPEG_VIDEO_HEVC_SIZE_1 = 1,
    V4L2_MPEG_VIDEO_HEVC_SIZE_2 = 2,
    V4L2_MPEG_VIDEO_HEVC_SIZE_4 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE = 3,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_median_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_mfc51_video_frame_skip_mode {
    V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED = 0,
    V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT = 1,
    V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_mfc51_video_force_frame_type {
    V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED = 0,
    V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME = 1,
    V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_exposure_auto_type {
    V4L2_EXPOSURE_AUTO = 0,
    V4L2_EXPOSURE_MANUAL = 1,
    V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
    V4L2_EXPOSURE_APERTURE_PRIORITY = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_auto_n_preset_white_balance {
    V4L2_WHITE_BALANCE_MANUAL = 0,
    V4L2_WHITE_BALANCE_AUTO = 1,
    V4L2_WHITE_BALANCE_INCANDESCENT = 2,
    V4L2_WHITE_BALANCE_FLUORESCENT = 3,
    V4L2_WHITE_BALANCE_FLUORESCENT_H = 4,
    V4L2_WHITE_BALANCE_HORIZON = 5,
    V4L2_WHITE_BALANCE_DAYLIGHT = 6,
    V4L2_WHITE_BALANCE_FLASH = 7,
    V4L2_WHITE_BALANCE_CLOUDY = 8,
    V4L2_WHITE_BALANCE_SHADE = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_iso_sensitivity_auto_type {
    V4L2_ISO_SENSITIVITY_MANUAL = 0,
    V4L2_ISO_SENSITIVITY_AUTO = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_exposure_metering {
    V4L2_EXPOSURE_METERING_AVERAGE = 0,
    V4L2_EXPOSURE_METERING_CENTER_WEIGHTED = 1,
    V4L2_EXPOSURE_METERING_SPOT = 2,
    V4L2_EXPOSURE_METERING_MATRIX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_scene_mode {
    V4L2_SCENE_MODE_NONE = 0,
    V4L2_SCENE_MODE_BACKLIGHT = 1,
    V4L2_SCENE_MODE_BEACH_SNOW = 2,
    V4L2_SCENE_MODE_CANDLE_LIGHT = 3,
    V4L2_SCENE_MODE_DAWN_DUSK = 4,
    V4L2_SCENE_MODE_FALL_COLORS = 5,
    V4L2_SCENE_MODE_FIREWORKS = 6,
    V4L2_SCENE_MODE_LANDSCAPE = 7,
    V4L2_SCENE_MODE_NIGHT = 8,
    V4L2_SCENE_MODE_PARTY_INDOOR = 9,
    V4L2_SCENE_MODE_PORTRAIT = 10,
    V4L2_SCENE_MODE_SPORTS = 11,
    V4L2_SCENE_MODE_SUNSET = 12,
    V4L2_SCENE_MODE_TEXT = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_auto_focus_range {
    V4L2_AUTO_FOCUS_RANGE_AUTO = 0,
    V4L2_AUTO_FOCUS_RANGE_NORMAL = 1,
    V4L2_AUTO_FOCUS_RANGE_MACRO = 2,
    V4L2_AUTO_FOCUS_RANGE_INFINITY = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_preemphasis {
    V4L2_PREEMPHASIS_DISABLED = 0,
    V4L2_PREEMPHASIS_50_uS = 1,
    V4L2_PREEMPHASIS_75_uS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_flash_led_mode {
    V4L2_FLASH_LED_MODE_NONE = 0,
    V4L2_FLASH_LED_MODE_FLASH = 1,
    V4L2_FLASH_LED_MODE_TORCH = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_flash_strobe_source {
    V4L2_FLASH_STROBE_SOURCE_SOFTWARE = 0,
    V4L2_FLASH_STROBE_SOURCE_EXTERNAL = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_jpeg_chroma_subsampling {
    V4L2_JPEG_CHROMA_SUBSAMPLING_444 = 0,
    V4L2_JPEG_CHROMA_SUBSAMPLING_422 = 1,
    V4L2_JPEG_CHROMA_SUBSAMPLING_420 = 2,
    V4L2_JPEG_CHROMA_SUBSAMPLING_411 = 3,
    V4L2_JPEG_CHROMA_SUBSAMPLING_410 = 4,
    V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_dv_tx_mode {
    V4L2_DV_TX_MODE_DVI_D = 0,
    V4L2_DV_TX_MODE_HDMI = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_dv_rgb_range {
    V4L2_DV_RGB_RANGE_AUTO = 0,
    V4L2_DV_RGB_RANGE_LIMITED = 1,
    V4L2_DV_RGB_RANGE_FULL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_dv_it_content_type {
    V4L2_DV_IT_CONTENT_TYPE_GRAPHICS = 0,
    V4L2_DV_IT_CONTENT_TYPE_PHOTO = 1,
    V4L2_DV_IT_CONTENT_TYPE_CINEMA = 2,
    V4L2_DV_IT_CONTENT_TYPE_GAME = 3,
    V4L2_DV_IT_CONTENT_TYPE_NO_ITC = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_deemphasis {
    V4L2_DEEMPHASIS_DISABLED = 0,
    V4L2_DEEMPHASIS_50_uS = 1,
    V4L2_DEEMPHASIS_75_uS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_detect_md_mode {
    V4L2_DETECT_MD_MODE_DISABLED = 0,
    V4L2_DETECT_MD_MODE_GLOBAL = 1,
    V4L2_DETECT_MD_MODE_THRESHOLD_GRID = 2,
    V4L2_DETECT_MD_MODE_REGION_GRID = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_field {
    V4L2_FIELD_ANY = 0,
    V4L2_FIELD_NONE = 1,
    V4L2_FIELD_TOP = 2,
    V4L2_FIELD_BOTTOM = 3,
    V4L2_FIELD_INTERLACED = 4,
    V4L2_FIELD_SEQ_TB = 5,
    V4L2_FIELD_SEQ_BT = 6,
    V4L2_FIELD_ALTERNATE = 7,
    V4L2_FIELD_INTERLACED_TB = 8,
    V4L2_FIELD_INTERLACED_BT = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_SDR_OUTPUT = 12,
    V4L2_BUF_TYPE_META_CAPTURE = 13,
    V4L2_BUF_TYPE_META_OUTPUT = 14,
    V4L2_BUF_TYPE_PRIVATE = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_tuner_type {
    V4L2_TUNER_RADIO = 1,
    V4L2_TUNER_ANALOG_TV = 2,
    V4L2_TUNER_DIGITAL_TV = 3,
    V4L2_TUNER_SDR = 4,
    V4L2_TUNER_RF = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3,
    V4L2_MEMORY_DMABUF = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_colorspace {
    V4L2_COLORSPACE_DEFAULT = 0,
    V4L2_COLORSPACE_SMPTE170M = 1,
    V4L2_COLORSPACE_SMPTE240M = 2,
    V4L2_COLORSPACE_REC709 = 3,
    V4L2_COLORSPACE_BT878 = 4,
    V4L2_COLORSPACE_470_SYSTEM_M = 5,
    V4L2_COLORSPACE_470_SYSTEM_BG = 6,
    V4L2_COLORSPACE_JPEG = 7,
    V4L2_COLORSPACE_SRGB = 8,
    V4L2_COLORSPACE_OPRGB = 9,
    V4L2_COLORSPACE_BT2020 = 10,
    V4L2_COLORSPACE_RAW = 11,
    V4L2_COLORSPACE_DCI_P3 = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_xfer_func {
    V4L2_XFER_FUNC_DEFAULT = 0,
    V4L2_XFER_FUNC_709 = 1,
    V4L2_XFER_FUNC_SRGB = 2,
    V4L2_XFER_FUNC_OPRGB = 3,
    V4L2_XFER_FUNC_SMPTE240M = 4,
    V4L2_XFER_FUNC_NONE = 5,
    V4L2_XFER_FUNC_DCI_P3 = 6,
    V4L2_XFER_FUNC_SMPTE2084 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_ycbcr_encoding {
    V4L2_YCBCR_ENC_DEFAULT = 0,
    V4L2_YCBCR_ENC_601 = 1,
    V4L2_YCBCR_ENC_709 = 2,
    V4L2_YCBCR_ENC_XV601 = 3,
    V4L2_YCBCR_ENC_XV709 = 4,
    V4L2_YCBCR_ENC_SYCC = 5,
    V4L2_YCBCR_ENC_BT2020 = 6,
    V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
    V4L2_YCBCR_ENC_SMPTE240M = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_hsv_encoding {
    V4L2_HSV_ENC_180 = 128,
    V4L2_HSV_ENC_256 = 129,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_quantization {
    V4L2_QUANTIZATION_DEFAULT = 0,
    V4L2_QUANTIZATION_FULL_RANGE = 1,
    V4L2_QUANTIZATION_LIM_RANGE = 2,
}
impl v4l2_priority {
    pub const V4L2_PRIORITY_DEFAULT: v4l2_priority = v4l2_priority::V4L2_PRIORITY_INTERACTIVE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_rect {
    pub left: __s32,
    pub top: __s32,
    pub width: __u32,
    pub height: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_rect"][::core::mem::size_of::<v4l2_rect>() - 16usize];
    ["Alignment of v4l2_rect"][::core::mem::align_of::<v4l2_rect>() - 4usize];
    ["Offset of field: v4l2_rect::left"][::core::mem::offset_of!(v4l2_rect, left) - 0usize];
    ["Offset of field: v4l2_rect::top"][::core::mem::offset_of!(v4l2_rect, top) - 4usize];
    ["Offset of field: v4l2_rect::width"][::core::mem::offset_of!(v4l2_rect, width) - 8usize];
    ["Offset of field: v4l2_rect::height"][::core::mem::offset_of!(v4l2_rect, height) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_fract"][::core::mem::size_of::<v4l2_fract>() - 8usize];
    ["Alignment of v4l2_fract"][::core::mem::align_of::<v4l2_fract>() - 4usize];
    ["Offset of field: v4l2_fract::numerator"]
        [::core::mem::offset_of!(v4l2_fract, numerator) - 0usize];
    ["Offset of field: v4l2_fract::denominator"]
        [::core::mem::offset_of!(v4l2_fract, denominator) - 4usize];
};
#[doc = " struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP\n\n @driver:\t   name of the driver module (e.g. \"bttv\")\n @card:\t   name of the card (e.g. \"Hauppauge WinTV\")\n @bus_info:\t   name of the bus (e.g. \"PCI:\" + pci_name(pci_dev) )\n @version:\t   KERNEL_VERSION\n @capabilities: capabilities of the physical device as a whole\n @device_caps:  capabilities accessed via this particular device (node)\n @reserved:\t   reserved fields for future extensions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_capability {
    pub driver: [__u8; 16usize],
    pub card: [__u8; 32usize],
    pub bus_info: [__u8; 32usize],
    pub version: __u32,
    pub capabilities: __u32,
    pub device_caps: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_capability"][::core::mem::size_of::<v4l2_capability>() - 104usize];
    ["Alignment of v4l2_capability"][::core::mem::align_of::<v4l2_capability>() - 4usize];
    ["Offset of field: v4l2_capability::driver"]
        [::core::mem::offset_of!(v4l2_capability, driver) - 0usize];
    ["Offset of field: v4l2_capability::card"]
        [::core::mem::offset_of!(v4l2_capability, card) - 16usize];
    ["Offset of field: v4l2_capability::bus_info"]
        [::core::mem::offset_of!(v4l2_capability, bus_info) - 48usize];
    ["Offset of field: v4l2_capability::version"]
        [::core::mem::offset_of!(v4l2_capability, version) - 80usize];
    ["Offset of field: v4l2_capability::capabilities"]
        [::core::mem::offset_of!(v4l2_capability, capabilities) - 84usize];
    ["Offset of field: v4l2_capability::device_caps"]
        [::core::mem::offset_of!(v4l2_capability, device_caps) - 88usize];
    ["Offset of field: v4l2_capability::reserved"]
        [::core::mem::offset_of!(v4l2_capability, reserved) - 92usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
    pub flags: __u32,
    pub __anon1: v4l2_pix_format__bindgen_ty_1,
    pub quantization: __u32,
    pub xfer_func: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format__bindgen_ty_1 {
    pub ycbcr_enc: __u32,
    pub hsv_enc: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_pix_format__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_pix_format__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_pix_format__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_pix_format__bindgen_ty_1::ycbcr_enc"]
        [::core::mem::offset_of!(v4l2_pix_format__bindgen_ty_1, ycbcr_enc) - 0usize];
    ["Offset of field: v4l2_pix_format__bindgen_ty_1::hsv_enc"]
        [::core::mem::offset_of!(v4l2_pix_format__bindgen_ty_1, hsv_enc) - 0usize];
};
impl Default for v4l2_pix_format__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format"][::core::mem::size_of::<v4l2_pix_format>() - 48usize];
    ["Alignment of v4l2_pix_format"][::core::mem::align_of::<v4l2_pix_format>() - 4usize];
    ["Offset of field: v4l2_pix_format::width"]
        [::core::mem::offset_of!(v4l2_pix_format, width) - 0usize];
    ["Offset of field: v4l2_pix_format::height"]
        [::core::mem::offset_of!(v4l2_pix_format, height) - 4usize];
    ["Offset of field: v4l2_pix_format::pixelformat"]
        [::core::mem::offset_of!(v4l2_pix_format, pixelformat) - 8usize];
    ["Offset of field: v4l2_pix_format::field"]
        [::core::mem::offset_of!(v4l2_pix_format, field) - 12usize];
    ["Offset of field: v4l2_pix_format::bytesperline"]
        [::core::mem::offset_of!(v4l2_pix_format, bytesperline) - 16usize];
    ["Offset of field: v4l2_pix_format::sizeimage"]
        [::core::mem::offset_of!(v4l2_pix_format, sizeimage) - 20usize];
    ["Offset of field: v4l2_pix_format::colorspace"]
        [::core::mem::offset_of!(v4l2_pix_format, colorspace) - 24usize];
    ["Offset of field: v4l2_pix_format::priv_"]
        [::core::mem::offset_of!(v4l2_pix_format, priv_) - 28usize];
    ["Offset of field: v4l2_pix_format::flags"]
        [::core::mem::offset_of!(v4l2_pix_format, flags) - 32usize];
    ["Offset of field: v4l2_pix_format::quantization"]
        [::core::mem::offset_of!(v4l2_pix_format, quantization) - 40usize];
    ["Offset of field: v4l2_pix_format::xfer_func"]
        [::core::mem::offset_of!(v4l2_pix_format, xfer_func) - 44usize];
};
impl Default for v4l2_pix_format {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_fmtdesc {
    pub index: __u32,
    pub type_: __u32,
    pub flags: __u32,
    pub description: [__u8; 32usize],
    pub pixelformat: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_fmtdesc"][::core::mem::size_of::<v4l2_fmtdesc>() - 64usize];
    ["Alignment of v4l2_fmtdesc"][::core::mem::align_of::<v4l2_fmtdesc>() - 4usize];
    ["Offset of field: v4l2_fmtdesc::index"][::core::mem::offset_of!(v4l2_fmtdesc, index) - 0usize];
    ["Offset of field: v4l2_fmtdesc::type_"][::core::mem::offset_of!(v4l2_fmtdesc, type_) - 4usize];
    ["Offset of field: v4l2_fmtdesc::flags"][::core::mem::offset_of!(v4l2_fmtdesc, flags) - 8usize];
    ["Offset of field: v4l2_fmtdesc::description"]
        [::core::mem::offset_of!(v4l2_fmtdesc, description) - 12usize];
    ["Offset of field: v4l2_fmtdesc::pixelformat"]
        [::core::mem::offset_of!(v4l2_fmtdesc, pixelformat) - 44usize];
    ["Offset of field: v4l2_fmtdesc::reserved"]
        [::core::mem::offset_of!(v4l2_fmtdesc, reserved) - 48usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_frmsizetypes {
    V4L2_FRMSIZE_TYPE_DISCRETE = 1,
    V4L2_FRMSIZE_TYPE_CONTINUOUS = 2,
    V4L2_FRMSIZE_TYPE_STEPWISE = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frmsize_discrete {
    pub width: __u32,
    pub height: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsize_discrete"][::core::mem::size_of::<v4l2_frmsize_discrete>() - 8usize];
    ["Alignment of v4l2_frmsize_discrete"]
        [::core::mem::align_of::<v4l2_frmsize_discrete>() - 4usize];
    ["Offset of field: v4l2_frmsize_discrete::width"]
        [::core::mem::offset_of!(v4l2_frmsize_discrete, width) - 0usize];
    ["Offset of field: v4l2_frmsize_discrete::height"]
        [::core::mem::offset_of!(v4l2_frmsize_discrete, height) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frmsize_stepwise {
    pub min_width: __u32,
    pub max_width: __u32,
    pub step_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub step_height: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsize_stepwise"][::core::mem::size_of::<v4l2_frmsize_stepwise>() - 24usize];
    ["Alignment of v4l2_frmsize_stepwise"]
        [::core::mem::align_of::<v4l2_frmsize_stepwise>() - 4usize];
    ["Offset of field: v4l2_frmsize_stepwise::min_width"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, min_width) - 0usize];
    ["Offset of field: v4l2_frmsize_stepwise::max_width"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, max_width) - 4usize];
    ["Offset of field: v4l2_frmsize_stepwise::step_width"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, step_width) - 8usize];
    ["Offset of field: v4l2_frmsize_stepwise::min_height"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, min_height) - 12usize];
    ["Offset of field: v4l2_frmsize_stepwise::max_height"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, max_height) - 16usize];
    ["Offset of field: v4l2_frmsize_stepwise::step_height"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, step_height) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmsizeenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub type_: __u32,
    pub __anon1: v4l2_frmsizeenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmsizeenum__bindgen_ty_1 {
    pub discrete: v4l2_frmsize_discrete,
    pub stepwise: v4l2_frmsize_stepwise,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsizeenum__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_frmsizeenum__bindgen_ty_1>() - 24usize];
    ["Alignment of v4l2_frmsizeenum__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_frmsizeenum__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_frmsizeenum__bindgen_ty_1::discrete"]
        [::core::mem::offset_of!(v4l2_frmsizeenum__bindgen_ty_1, discrete) - 0usize];
    ["Offset of field: v4l2_frmsizeenum__bindgen_ty_1::stepwise"]
        [::core::mem::offset_of!(v4l2_frmsizeenum__bindgen_ty_1, stepwise) - 0usize];
};
impl Default for v4l2_frmsizeenum__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsizeenum"][::core::mem::size_of::<v4l2_frmsizeenum>() - 44usize];
    ["Alignment of v4l2_frmsizeenum"][::core::mem::align_of::<v4l2_frmsizeenum>() - 4usize];
    ["Offset of field: v4l2_frmsizeenum::index"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, index) - 0usize];
    ["Offset of field: v4l2_frmsizeenum::pixel_format"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, pixel_format) - 4usize];
    ["Offset of field: v4l2_frmsizeenum::type_"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, type_) - 8usize];
    ["Offset of field: v4l2_frmsizeenum::reserved"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, reserved) - 36usize];
};
impl Default for v4l2_frmsizeenum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_frmivaltypes {
    V4L2_FRMIVAL_TYPE_DISCRETE = 1,
    V4L2_FRMIVAL_TYPE_CONTINUOUS = 2,
    V4L2_FRMIVAL_TYPE_STEPWISE = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frmival_stepwise {
    pub min: v4l2_fract,
    pub max: v4l2_fract,
    pub step: v4l2_fract,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmival_stepwise"][::core::mem::size_of::<v4l2_frmival_stepwise>() - 24usize];
    ["Alignment of v4l2_frmival_stepwise"]
        [::core::mem::align_of::<v4l2_frmival_stepwise>() - 4usize];
    ["Offset of field: v4l2_frmival_stepwise::min"]
        [::core::mem::offset_of!(v4l2_frmival_stepwise, min) - 0usize];
    ["Offset of field: v4l2_frmival_stepwise::max"]
        [::core::mem::offset_of!(v4l2_frmival_stepwise, max) - 8usize];
    ["Offset of field: v4l2_frmival_stepwise::step"]
        [::core::mem::offset_of!(v4l2_frmival_stepwise, step) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmivalenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub width: __u32,
    pub height: __u32,
    pub type_: __u32,
    pub __anon1: v4l2_frmivalenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmivalenum__bindgen_ty_1 {
    pub discrete: v4l2_fract,
    pub stepwise: v4l2_frmival_stepwise,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmivalenum__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_frmivalenum__bindgen_ty_1>() - 24usize];
    ["Alignment of v4l2_frmivalenum__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_frmivalenum__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_frmivalenum__bindgen_ty_1::discrete"]
        [::core::mem::offset_of!(v4l2_frmivalenum__bindgen_ty_1, discrete) - 0usize];
    ["Offset of field: v4l2_frmivalenum__bindgen_ty_1::stepwise"]
        [::core::mem::offset_of!(v4l2_frmivalenum__bindgen_ty_1, stepwise) - 0usize];
};
impl Default for v4l2_frmivalenum__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmivalenum"][::core::mem::size_of::<v4l2_frmivalenum>() - 52usize];
    ["Alignment of v4l2_frmivalenum"][::core::mem::align_of::<v4l2_frmivalenum>() - 4usize];
    ["Offset of field: v4l2_frmivalenum::index"]
        [::core::mem::offset_of!(v4l2_frmivalenum, index) - 0usize];
    ["Offset of field: v4l2_frmivalenum::pixel_format"]
        [::core::mem::offset_of!(v4l2_frmivalenum, pixel_format) - 4usize];
    ["Offset of field: v4l2_frmivalenum::width"]
        [::core::mem::offset_of!(v4l2_frmivalenum, width) - 8usize];
    ["Offset of field: v4l2_frmivalenum::height"]
        [::core::mem::offset_of!(v4l2_frmivalenum, height) - 12usize];
    ["Offset of field: v4l2_frmivalenum::type_"]
        [::core::mem::offset_of!(v4l2_frmivalenum, type_) - 16usize];
    ["Offset of field: v4l2_frmivalenum::reserved"]
        [::core::mem::offset_of!(v4l2_frmivalenum, reserved) - 44usize];
};
impl Default for v4l2_frmivalenum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_timecode {
    pub type_: __u32,
    pub flags: __u32,
    pub frames: __u8,
    pub seconds: __u8,
    pub minutes: __u8,
    pub hours: __u8,
    pub userbits: [__u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_timecode"][::core::mem::size_of::<v4l2_timecode>() - 16usize];
    ["Alignment of v4l2_timecode"][::core::mem::align_of::<v4l2_timecode>() - 4usize];
    ["Offset of field: v4l2_timecode::type_"]
        [::core::mem::offset_of!(v4l2_timecode, type_) - 0usize];
    ["Offset of field: v4l2_timecode::flags"]
        [::core::mem::offset_of!(v4l2_timecode, flags) - 4usize];
    ["Offset of field: v4l2_timecode::frames"]
        [::core::mem::offset_of!(v4l2_timecode, frames) - 8usize];
    ["Offset of field: v4l2_timecode::seconds"]
        [::core::mem::offset_of!(v4l2_timecode, seconds) - 9usize];
    ["Offset of field: v4l2_timecode::minutes"]
        [::core::mem::offset_of!(v4l2_timecode, minutes) - 10usize];
    ["Offset of field: v4l2_timecode::hours"]
        [::core::mem::offset_of!(v4l2_timecode, hours) - 11usize];
    ["Offset of field: v4l2_timecode::userbits"]
        [::core::mem::offset_of!(v4l2_timecode, userbits) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_jpegcompression {
    pub quality: libc::c_int,
    pub APPn: libc::c_int,
    pub APP_len: libc::c_int,
    pub APP_data: [libc::c_char; 60usize],
    pub COM_len: libc::c_int,
    pub COM_data: [libc::c_char; 60usize],
    pub jpeg_markers: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_jpegcompression"][::core::mem::size_of::<v4l2_jpegcompression>() - 140usize];
    ["Alignment of v4l2_jpegcompression"][::core::mem::align_of::<v4l2_jpegcompression>() - 4usize];
    ["Offset of field: v4l2_jpegcompression::quality"]
        [::core::mem::offset_of!(v4l2_jpegcompression, quality) - 0usize];
    ["Offset of field: v4l2_jpegcompression::APPn"]
        [::core::mem::offset_of!(v4l2_jpegcompression, APPn) - 4usize];
    ["Offset of field: v4l2_jpegcompression::APP_len"]
        [::core::mem::offset_of!(v4l2_jpegcompression, APP_len) - 8usize];
    ["Offset of field: v4l2_jpegcompression::APP_data"]
        [::core::mem::offset_of!(v4l2_jpegcompression, APP_data) - 12usize];
    ["Offset of field: v4l2_jpegcompression::COM_len"]
        [::core::mem::offset_of!(v4l2_jpegcompression, COM_len) - 72usize];
    ["Offset of field: v4l2_jpegcompression::COM_data"]
        [::core::mem::offset_of!(v4l2_jpegcompression, COM_data) - 76usize];
    ["Offset of field: v4l2_jpegcompression::jpeg_markers"]
        [::core::mem::offset_of!(v4l2_jpegcompression, jpeg_markers) - 136usize];
};
impl Default for v4l2_jpegcompression {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_requestbuffers {
    pub count: __u32,
    pub type_: __u32,
    pub memory: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_requestbuffers"][::core::mem::size_of::<v4l2_requestbuffers>() - 20usize];
    ["Alignment of v4l2_requestbuffers"][::core::mem::align_of::<v4l2_requestbuffers>() - 4usize];
    ["Offset of field: v4l2_requestbuffers::count"]
        [::core::mem::offset_of!(v4l2_requestbuffers, count) - 0usize];
    ["Offset of field: v4l2_requestbuffers::type_"]
        [::core::mem::offset_of!(v4l2_requestbuffers, type_) - 4usize];
    ["Offset of field: v4l2_requestbuffers::memory"]
        [::core::mem::offset_of!(v4l2_requestbuffers, memory) - 8usize];
    ["Offset of field: v4l2_requestbuffers::capabilities"]
        [::core::mem::offset_of!(v4l2_requestbuffers, capabilities) - 12usize];
    ["Offset of field: v4l2_requestbuffers::reserved"]
        [::core::mem::offset_of!(v4l2_requestbuffers, reserved) - 16usize];
};
#[doc = " struct v4l2_plane - plane info for multi-planar buffers\n @bytesused:\t\tnumber of bytes occupied by data in the plane (payload)\n @length:\t\tsize of this plane (NOT the payload) in bytes\n @mem_offset:\t\twhen memory in the associated struct v4l2_buffer is\n\t\t\tV4L2_MEMORY_MMAP, equals the offset from the start of\n\t\t\tthe device memory for this plane (or is a \"cookie\" that\n\t\t\tshould be passed to mmap() called on the video node)\n @userptr:\t\twhen memory is V4L2_MEMORY_USERPTR, a userspace pointer\n\t\t\tpointing to this plane\n @fd:\t\t\twhen memory is V4L2_MEMORY_DMABUF, a userspace file\n\t\t\tdescriptor associated with this plane\n @data_offset:\toffset in the plane to the start of data; usually 0,\n\t\t\tunless there is a header in front of the data\n\n Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer\n with two planes can have one plane for Y, and another for interleaved CbCr\n components. Each plane can reside in a separate memory buffer, or even in\n a completely separate memory node (e.g. in embedded devices)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_plane {
    pub bytesused: __u32,
    pub length: __u32,
    pub m: v4l2_plane__bindgen_ty_1,
    pub data_offset: __u32,
    pub reserved: [__u32; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_plane__bindgen_ty_1 {
    pub mem_offset: __u32,
    pub userptr: libc::c_ulong,
    pub fd: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_plane__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_plane__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_plane__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_plane__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_plane__bindgen_ty_1::mem_offset"]
        [::core::mem::offset_of!(v4l2_plane__bindgen_ty_1, mem_offset) - 0usize];
    ["Offset of field: v4l2_plane__bindgen_ty_1::userptr"]
        [::core::mem::offset_of!(v4l2_plane__bindgen_ty_1, userptr) - 0usize];
    ["Offset of field: v4l2_plane__bindgen_ty_1::fd"]
        [::core::mem::offset_of!(v4l2_plane__bindgen_ty_1, fd) - 0usize];
};
impl Default for v4l2_plane__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_plane"][::core::mem::size_of::<v4l2_plane>() - 60usize];
    ["Alignment of v4l2_plane"][::core::mem::align_of::<v4l2_plane>() - 4usize];
    ["Offset of field: v4l2_plane::bytesused"]
        [::core::mem::offset_of!(v4l2_plane, bytesused) - 0usize];
    ["Offset of field: v4l2_plane::length"][::core::mem::offset_of!(v4l2_plane, length) - 4usize];
    ["Offset of field: v4l2_plane::m"][::core::mem::offset_of!(v4l2_plane, m) - 8usize];
    ["Offset of field: v4l2_plane::data_offset"]
        [::core::mem::offset_of!(v4l2_plane, data_offset) - 12usize];
    ["Offset of field: v4l2_plane::reserved"]
        [::core::mem::offset_of!(v4l2_plane, reserved) - 16usize];
};
impl Default for v4l2_plane {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_buffer - video buffer info\n @index:\tid number of the buffer\n @type:\tenum v4l2_buf_type; buffer type (type == *_MPLANE for\n\t\tmultiplanar buffers);\n @bytesused:\tnumber of bytes occupied by data in the buffer (payload);\n\t\tunused (set to 0) for multiplanar buffers\n @flags:\tbuffer informational flags\n @field:\tenum v4l2_field; field order of the image in the buffer\n @timestamp:\tframe timestamp\n @timecode:\tframe timecode\n @sequence:\tsequence count of this frame\n @memory:\tenum v4l2_memory; the method, in which the actual video data is\n\t\tpassed\n @offset:\tfor non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;\n\t\toffset from the start of the device memory for this plane,\n\t\t(or a \"cookie\" that should be passed to mmap() as offset)\n @userptr:\tfor non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;\n\t\ta userspace pointer pointing to this buffer\n @fd:\t\tfor non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;\n\t\ta userspace file descriptor associated with this buffer\n @planes:\tfor multiplanar buffers; userspace pointer to the array of plane\n\t\tinfo structs for this buffer\n @length:\tsize in bytes of the buffer (NOT its payload) for single-plane\n\t\tbuffers (when type != *_MPLANE); number of elements in the\n\t\tplanes array for multi-plane buffers\n @request_fd: fd of the request that this buffer should use\n\n Contains data exchanged by application and driver using one of the Streaming\n I/O methods."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_buffer {
    pub index: __u32,
    pub type_: __u32,
    pub bytesused: __u32,
    pub flags: __u32,
    pub field: __u32,
    pub timestamp: timeval,
    pub timecode: v4l2_timecode,
    pub sequence: __u32,
    pub memory: __u32,
    pub m: v4l2_buffer__bindgen_ty_1,
    pub length: __u32,
    pub reserved2: __u32,
    pub __anon1: v4l2_buffer__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_1 {
    pub offset: __u32,
    pub userptr: libc::c_ulong,
    pub planes: *mut v4l2_plane,
    pub fd: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_buffer__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_buffer__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_buffer__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_buffer__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::offset"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, offset) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::userptr"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, userptr) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::planes"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, planes) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::fd"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, fd) - 0usize];
};
impl Default for v4l2_buffer__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_2 {
    pub request_fd: __s32,
    pub reserved: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_buffer__bindgen_ty_2"]
        [::core::mem::size_of::<v4l2_buffer__bindgen_ty_2>() - 4usize];
    ["Alignment of v4l2_buffer__bindgen_ty_2"]
        [::core::mem::align_of::<v4l2_buffer__bindgen_ty_2>() - 4usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_2::request_fd"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_2, request_fd) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_2::reserved"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_2, reserved) - 0usize];
};
impl Default for v4l2_buffer__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_buffer"][::core::mem::size_of::<v4l2_buffer>() - 68usize];
    ["Alignment of v4l2_buffer"][::core::mem::align_of::<v4l2_buffer>() - 4usize];
    ["Offset of field: v4l2_buffer::index"][::core::mem::offset_of!(v4l2_buffer, index) - 0usize];
    ["Offset of field: v4l2_buffer::type_"][::core::mem::offset_of!(v4l2_buffer, type_) - 4usize];
    ["Offset of field: v4l2_buffer::bytesused"]
        [::core::mem::offset_of!(v4l2_buffer, bytesused) - 8usize];
    ["Offset of field: v4l2_buffer::flags"][::core::mem::offset_of!(v4l2_buffer, flags) - 12usize];
    ["Offset of field: v4l2_buffer::field"][::core::mem::offset_of!(v4l2_buffer, field) - 16usize];
    ["Offset of field: v4l2_buffer::timestamp"]
        [::core::mem::offset_of!(v4l2_buffer, timestamp) - 20usize];
    ["Offset of field: v4l2_buffer::timecode"]
        [::core::mem::offset_of!(v4l2_buffer, timecode) - 28usize];
    ["Offset of field: v4l2_buffer::sequence"]
        [::core::mem::offset_of!(v4l2_buffer, sequence) - 44usize];
    ["Offset of field: v4l2_buffer::memory"]
        [::core::mem::offset_of!(v4l2_buffer, memory) - 48usize];
    ["Offset of field: v4l2_buffer::m"][::core::mem::offset_of!(v4l2_buffer, m) - 52usize];
    ["Offset of field: v4l2_buffer::length"]
        [::core::mem::offset_of!(v4l2_buffer, length) - 56usize];
    ["Offset of field: v4l2_buffer::reserved2"]
        [::core::mem::offset_of!(v4l2_buffer, reserved2) - 60usize];
};
impl Default for v4l2_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor\n\n @index:\tid number of the buffer\n @type:\tenum v4l2_buf_type; buffer type (type == *_MPLANE for\n\t\tmultiplanar buffers);\n @plane:\tindex of the plane to be exported, 0 for single plane queues\n @flags:\tflags for newly created file, currently only O_CLOEXEC is\n\t\tsupported, refer to manual of open syscall for more details\n @fd:\t\tfile descriptor associated with DMABUF (set by driver)\n\n Contains data used for exporting a video buffer as DMABUF file descriptor.\n The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF\n (identical to the cookie used to mmap() the buffer to userspace). All\n reserved fields must be set to zero. The field reserved0 is expected to\n become a structure 'type' allowing an alternative layout of the structure\n content. Therefore this field should not be used for any other extensions."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_exportbuffer {
    pub type_: __u32,
    pub index: __u32,
    pub plane: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub reserved: [__u32; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_exportbuffer"][::core::mem::size_of::<v4l2_exportbuffer>() - 64usize];
    ["Alignment of v4l2_exportbuffer"][::core::mem::align_of::<v4l2_exportbuffer>() - 4usize];
    ["Offset of field: v4l2_exportbuffer::type_"]
        [::core::mem::offset_of!(v4l2_exportbuffer, type_) - 0usize];
    ["Offset of field: v4l2_exportbuffer::index"]
        [::core::mem::offset_of!(v4l2_exportbuffer, index) - 4usize];
    ["Offset of field: v4l2_exportbuffer::plane"]
        [::core::mem::offset_of!(v4l2_exportbuffer, plane) - 8usize];
    ["Offset of field: v4l2_exportbuffer::flags"]
        [::core::mem::offset_of!(v4l2_exportbuffer, flags) - 12usize];
    ["Offset of field: v4l2_exportbuffer::fd"]
        [::core::mem::offset_of!(v4l2_exportbuffer, fd) - 16usize];
    ["Offset of field: v4l2_exportbuffer::reserved"]
        [::core::mem::offset_of!(v4l2_exportbuffer, reserved) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_framebuffer {
    pub capability: __u32,
    pub flags: __u32,
    pub base: *mut libc::c_void,
    pub fmt: v4l2_framebuffer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_framebuffer__bindgen_ty_1 {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_framebuffer__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_framebuffer__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_framebuffer__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_framebuffer__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::width"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, width) - 0usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::height"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, height) - 4usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::pixelformat"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, pixelformat) - 8usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::field"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, field) - 12usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::bytesperline"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, bytesperline) - 16usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::sizeimage"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, sizeimage) - 20usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::colorspace"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, colorspace) - 24usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::priv_"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, priv_) - 28usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_framebuffer"][::core::mem::size_of::<v4l2_framebuffer>() - 44usize];
    ["Alignment of v4l2_framebuffer"][::core::mem::align_of::<v4l2_framebuffer>() - 4usize];
    ["Offset of field: v4l2_framebuffer::capability"]
        [::core::mem::offset_of!(v4l2_framebuffer, capability) - 0usize];
    ["Offset of field: v4l2_framebuffer::flags"]
        [::core::mem::offset_of!(v4l2_framebuffer, flags) - 4usize];
    ["Offset of field: v4l2_framebuffer::base"]
        [::core::mem::offset_of!(v4l2_framebuffer, base) - 8usize];
    ["Offset of field: v4l2_framebuffer::fmt"]
        [::core::mem::offset_of!(v4l2_framebuffer, fmt) - 12usize];
};
impl Default for v4l2_framebuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_clip {
    pub c: v4l2_rect,
    pub next: *mut v4l2_clip,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_clip"][::core::mem::size_of::<v4l2_clip>() - 20usize];
    ["Alignment of v4l2_clip"][::core::mem::align_of::<v4l2_clip>() - 4usize];
    ["Offset of field: v4l2_clip::c"][::core::mem::offset_of!(v4l2_clip, c) - 0usize];
    ["Offset of field: v4l2_clip::next"][::core::mem::offset_of!(v4l2_clip, next) - 16usize];
};
impl Default for v4l2_clip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_window {
    pub w: v4l2_rect,
    pub field: __u32,
    pub chromakey: __u32,
    pub clips: *mut v4l2_clip,
    pub clipcount: __u32,
    pub bitmap: *mut libc::c_void,
    pub global_alpha: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_window"][::core::mem::size_of::<v4l2_window>() - 40usize];
    ["Alignment of v4l2_window"][::core::mem::align_of::<v4l2_window>() - 4usize];
    ["Offset of field: v4l2_window::w"][::core::mem::offset_of!(v4l2_window, w) - 0usize];
    ["Offset of field: v4l2_window::field"][::core::mem::offset_of!(v4l2_window, field) - 16usize];
    ["Offset of field: v4l2_window::chromakey"]
        [::core::mem::offset_of!(v4l2_window, chromakey) - 20usize];
    ["Offset of field: v4l2_window::clips"][::core::mem::offset_of!(v4l2_window, clips) - 24usize];
    ["Offset of field: v4l2_window::clipcount"]
        [::core::mem::offset_of!(v4l2_window, clipcount) - 28usize];
    ["Offset of field: v4l2_window::bitmap"]
        [::core::mem::offset_of!(v4l2_window, bitmap) - 32usize];
    ["Offset of field: v4l2_window::global_alpha"]
        [::core::mem::offset_of!(v4l2_window, global_alpha) - 36usize];
};
impl Default for v4l2_window {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_captureparm {
    pub capability: __u32,
    pub capturemode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub readbuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_captureparm"][::core::mem::size_of::<v4l2_captureparm>() - 40usize];
    ["Alignment of v4l2_captureparm"][::core::mem::align_of::<v4l2_captureparm>() - 4usize];
    ["Offset of field: v4l2_captureparm::capability"]
        [::core::mem::offset_of!(v4l2_captureparm, capability) - 0usize];
    ["Offset of field: v4l2_captureparm::capturemode"]
        [::core::mem::offset_of!(v4l2_captureparm, capturemode) - 4usize];
    ["Offset of field: v4l2_captureparm::timeperframe"]
        [::core::mem::offset_of!(v4l2_captureparm, timeperframe) - 8usize];
    ["Offset of field: v4l2_captureparm::extendedmode"]
        [::core::mem::offset_of!(v4l2_captureparm, extendedmode) - 16usize];
    ["Offset of field: v4l2_captureparm::readbuffers"]
        [::core::mem::offset_of!(v4l2_captureparm, readbuffers) - 20usize];
    ["Offset of field: v4l2_captureparm::reserved"]
        [::core::mem::offset_of!(v4l2_captureparm, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_outputparm {
    pub capability: __u32,
    pub outputmode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub writebuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_outputparm"][::core::mem::size_of::<v4l2_outputparm>() - 40usize];
    ["Alignment of v4l2_outputparm"][::core::mem::align_of::<v4l2_outputparm>() - 4usize];
    ["Offset of field: v4l2_outputparm::capability"]
        [::core::mem::offset_of!(v4l2_outputparm, capability) - 0usize];
    ["Offset of field: v4l2_outputparm::outputmode"]
        [::core::mem::offset_of!(v4l2_outputparm, outputmode) - 4usize];
    ["Offset of field: v4l2_outputparm::timeperframe"]
        [::core::mem::offset_of!(v4l2_outputparm, timeperframe) - 8usize];
    ["Offset of field: v4l2_outputparm::extendedmode"]
        [::core::mem::offset_of!(v4l2_outputparm, extendedmode) - 16usize];
    ["Offset of field: v4l2_outputparm::writebuffers"]
        [::core::mem::offset_of!(v4l2_outputparm, writebuffers) - 20usize];
    ["Offset of field: v4l2_outputparm::reserved"]
        [::core::mem::offset_of!(v4l2_outputparm, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_cropcap {
    pub type_: __u32,
    pub bounds: v4l2_rect,
    pub defrect: v4l2_rect,
    pub pixelaspect: v4l2_fract,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_cropcap"][::core::mem::size_of::<v4l2_cropcap>() - 44usize];
    ["Alignment of v4l2_cropcap"][::core::mem::align_of::<v4l2_cropcap>() - 4usize];
    ["Offset of field: v4l2_cropcap::type_"][::core::mem::offset_of!(v4l2_cropcap, type_) - 0usize];
    ["Offset of field: v4l2_cropcap::bounds"]
        [::core::mem::offset_of!(v4l2_cropcap, bounds) - 4usize];
    ["Offset of field: v4l2_cropcap::defrect"]
        [::core::mem::offset_of!(v4l2_cropcap, defrect) - 20usize];
    ["Offset of field: v4l2_cropcap::pixelaspect"]
        [::core::mem::offset_of!(v4l2_cropcap, pixelaspect) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_crop {
    pub type_: __u32,
    pub c: v4l2_rect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_crop"][::core::mem::size_of::<v4l2_crop>() - 20usize];
    ["Alignment of v4l2_crop"][::core::mem::align_of::<v4l2_crop>() - 4usize];
    ["Offset of field: v4l2_crop::type_"][::core::mem::offset_of!(v4l2_crop, type_) - 0usize];
    ["Offset of field: v4l2_crop::c"][::core::mem::offset_of!(v4l2_crop, c) - 4usize];
};
#[doc = " struct v4l2_selection - selection info\n @type:\tbuffer type (do not use *_MPLANE types)\n @target:\tSelection target, used to choose one of possible rectangles;\n\t\tdefined in v4l2-common.h; V4L2_SEL_TGT_* .\n @flags:\tconstraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.\n @r:\t\tcoordinates of selection window\n @reserved:\tfor future use, rounds structure size to 64 bytes, set to zero\n\n Hardware may use multiple helper windows to process a video stream.\n The structure is used to exchange this selection areas between\n an application and a driver."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_selection {
    pub type_: __u32,
    pub target: __u32,
    pub flags: __u32,
    pub r: v4l2_rect,
    pub reserved: [__u32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_selection"][::core::mem::size_of::<v4l2_selection>() - 64usize];
    ["Alignment of v4l2_selection"][::core::mem::align_of::<v4l2_selection>() - 4usize];
    ["Offset of field: v4l2_selection::type_"]
        [::core::mem::offset_of!(v4l2_selection, type_) - 0usize];
    ["Offset of field: v4l2_selection::target"]
        [::core::mem::offset_of!(v4l2_selection, target) - 4usize];
    ["Offset of field: v4l2_selection::flags"]
        [::core::mem::offset_of!(v4l2_selection, flags) - 8usize];
    ["Offset of field: v4l2_selection::r"][::core::mem::offset_of!(v4l2_selection, r) - 12usize];
    ["Offset of field: v4l2_selection::reserved"]
        [::core::mem::offset_of!(v4l2_selection, reserved) - 28usize];
};
pub type v4l2_std_id = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_standard {
    pub index: __u32,
    pub id: v4l2_std_id,
    pub name: [__u8; 24usize],
    pub frameperiod: v4l2_fract,
    pub framelines: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_standard"][::core::mem::size_of::<v4l2_standard>() - 72usize];
    ["Alignment of v4l2_standard"][::core::mem::align_of::<v4l2_standard>() - 8usize];
    ["Offset of field: v4l2_standard::index"]
        [::core::mem::offset_of!(v4l2_standard, index) - 0usize];
    ["Offset of field: v4l2_standard::id"][::core::mem::offset_of!(v4l2_standard, id) - 8usize];
    ["Offset of field: v4l2_standard::name"]
        [::core::mem::offset_of!(v4l2_standard, name) - 16usize];
    ["Offset of field: v4l2_standard::frameperiod"]
        [::core::mem::offset_of!(v4l2_standard, frameperiod) - 40usize];
    ["Offset of field: v4l2_standard::framelines"]
        [::core::mem::offset_of!(v4l2_standard, framelines) - 48usize];
    ["Offset of field: v4l2_standard::reserved"]
        [::core::mem::offset_of!(v4l2_standard, reserved) - 52usize];
};
#[doc = " struct v4l2_bt_timings - BT.656/BT.1120 timing data\n @width:\ttotal width of the active video in pixels\n @height:\ttotal height of the active video in lines\n @interlaced:\tInterlaced or progressive\n @polarities:\tPositive or negative polarities\n @pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000\n @hfrontporch:Horizontal front porch in pixels\n @hsync:\tHorizontal Sync length in pixels\n @hbackporch:\tHorizontal back porch in pixels\n @vfrontporch:Vertical front porch in lines\n @vsync:\tVertical Sync length in lines\n @vbackporch:\tVertical back porch in lines\n @il_vfrontporch:Vertical front porch for the even field\n\t\t(aka field 2) of interlaced field formats\n @il_vsync:\tVertical Sync length for the even field\n\t\t(aka field 2) of interlaced field formats\n @il_vbackporch:Vertical back porch for the even field\n\t\t(aka field 2) of interlaced field formats\n @standards:\tStandards the timing belongs to\n @flags:\tFlags\n @picture_aspect: The picture aspect ratio (hor/vert).\n @cea861_vic:\tVIC code as per the CEA-861 standard.\n @hdmi_vic:\tVIC code as per the HDMI standard.\n @reserved:\tReserved fields, must be zeroed.\n\n A note regarding vertical interlaced timings: height refers to the total\n height of the active video frame (= two fields). The blanking timings refer\n to the blanking of each field. So the height of the total frame is\n calculated as follows:\n\n tot_height = height + vfrontporch + vsync + vbackporch +\n                       il_vfrontporch + il_vsync + il_vbackporch\n\n The active height of each field is height / 2."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_bt_timings {
    pub width: __u32,
    pub height: __u32,
    pub interlaced: __u32,
    pub polarities: __u32,
    pub pixelclock: __u64,
    pub hfrontporch: __u32,
    pub hsync: __u32,
    pub hbackporch: __u32,
    pub vfrontporch: __u32,
    pub vsync: __u32,
    pub vbackporch: __u32,
    pub il_vfrontporch: __u32,
    pub il_vsync: __u32,
    pub il_vbackporch: __u32,
    pub standards: __u32,
    pub flags: __u32,
    pub picture_aspect: v4l2_fract,
    pub cea861_vic: __u8,
    pub hdmi_vic: __u8,
    pub reserved: [__u8; 46usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_bt_timings"][::core::mem::size_of::<v4l2_bt_timings>() - 124usize];
    ["Alignment of v4l2_bt_timings"][::core::mem::align_of::<v4l2_bt_timings>() - 1usize];
    ["Offset of field: v4l2_bt_timings::width"]
        [::core::mem::offset_of!(v4l2_bt_timings, width) - 0usize];
    ["Offset of field: v4l2_bt_timings::height"]
        [::core::mem::offset_of!(v4l2_bt_timings, height) - 4usize];
    ["Offset of field: v4l2_bt_timings::interlaced"]
        [::core::mem::offset_of!(v4l2_bt_timings, interlaced) - 8usize];
    ["Offset of field: v4l2_bt_timings::polarities"]
        [::core::mem::offset_of!(v4l2_bt_timings, polarities) - 12usize];
    ["Offset of field: v4l2_bt_timings::pixelclock"]
        [::core::mem::offset_of!(v4l2_bt_timings, pixelclock) - 16usize];
    ["Offset of field: v4l2_bt_timings::hfrontporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, hfrontporch) - 24usize];
    ["Offset of field: v4l2_bt_timings::hsync"]
        [::core::mem::offset_of!(v4l2_bt_timings, hsync) - 28usize];
    ["Offset of field: v4l2_bt_timings::hbackporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, hbackporch) - 32usize];
    ["Offset of field: v4l2_bt_timings::vfrontporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, vfrontporch) - 36usize];
    ["Offset of field: v4l2_bt_timings::vsync"]
        [::core::mem::offset_of!(v4l2_bt_timings, vsync) - 40usize];
    ["Offset of field: v4l2_bt_timings::vbackporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, vbackporch) - 44usize];
    ["Offset of field: v4l2_bt_timings::il_vfrontporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, il_vfrontporch) - 48usize];
    ["Offset of field: v4l2_bt_timings::il_vsync"]
        [::core::mem::offset_of!(v4l2_bt_timings, il_vsync) - 52usize];
    ["Offset of field: v4l2_bt_timings::il_vbackporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, il_vbackporch) - 56usize];
    ["Offset of field: v4l2_bt_timings::standards"]
        [::core::mem::offset_of!(v4l2_bt_timings, standards) - 60usize];
    ["Offset of field: v4l2_bt_timings::flags"]
        [::core::mem::offset_of!(v4l2_bt_timings, flags) - 64usize];
    ["Offset of field: v4l2_bt_timings::picture_aspect"]
        [::core::mem::offset_of!(v4l2_bt_timings, picture_aspect) - 68usize];
    ["Offset of field: v4l2_bt_timings::cea861_vic"]
        [::core::mem::offset_of!(v4l2_bt_timings, cea861_vic) - 76usize];
    ["Offset of field: v4l2_bt_timings::hdmi_vic"]
        [::core::mem::offset_of!(v4l2_bt_timings, hdmi_vic) - 77usize];
    ["Offset of field: v4l2_bt_timings::reserved"]
        [::core::mem::offset_of!(v4l2_bt_timings, reserved) - 78usize];
};
impl Default for v4l2_bt_timings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_dv_timings - DV timings\n @type:\tthe type of the timings\n @bt:\tBT656/1120 timings"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings {
    pub type_: __u32,
    pub __anon1: v4l2_dv_timings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings__bindgen_ty_1 {
    pub bt: v4l2_bt_timings,
    pub reserved: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_dv_timings__bindgen_ty_1>() - 128usize];
    ["Alignment of v4l2_dv_timings__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_dv_timings__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_dv_timings__bindgen_ty_1::bt"]
        [::core::mem::offset_of!(v4l2_dv_timings__bindgen_ty_1, bt) - 0usize];
    ["Offset of field: v4l2_dv_timings__bindgen_ty_1::reserved"]
        [::core::mem::offset_of!(v4l2_dv_timings__bindgen_ty_1, reserved) - 0usize];
};
impl Default for v4l2_dv_timings__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings"][::core::mem::size_of::<v4l2_dv_timings>() - 132usize];
    ["Alignment of v4l2_dv_timings"][::core::mem::align_of::<v4l2_dv_timings>() - 1usize];
    ["Offset of field: v4l2_dv_timings::type_"]
        [::core::mem::offset_of!(v4l2_dv_timings, type_) - 0usize];
};
impl Default for v4l2_dv_timings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_enum_dv_timings - DV timings enumeration\n @index:\tenumeration index\n @pad:\tthe pad number for which to enumerate timings (used with\n\t\tv4l-subdev nodes only)\n @reserved:\tmust be zeroed\n @timings:\tthe timings for the given index"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_enum_dv_timings {
    pub index: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub timings: v4l2_dv_timings,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_enum_dv_timings"][::core::mem::size_of::<v4l2_enum_dv_timings>() - 148usize];
    ["Alignment of v4l2_enum_dv_timings"][::core::mem::align_of::<v4l2_enum_dv_timings>() - 4usize];
    ["Offset of field: v4l2_enum_dv_timings::index"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, index) - 0usize];
    ["Offset of field: v4l2_enum_dv_timings::pad"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, pad) - 4usize];
    ["Offset of field: v4l2_enum_dv_timings::reserved"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, reserved) - 8usize];
    ["Offset of field: v4l2_enum_dv_timings::timings"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, timings) - 16usize];
};
impl Default for v4l2_enum_dv_timings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities\n @min_width:\t\twidth in pixels\n @max_width:\t\twidth in pixels\n @min_height:\t\theight in lines\n @max_height:\t\theight in lines\n @min_pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000\n @max_pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000\n @standards:\t\tSupported standards\n @capabilities:\tSupported capabilities\n @reserved:\t\tMust be zeroed"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_bt_timings_cap {
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub min_pixelclock: __u64,
    pub max_pixelclock: __u64,
    pub standards: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_bt_timings_cap"][::core::mem::size_of::<v4l2_bt_timings_cap>() - 104usize];
    ["Alignment of v4l2_bt_timings_cap"][::core::mem::align_of::<v4l2_bt_timings_cap>() - 1usize];
    ["Offset of field: v4l2_bt_timings_cap::min_width"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, min_width) - 0usize];
    ["Offset of field: v4l2_bt_timings_cap::max_width"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, max_width) - 4usize];
    ["Offset of field: v4l2_bt_timings_cap::min_height"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, min_height) - 8usize];
    ["Offset of field: v4l2_bt_timings_cap::max_height"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, max_height) - 12usize];
    ["Offset of field: v4l2_bt_timings_cap::min_pixelclock"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, min_pixelclock) - 16usize];
    ["Offset of field: v4l2_bt_timings_cap::max_pixelclock"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, max_pixelclock) - 24usize];
    ["Offset of field: v4l2_bt_timings_cap::standards"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, standards) - 32usize];
    ["Offset of field: v4l2_bt_timings_cap::capabilities"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, capabilities) - 36usize];
    ["Offset of field: v4l2_bt_timings_cap::reserved"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, reserved) - 40usize];
};
#[doc = " struct v4l2_dv_timings_cap - DV timings capabilities\n @type:\tthe type of the timings (same as in struct v4l2_dv_timings)\n @pad:\tthe pad number for which to query capabilities (used with\n\t\tv4l-subdev nodes only)\n @bt:\t\tthe BT656/1120 timings capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings_cap {
    pub type_: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub __anon1: v4l2_dv_timings_cap__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings_cap__bindgen_ty_1 {
    pub bt: v4l2_bt_timings_cap,
    pub raw_data: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings_cap__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_dv_timings_cap__bindgen_ty_1>() - 128usize];
    ["Alignment of v4l2_dv_timings_cap__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_dv_timings_cap__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_dv_timings_cap__bindgen_ty_1::bt"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap__bindgen_ty_1, bt) - 0usize];
    ["Offset of field: v4l2_dv_timings_cap__bindgen_ty_1::raw_data"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap__bindgen_ty_1, raw_data) - 0usize];
};
impl Default for v4l2_dv_timings_cap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings_cap"][::core::mem::size_of::<v4l2_dv_timings_cap>() - 144usize];
    ["Alignment of v4l2_dv_timings_cap"][::core::mem::align_of::<v4l2_dv_timings_cap>() - 4usize];
    ["Offset of field: v4l2_dv_timings_cap::type_"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap, type_) - 0usize];
    ["Offset of field: v4l2_dv_timings_cap::pad"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap, pad) - 4usize];
    ["Offset of field: v4l2_dv_timings_cap::reserved"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap, reserved) - 8usize];
};
impl Default for v4l2_dv_timings_cap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_input {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub tuner: __u32,
    pub std: v4l2_std_id,
    pub status: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_input"][::core::mem::size_of::<v4l2_input>() - 80usize];
    ["Alignment of v4l2_input"][::core::mem::align_of::<v4l2_input>() - 8usize];
    ["Offset of field: v4l2_input::index"][::core::mem::offset_of!(v4l2_input, index) - 0usize];
    ["Offset of field: v4l2_input::name"][::core::mem::offset_of!(v4l2_input, name) - 4usize];
    ["Offset of field: v4l2_input::type_"][::core::mem::offset_of!(v4l2_input, type_) - 36usize];
    ["Offset of field: v4l2_input::audioset"]
        [::core::mem::offset_of!(v4l2_input, audioset) - 40usize];
    ["Offset of field: v4l2_input::tuner"][::core::mem::offset_of!(v4l2_input, tuner) - 44usize];
    ["Offset of field: v4l2_input::std"][::core::mem::offset_of!(v4l2_input, std) - 48usize];
    ["Offset of field: v4l2_input::status"][::core::mem::offset_of!(v4l2_input, status) - 56usize];
    ["Offset of field: v4l2_input::capabilities"]
        [::core::mem::offset_of!(v4l2_input, capabilities) - 60usize];
    ["Offset of field: v4l2_input::reserved"]
        [::core::mem::offset_of!(v4l2_input, reserved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_output {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub modulator: __u32,
    pub std: v4l2_std_id,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_output"][::core::mem::size_of::<v4l2_output>() - 72usize];
    ["Alignment of v4l2_output"][::core::mem::align_of::<v4l2_output>() - 8usize];
    ["Offset of field: v4l2_output::index"][::core::mem::offset_of!(v4l2_output, index) - 0usize];
    ["Offset of field: v4l2_output::name"][::core::mem::offset_of!(v4l2_output, name) - 4usize];
    ["Offset of field: v4l2_output::type_"][::core::mem::offset_of!(v4l2_output, type_) - 36usize];
    ["Offset of field: v4l2_output::audioset"]
        [::core::mem::offset_of!(v4l2_output, audioset) - 40usize];
    ["Offset of field: v4l2_output::modulator"]
        [::core::mem::offset_of!(v4l2_output, modulator) - 44usize];
    ["Offset of field: v4l2_output::std"][::core::mem::offset_of!(v4l2_output, std) - 48usize];
    ["Offset of field: v4l2_output::capabilities"]
        [::core::mem::offset_of!(v4l2_output, capabilities) - 56usize];
    ["Offset of field: v4l2_output::reserved"]
        [::core::mem::offset_of!(v4l2_output, reserved) - 60usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_control {
    pub id: __u32,
    pub value: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_control"][::core::mem::size_of::<v4l2_control>() - 8usize];
    ["Alignment of v4l2_control"][::core::mem::align_of::<v4l2_control>() - 4usize];
    ["Offset of field: v4l2_control::id"][::core::mem::offset_of!(v4l2_control, id) - 0usize];
    ["Offset of field: v4l2_control::value"][::core::mem::offset_of!(v4l2_control, value) - 4usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_control {
    pub id: __u32,
    pub size: __u32,
    pub reserved2: [__u32; 1usize],
    pub __anon1: v4l2_ext_control__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_control__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
    pub string: *mut libc::c_char,
    pub p_u8: *mut __u8,
    pub p_u16: *mut __u16,
    pub p_u32: *mut __u32,
    pub ptr: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_control__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_ext_control__bindgen_ty_1>() - 8usize];
    ["Alignment of v4l2_ext_control__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_ext_control__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::value"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, value) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::value64"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, value64) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::string"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, string) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::p_u8"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, p_u8) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::p_u16"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, p_u16) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::p_u32"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, p_u32) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::ptr"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, ptr) - 0usize];
};
impl Default for v4l2_ext_control__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_control"][::core::mem::size_of::<v4l2_ext_control>() - 20usize];
    ["Alignment of v4l2_ext_control"][::core::mem::align_of::<v4l2_ext_control>() - 1usize];
    ["Offset of field: v4l2_ext_control::id"]
        [::core::mem::offset_of!(v4l2_ext_control, id) - 0usize];
    ["Offset of field: v4l2_ext_control::size"]
        [::core::mem::offset_of!(v4l2_ext_control, size) - 4usize];
    ["Offset of field: v4l2_ext_control::reserved2"]
        [::core::mem::offset_of!(v4l2_ext_control, reserved2) - 8usize];
};
impl Default for v4l2_ext_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_controls {
    pub __anon1: v4l2_ext_controls__bindgen_ty_1,
    pub count: __u32,
    pub error_idx: __u32,
    pub request_fd: __s32,
    pub reserved: [__u32; 1usize],
    pub controls: *mut v4l2_ext_control,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_controls__bindgen_ty_1 {
    pub ctrl_class: __u32,
    pub which: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_controls__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_ext_controls__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_ext_controls__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_ext_controls__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_ext_controls__bindgen_ty_1::ctrl_class"]
        [::core::mem::offset_of!(v4l2_ext_controls__bindgen_ty_1, ctrl_class) - 0usize];
    ["Offset of field: v4l2_ext_controls__bindgen_ty_1::which"]
        [::core::mem::offset_of!(v4l2_ext_controls__bindgen_ty_1, which) - 0usize];
};
impl Default for v4l2_ext_controls__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_controls"][::core::mem::size_of::<v4l2_ext_controls>() - 24usize];
    ["Alignment of v4l2_ext_controls"][::core::mem::align_of::<v4l2_ext_controls>() - 4usize];
    ["Offset of field: v4l2_ext_controls::count"]
        [::core::mem::offset_of!(v4l2_ext_controls, count) - 4usize];
    ["Offset of field: v4l2_ext_controls::error_idx"]
        [::core::mem::offset_of!(v4l2_ext_controls, error_idx) - 8usize];
    ["Offset of field: v4l2_ext_controls::request_fd"]
        [::core::mem::offset_of!(v4l2_ext_controls, request_fd) - 12usize];
    ["Offset of field: v4l2_ext_controls::reserved"]
        [::core::mem::offset_of!(v4l2_ext_controls, reserved) - 16usize];
    ["Offset of field: v4l2_ext_controls::controls"]
        [::core::mem::offset_of!(v4l2_ext_controls, controls) - 20usize];
};
impl Default for v4l2_ext_controls {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl v4l2_ctrl_type {
    pub const V4L2_CTRL_TYPE_U8: v4l2_ctrl_type = v4l2_ctrl_type::V4L2_CTRL_COMPOUND_TYPES;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_queryctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [__u8; 32usize],
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_queryctrl"][::core::mem::size_of::<v4l2_queryctrl>() - 68usize];
    ["Alignment of v4l2_queryctrl"][::core::mem::align_of::<v4l2_queryctrl>() - 4usize];
    ["Offset of field: v4l2_queryctrl::id"][::core::mem::offset_of!(v4l2_queryctrl, id) - 0usize];
    ["Offset of field: v4l2_queryctrl::type_"]
        [::core::mem::offset_of!(v4l2_queryctrl, type_) - 4usize];
    ["Offset of field: v4l2_queryctrl::name"]
        [::core::mem::offset_of!(v4l2_queryctrl, name) - 8usize];
    ["Offset of field: v4l2_queryctrl::minimum"]
        [::core::mem::offset_of!(v4l2_queryctrl, minimum) - 40usize];
    ["Offset of field: v4l2_queryctrl::maximum"]
        [::core::mem::offset_of!(v4l2_queryctrl, maximum) - 44usize];
    ["Offset of field: v4l2_queryctrl::step"]
        [::core::mem::offset_of!(v4l2_queryctrl, step) - 48usize];
    ["Offset of field: v4l2_queryctrl::default_value"]
        [::core::mem::offset_of!(v4l2_queryctrl, default_value) - 52usize];
    ["Offset of field: v4l2_queryctrl::flags"]
        [::core::mem::offset_of!(v4l2_queryctrl, flags) - 56usize];
    ["Offset of field: v4l2_queryctrl::reserved"]
        [::core::mem::offset_of!(v4l2_queryctrl, reserved) - 60usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_query_ext_ctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [libc::c_char; 32usize],
    pub minimum: __s64,
    pub maximum: __s64,
    pub step: __u64,
    pub default_value: __s64,
    pub flags: __u32,
    pub elem_size: __u32,
    pub elems: __u32,
    pub nr_of_dims: __u32,
    pub dims: [__u32; 4usize],
    pub reserved: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_query_ext_ctrl"][::core::mem::size_of::<v4l2_query_ext_ctrl>() - 232usize];
    ["Alignment of v4l2_query_ext_ctrl"][::core::mem::align_of::<v4l2_query_ext_ctrl>() - 8usize];
    ["Offset of field: v4l2_query_ext_ctrl::id"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, id) - 0usize];
    ["Offset of field: v4l2_query_ext_ctrl::type_"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, type_) - 4usize];
    ["Offset of field: v4l2_query_ext_ctrl::name"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, name) - 8usize];
    ["Offset of field: v4l2_query_ext_ctrl::minimum"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, minimum) - 40usize];
    ["Offset of field: v4l2_query_ext_ctrl::maximum"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, maximum) - 48usize];
    ["Offset of field: v4l2_query_ext_ctrl::step"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, step) - 56usize];
    ["Offset of field: v4l2_query_ext_ctrl::default_value"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, default_value) - 64usize];
    ["Offset of field: v4l2_query_ext_ctrl::flags"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, flags) - 72usize];
    ["Offset of field: v4l2_query_ext_ctrl::elem_size"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, elem_size) - 76usize];
    ["Offset of field: v4l2_query_ext_ctrl::elems"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, elems) - 80usize];
    ["Offset of field: v4l2_query_ext_ctrl::nr_of_dims"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, nr_of_dims) - 84usize];
    ["Offset of field: v4l2_query_ext_ctrl::dims"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, dims) - 88usize];
    ["Offset of field: v4l2_query_ext_ctrl::reserved"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, reserved) - 104usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_querymenu {
    pub id: __u32,
    pub index: __u32,
    pub __anon1: v4l2_querymenu__bindgen_ty_1,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_querymenu__bindgen_ty_1 {
    pub name: [__u8; 32usize],
    pub value: __s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_querymenu__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_querymenu__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_querymenu__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_querymenu__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_querymenu__bindgen_ty_1::name"]
        [::core::mem::offset_of!(v4l2_querymenu__bindgen_ty_1, name) - 0usize];
    ["Offset of field: v4l2_querymenu__bindgen_ty_1::value"]
        [::core::mem::offset_of!(v4l2_querymenu__bindgen_ty_1, value) - 0usize];
};
impl Default for v4l2_querymenu__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_querymenu"][::core::mem::size_of::<v4l2_querymenu>() - 44usize];
    ["Alignment of v4l2_querymenu"][::core::mem::align_of::<v4l2_querymenu>() - 1usize];
    ["Offset of field: v4l2_querymenu::id"][::core::mem::offset_of!(v4l2_querymenu, id) - 0usize];
    ["Offset of field: v4l2_querymenu::index"]
        [::core::mem::offset_of!(v4l2_querymenu, index) - 4usize];
    ["Offset of field: v4l2_querymenu::reserved"]
        [::core::mem::offset_of!(v4l2_querymenu, reserved) - 40usize];
};
impl Default for v4l2_querymenu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_tuner {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub rxsubchans: __u32,
    pub audmode: __u32,
    pub signal: __s32,
    pub afc: __s32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_tuner"][::core::mem::size_of::<v4l2_tuner>() - 84usize];
    ["Alignment of v4l2_tuner"][::core::mem::align_of::<v4l2_tuner>() - 4usize];
    ["Offset of field: v4l2_tuner::index"][::core::mem::offset_of!(v4l2_tuner, index) - 0usize];
    ["Offset of field: v4l2_tuner::name"][::core::mem::offset_of!(v4l2_tuner, name) - 4usize];
    ["Offset of field: v4l2_tuner::type_"][::core::mem::offset_of!(v4l2_tuner, type_) - 36usize];
    ["Offset of field: v4l2_tuner::capability"]
        [::core::mem::offset_of!(v4l2_tuner, capability) - 40usize];
    ["Offset of field: v4l2_tuner::rangelow"]
        [::core::mem::offset_of!(v4l2_tuner, rangelow) - 44usize];
    ["Offset of field: v4l2_tuner::rangehigh"]
        [::core::mem::offset_of!(v4l2_tuner, rangehigh) - 48usize];
    ["Offset of field: v4l2_tuner::rxsubchans"]
        [::core::mem::offset_of!(v4l2_tuner, rxsubchans) - 52usize];
    ["Offset of field: v4l2_tuner::audmode"]
        [::core::mem::offset_of!(v4l2_tuner, audmode) - 56usize];
    ["Offset of field: v4l2_tuner::signal"][::core::mem::offset_of!(v4l2_tuner, signal) - 60usize];
    ["Offset of field: v4l2_tuner::afc"][::core::mem::offset_of!(v4l2_tuner, afc) - 64usize];
    ["Offset of field: v4l2_tuner::reserved"]
        [::core::mem::offset_of!(v4l2_tuner, reserved) - 68usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_modulator {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub txsubchans: __u32,
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_modulator"][::core::mem::size_of::<v4l2_modulator>() - 68usize];
    ["Alignment of v4l2_modulator"][::core::mem::align_of::<v4l2_modulator>() - 4usize];
    ["Offset of field: v4l2_modulator::index"]
        [::core::mem::offset_of!(v4l2_modulator, index) - 0usize];
    ["Offset of field: v4l2_modulator::name"]
        [::core::mem::offset_of!(v4l2_modulator, name) - 4usize];
    ["Offset of field: v4l2_modulator::capability"]
        [::core::mem::offset_of!(v4l2_modulator, capability) - 36usize];
    ["Offset of field: v4l2_modulator::rangelow"]
        [::core::mem::offset_of!(v4l2_modulator, rangelow) - 40usize];
    ["Offset of field: v4l2_modulator::rangehigh"]
        [::core::mem::offset_of!(v4l2_modulator, rangehigh) - 44usize];
    ["Offset of field: v4l2_modulator::txsubchans"]
        [::core::mem::offset_of!(v4l2_modulator, txsubchans) - 48usize];
    ["Offset of field: v4l2_modulator::type_"]
        [::core::mem::offset_of!(v4l2_modulator, type_) - 52usize];
    ["Offset of field: v4l2_modulator::reserved"]
        [::core::mem::offset_of!(v4l2_modulator, reserved) - 56usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frequency {
    pub tuner: __u32,
    pub type_: __u32,
    pub frequency: __u32,
    pub reserved: [__u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frequency"][::core::mem::size_of::<v4l2_frequency>() - 44usize];
    ["Alignment of v4l2_frequency"][::core::mem::align_of::<v4l2_frequency>() - 4usize];
    ["Offset of field: v4l2_frequency::tuner"]
        [::core::mem::offset_of!(v4l2_frequency, tuner) - 0usize];
    ["Offset of field: v4l2_frequency::type_"]
        [::core::mem::offset_of!(v4l2_frequency, type_) - 4usize];
    ["Offset of field: v4l2_frequency::frequency"]
        [::core::mem::offset_of!(v4l2_frequency, frequency) - 8usize];
    ["Offset of field: v4l2_frequency::reserved"]
        [::core::mem::offset_of!(v4l2_frequency, reserved) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frequency_band {
    pub tuner: __u32,
    pub type_: __u32,
    pub index: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub modulation: __u32,
    pub reserved: [__u32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frequency_band"][::core::mem::size_of::<v4l2_frequency_band>() - 64usize];
    ["Alignment of v4l2_frequency_band"][::core::mem::align_of::<v4l2_frequency_band>() - 4usize];
    ["Offset of field: v4l2_frequency_band::tuner"]
        [::core::mem::offset_of!(v4l2_frequency_band, tuner) - 0usize];
    ["Offset of field: v4l2_frequency_band::type_"]
        [::core::mem::offset_of!(v4l2_frequency_band, type_) - 4usize];
    ["Offset of field: v4l2_frequency_band::index"]
        [::core::mem::offset_of!(v4l2_frequency_band, index) - 8usize];
    ["Offset of field: v4l2_frequency_band::capability"]
        [::core::mem::offset_of!(v4l2_frequency_band, capability) - 12usize];
    ["Offset of field: v4l2_frequency_band::rangelow"]
        [::core::mem::offset_of!(v4l2_frequency_band, rangelow) - 16usize];
    ["Offset of field: v4l2_frequency_band::rangehigh"]
        [::core::mem::offset_of!(v4l2_frequency_band, rangehigh) - 20usize];
    ["Offset of field: v4l2_frequency_band::modulation"]
        [::core::mem::offset_of!(v4l2_frequency_band, modulation) - 24usize];
    ["Offset of field: v4l2_frequency_band::reserved"]
        [::core::mem::offset_of!(v4l2_frequency_band, reserved) - 28usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_hw_freq_seek {
    pub tuner: __u32,
    pub type_: __u32,
    pub seek_upward: __u32,
    pub wrap_around: __u32,
    pub spacing: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub reserved: [__u32; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_hw_freq_seek"][::core::mem::size_of::<v4l2_hw_freq_seek>() - 48usize];
    ["Alignment of v4l2_hw_freq_seek"][::core::mem::align_of::<v4l2_hw_freq_seek>() - 4usize];
    ["Offset of field: v4l2_hw_freq_seek::tuner"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, tuner) - 0usize];
    ["Offset of field: v4l2_hw_freq_seek::type_"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, type_) - 4usize];
    ["Offset of field: v4l2_hw_freq_seek::seek_upward"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, seek_upward) - 8usize];
    ["Offset of field: v4l2_hw_freq_seek::wrap_around"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, wrap_around) - 12usize];
    ["Offset of field: v4l2_hw_freq_seek::spacing"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, spacing) - 16usize];
    ["Offset of field: v4l2_hw_freq_seek::rangelow"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, rangelow) - 20usize];
    ["Offset of field: v4l2_hw_freq_seek::rangehigh"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, rangehigh) - 24usize];
    ["Offset of field: v4l2_hw_freq_seek::reserved"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, reserved) - 28usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_rds_data {
    pub lsb: __u8,
    pub msb: __u8,
    pub block: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_rds_data"][::core::mem::size_of::<v4l2_rds_data>() - 3usize];
    ["Alignment of v4l2_rds_data"][::core::mem::align_of::<v4l2_rds_data>() - 1usize];
    ["Offset of field: v4l2_rds_data::lsb"][::core::mem::offset_of!(v4l2_rds_data, lsb) - 0usize];
    ["Offset of field: v4l2_rds_data::msb"][::core::mem::offset_of!(v4l2_rds_data, msb) - 1usize];
    ["Offset of field: v4l2_rds_data::block"]
        [::core::mem::offset_of!(v4l2_rds_data, block) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_audio {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_audio"][::core::mem::size_of::<v4l2_audio>() - 52usize];
    ["Alignment of v4l2_audio"][::core::mem::align_of::<v4l2_audio>() - 4usize];
    ["Offset of field: v4l2_audio::index"][::core::mem::offset_of!(v4l2_audio, index) - 0usize];
    ["Offset of field: v4l2_audio::name"][::core::mem::offset_of!(v4l2_audio, name) - 4usize];
    ["Offset of field: v4l2_audio::capability"]
        [::core::mem::offset_of!(v4l2_audio, capability) - 36usize];
    ["Offset of field: v4l2_audio::mode"][::core::mem::offset_of!(v4l2_audio, mode) - 40usize];
    ["Offset of field: v4l2_audio::reserved"]
        [::core::mem::offset_of!(v4l2_audio, reserved) - 44usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_audioout {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_audioout"][::core::mem::size_of::<v4l2_audioout>() - 52usize];
    ["Alignment of v4l2_audioout"][::core::mem::align_of::<v4l2_audioout>() - 4usize];
    ["Offset of field: v4l2_audioout::index"]
        [::core::mem::offset_of!(v4l2_audioout, index) - 0usize];
    ["Offset of field: v4l2_audioout::name"][::core::mem::offset_of!(v4l2_audioout, name) - 4usize];
    ["Offset of field: v4l2_audioout::capability"]
        [::core::mem::offset_of!(v4l2_audioout, capability) - 36usize];
    ["Offset of field: v4l2_audioout::mode"]
        [::core::mem::offset_of!(v4l2_audioout, mode) - 40usize];
    ["Offset of field: v4l2_audioout::reserved"]
        [::core::mem::offset_of!(v4l2_audioout, reserved) - 44usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_enc_idx_entry {
    pub offset: __u64,
    pub pts: __u64,
    pub length: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_enc_idx_entry"][::core::mem::size_of::<v4l2_enc_idx_entry>() - 32usize];
    ["Alignment of v4l2_enc_idx_entry"][::core::mem::align_of::<v4l2_enc_idx_entry>() - 8usize];
    ["Offset of field: v4l2_enc_idx_entry::offset"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, offset) - 0usize];
    ["Offset of field: v4l2_enc_idx_entry::pts"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, pts) - 8usize];
    ["Offset of field: v4l2_enc_idx_entry::length"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, length) - 16usize];
    ["Offset of field: v4l2_enc_idx_entry::flags"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, flags) - 20usize];
    ["Offset of field: v4l2_enc_idx_entry::reserved"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_enc_idx {
    pub entries: __u32,
    pub entries_cap: __u32,
    pub reserved: [__u32; 4usize],
    pub entry: [v4l2_enc_idx_entry; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_enc_idx"][::core::mem::size_of::<v4l2_enc_idx>() - 2072usize];
    ["Alignment of v4l2_enc_idx"][::core::mem::align_of::<v4l2_enc_idx>() - 8usize];
    ["Offset of field: v4l2_enc_idx::entries"]
        [::core::mem::offset_of!(v4l2_enc_idx, entries) - 0usize];
    ["Offset of field: v4l2_enc_idx::entries_cap"]
        [::core::mem::offset_of!(v4l2_enc_idx, entries_cap) - 4usize];
    ["Offset of field: v4l2_enc_idx::reserved"]
        [::core::mem::offset_of!(v4l2_enc_idx, reserved) - 8usize];
    ["Offset of field: v4l2_enc_idx::entry"]
        [::core::mem::offset_of!(v4l2_enc_idx, entry) - 24usize];
};
impl Default for v4l2_enc_idx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_encoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __anon1: v4l2_encoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_encoder_cmd__bindgen_ty_1 {
    pub raw: v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub data: [__u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1::data"]
        [::core::mem::offset_of!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1, data) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_encoder_cmd__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_encoder_cmd__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_encoder_cmd__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(v4l2_encoder_cmd__bindgen_ty_1, raw) - 0usize];
};
impl Default for v4l2_encoder_cmd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_encoder_cmd"][::core::mem::size_of::<v4l2_encoder_cmd>() - 40usize];
    ["Alignment of v4l2_encoder_cmd"][::core::mem::align_of::<v4l2_encoder_cmd>() - 4usize];
    ["Offset of field: v4l2_encoder_cmd::cmd"]
        [::core::mem::offset_of!(v4l2_encoder_cmd, cmd) - 0usize];
    ["Offset of field: v4l2_encoder_cmd::flags"]
        [::core::mem::offset_of!(v4l2_encoder_cmd, flags) - 4usize];
};
impl Default for v4l2_encoder_cmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_decoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __anon1: v4l2_decoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_decoder_cmd__bindgen_ty_1 {
    pub stop: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1,
    pub start: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2,
    pub raw: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub pts: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1::pts"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1, pts) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2 {
    pub speed: __s32,
    pub format: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2::speed"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2, speed) - 0usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2::format"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2, format) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3 {
    pub data: [__u32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>() - 64usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>() - 4usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3::data"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3, data) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1>() - 64usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1::stop"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1, stop) - 0usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1::start"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1, start) - 0usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1, raw) - 0usize];
};
impl Default for v4l2_decoder_cmd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd"][::core::mem::size_of::<v4l2_decoder_cmd>() - 72usize];
    ["Alignment of v4l2_decoder_cmd"][::core::mem::align_of::<v4l2_decoder_cmd>() - 8usize];
    ["Offset of field: v4l2_decoder_cmd::cmd"]
        [::core::mem::offset_of!(v4l2_decoder_cmd, cmd) - 0usize];
    ["Offset of field: v4l2_decoder_cmd::flags"]
        [::core::mem::offset_of!(v4l2_decoder_cmd, flags) - 4usize];
};
impl Default for v4l2_decoder_cmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_vbi_format {
    pub sampling_rate: __u32,
    pub offset: __u32,
    pub samples_per_line: __u32,
    pub sample_format: __u32,
    pub start: [__s32; 2usize],
    pub count: [__u32; 2usize],
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_vbi_format"][::core::mem::size_of::<v4l2_vbi_format>() - 44usize];
    ["Alignment of v4l2_vbi_format"][::core::mem::align_of::<v4l2_vbi_format>() - 4usize];
    ["Offset of field: v4l2_vbi_format::sampling_rate"]
        [::core::mem::offset_of!(v4l2_vbi_format, sampling_rate) - 0usize];
    ["Offset of field: v4l2_vbi_format::offset"]
        [::core::mem::offset_of!(v4l2_vbi_format, offset) - 4usize];
    ["Offset of field: v4l2_vbi_format::samples_per_line"]
        [::core::mem::offset_of!(v4l2_vbi_format, samples_per_line) - 8usize];
    ["Offset of field: v4l2_vbi_format::sample_format"]
        [::core::mem::offset_of!(v4l2_vbi_format, sample_format) - 12usize];
    ["Offset of field: v4l2_vbi_format::start"]
        [::core::mem::offset_of!(v4l2_vbi_format, start) - 16usize];
    ["Offset of field: v4l2_vbi_format::count"]
        [::core::mem::offset_of!(v4l2_vbi_format, count) - 24usize];
    ["Offset of field: v4l2_vbi_format::flags"]
        [::core::mem::offset_of!(v4l2_vbi_format, flags) - 32usize];
    ["Offset of field: v4l2_vbi_format::reserved"]
        [::core::mem::offset_of!(v4l2_vbi_format, reserved) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_sliced_vbi_format {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub io_size: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sliced_vbi_format"][::core::mem::size_of::<v4l2_sliced_vbi_format>() - 112usize];
    ["Alignment of v4l2_sliced_vbi_format"]
        [::core::mem::align_of::<v4l2_sliced_vbi_format>() - 4usize];
    ["Offset of field: v4l2_sliced_vbi_format::service_set"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, service_set) - 0usize];
    ["Offset of field: v4l2_sliced_vbi_format::service_lines"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, service_lines) - 2usize];
    ["Offset of field: v4l2_sliced_vbi_format::io_size"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, io_size) - 100usize];
    ["Offset of field: v4l2_sliced_vbi_format::reserved"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, reserved) - 104usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_sliced_vbi_cap {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sliced_vbi_cap"][::core::mem::size_of::<v4l2_sliced_vbi_cap>() - 116usize];
    ["Alignment of v4l2_sliced_vbi_cap"][::core::mem::align_of::<v4l2_sliced_vbi_cap>() - 4usize];
    ["Offset of field: v4l2_sliced_vbi_cap::service_set"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, service_set) - 0usize];
    ["Offset of field: v4l2_sliced_vbi_cap::service_lines"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, service_lines) - 2usize];
    ["Offset of field: v4l2_sliced_vbi_cap::type_"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, type_) - 100usize];
    ["Offset of field: v4l2_sliced_vbi_cap::reserved"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, reserved) - 104usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_data {
    pub id: __u32,
    pub field: __u32,
    pub line: __u32,
    pub reserved: __u32,
    pub data: [__u8; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sliced_vbi_data"][::core::mem::size_of::<v4l2_sliced_vbi_data>() - 64usize];
    ["Alignment of v4l2_sliced_vbi_data"][::core::mem::align_of::<v4l2_sliced_vbi_data>() - 4usize];
    ["Offset of field: v4l2_sliced_vbi_data::id"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, id) - 0usize];
    ["Offset of field: v4l2_sliced_vbi_data::field"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, field) - 4usize];
    ["Offset of field: v4l2_sliced_vbi_data::line"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, line) - 8usize];
    ["Offset of field: v4l2_sliced_vbi_data::reserved"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, reserved) - 12usize];
    ["Offset of field: v4l2_sliced_vbi_data::data"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, data) - 16usize];
};
impl Default for v4l2_sliced_vbi_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0_line {
    pub id: __u8,
    pub data: [__u8; 42usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_itv0_line"]
        [::core::mem::size_of::<v4l2_mpeg_vbi_itv0_line>() - 43usize];
    ["Alignment of v4l2_mpeg_vbi_itv0_line"]
        [::core::mem::align_of::<v4l2_mpeg_vbi_itv0_line>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0_line::id"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0_line, id) - 0usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0_line::data"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0_line, data) - 1usize];
};
impl Default for v4l2_mpeg_vbi_itv0_line {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0 {
    pub linemask: [__le32; 2usize],
    pub line: [v4l2_mpeg_vbi_itv0_line; 35usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_itv0"][::core::mem::size_of::<v4l2_mpeg_vbi_itv0>() - 1513usize];
    ["Alignment of v4l2_mpeg_vbi_itv0"][::core::mem::align_of::<v4l2_mpeg_vbi_itv0>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0::linemask"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0, linemask) - 0usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0::line"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0, line) - 8usize];
};
impl Default for v4l2_mpeg_vbi_itv0 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_ITV0 {
    pub line: [v4l2_mpeg_vbi_itv0_line; 36usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_ITV0"][::core::mem::size_of::<v4l2_mpeg_vbi_ITV0>() - 1548usize];
    ["Alignment of v4l2_mpeg_vbi_ITV0"][::core::mem::align_of::<v4l2_mpeg_vbi_ITV0>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_ITV0::line"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_ITV0, line) - 0usize];
};
impl Default for v4l2_mpeg_vbi_ITV0 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_fmt_ivtv {
    pub magic: [__u8; 4usize],
    pub __anon1: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1 {
    pub itv0: v4l2_mpeg_vbi_itv0,
    pub ITV0: v4l2_mpeg_vbi_ITV0,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>() - 1548usize];
    ["Alignment of v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1::itv0"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1, itv0) - 0usize];
    ["Offset of field: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1::ITV0"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1, ITV0) - 0usize];
};
impl Default for v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_fmt_ivtv"]
        [::core::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv>() - 1552usize];
    ["Alignment of v4l2_mpeg_vbi_fmt_ivtv"]
        [::core::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_fmt_ivtv::magic"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_fmt_ivtv, magic) - 0usize];
};
impl Default for v4l2_mpeg_vbi_fmt_ivtv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_plane_pix_format - additional, per-plane format definition\n @sizeimage:\t\tmaximum size in bytes required for data, for which\n\t\t\tthis plane will be used\n @bytesperline:\tdistance in bytes between the leftmost pixels in two\n\t\t\tadjacent lines"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_plane_pix_format {
    pub sizeimage: __u32,
    pub bytesperline: __u32,
    pub reserved: [__u16; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_plane_pix_format"][::core::mem::size_of::<v4l2_plane_pix_format>() - 20usize];
    ["Alignment of v4l2_plane_pix_format"]
        [::core::mem::align_of::<v4l2_plane_pix_format>() - 1usize];
    ["Offset of field: v4l2_plane_pix_format::sizeimage"]
        [::core::mem::offset_of!(v4l2_plane_pix_format, sizeimage) - 0usize];
    ["Offset of field: v4l2_plane_pix_format::bytesperline"]
        [::core::mem::offset_of!(v4l2_plane_pix_format, bytesperline) - 4usize];
    ["Offset of field: v4l2_plane_pix_format::reserved"]
        [::core::mem::offset_of!(v4l2_plane_pix_format, reserved) - 8usize];
};
#[doc = " struct v4l2_pix_format_mplane - multiplanar format definition\n @width:\t\timage width in pixels\n @height:\t\timage height in pixels\n @pixelformat:\tlittle endian four character code (fourcc)\n @field:\t\tenum v4l2_field; field order (for interlaced video)\n @colorspace:\t\tenum v4l2_colorspace; supplemental to pixelformat\n @plane_fmt:\t\tper-plane information\n @num_planes:\t\tnumber of planes for this format\n @flags:\t\tformat flags (V4L2_PIX_FMT_FLAG_*)\n @ycbcr_enc:\t\tenum v4l2_ycbcr_encoding, Y'CbCr encoding\n @quantization:\tenum v4l2_quantization, colorspace quantization\n @xfer_func:\t\tenum v4l2_xfer_func, colorspace transfer function"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format_mplane {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub colorspace: __u32,
    pub plane_fmt: [v4l2_plane_pix_format; 8usize],
    pub num_planes: __u8,
    pub flags: __u8,
    pub __anon1: v4l2_pix_format_mplane__bindgen_ty_1,
    pub quantization: __u8,
    pub xfer_func: __u8,
    pub reserved: [__u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format_mplane__bindgen_ty_1 {
    pub ycbcr_enc: __u8,
    pub hsv_enc: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format_mplane__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_pix_format_mplane__bindgen_ty_1>() - 1usize];
    ["Alignment of v4l2_pix_format_mplane__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_pix_format_mplane__bindgen_ty_1>() - 1usize];
    ["Offset of field: v4l2_pix_format_mplane__bindgen_ty_1::ycbcr_enc"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane__bindgen_ty_1, ycbcr_enc) - 0usize];
    ["Offset of field: v4l2_pix_format_mplane__bindgen_ty_1::hsv_enc"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane__bindgen_ty_1, hsv_enc) - 0usize];
};
impl Default for v4l2_pix_format_mplane__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format_mplane"][::core::mem::size_of::<v4l2_pix_format_mplane>() - 192usize];
    ["Alignment of v4l2_pix_format_mplane"]
        [::core::mem::align_of::<v4l2_pix_format_mplane>() - 1usize];
    ["Offset of field: v4l2_pix_format_mplane::width"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, width) - 0usize];
    ["Offset of field: v4l2_pix_format_mplane::height"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, height) - 4usize];
    ["Offset of field: v4l2_pix_format_mplane::pixelformat"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, pixelformat) - 8usize];
    ["Offset of field: v4l2_pix_format_mplane::field"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, field) - 12usize];
    ["Offset of field: v4l2_pix_format_mplane::colorspace"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, colorspace) - 16usize];
    ["Offset of field: v4l2_pix_format_mplane::plane_fmt"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, plane_fmt) - 20usize];
    ["Offset of field: v4l2_pix_format_mplane::num_planes"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, num_planes) - 180usize];
    ["Offset of field: v4l2_pix_format_mplane::flags"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, flags) - 181usize];
    ["Offset of field: v4l2_pix_format_mplane::quantization"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, quantization) - 183usize];
    ["Offset of field: v4l2_pix_format_mplane::xfer_func"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, xfer_func) - 184usize];
    ["Offset of field: v4l2_pix_format_mplane::reserved"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, reserved) - 185usize];
};
impl Default for v4l2_pix_format_mplane {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_sdr_format - SDR format definition\n @pixelformat:\tlittle endian four character code (fourcc)\n @buffersize:\t\tmaximum size in bytes required for data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_sdr_format {
    pub pixelformat: __u32,
    pub buffersize: __u32,
    pub reserved: [__u8; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sdr_format"][::core::mem::size_of::<v4l2_sdr_format>() - 32usize];
    ["Alignment of v4l2_sdr_format"][::core::mem::align_of::<v4l2_sdr_format>() - 1usize];
    ["Offset of field: v4l2_sdr_format::pixelformat"]
        [::core::mem::offset_of!(v4l2_sdr_format, pixelformat) - 0usize];
    ["Offset of field: v4l2_sdr_format::buffersize"]
        [::core::mem::offset_of!(v4l2_sdr_format, buffersize) - 4usize];
    ["Offset of field: v4l2_sdr_format::reserved"]
        [::core::mem::offset_of!(v4l2_sdr_format, reserved) - 8usize];
};
#[doc = " struct v4l2_meta_format - metadata format definition\n @dataformat:\t\tlittle endian four character code (fourcc)\n @buffersize:\t\tmaximum size in bytes required for data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_meta_format {
    pub dataformat: __u32,
    pub buffersize: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_meta_format"][::core::mem::size_of::<v4l2_meta_format>() - 8usize];
    ["Alignment of v4l2_meta_format"][::core::mem::align_of::<v4l2_meta_format>() - 1usize];
    ["Offset of field: v4l2_meta_format::dataformat"]
        [::core::mem::offset_of!(v4l2_meta_format, dataformat) - 0usize];
    ["Offset of field: v4l2_meta_format::buffersize"]
        [::core::mem::offset_of!(v4l2_meta_format, buffersize) - 4usize];
};
#[doc = " struct v4l2_format - stream data format\n @type:\tenum v4l2_buf_type; type of the data stream\n @pix:\tdefinition of an image format\n @pix_mp:\tdefinition of a multiplanar image format\n @win:\tdefinition of an overlaid image\n @vbi:\traw VBI capture or output parameters\n @sliced:\tsliced VBI capture or output parameters\n @raw_data:\tplaceholder for future extensions and custom formats"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_format {
    pub type_: __u32,
    pub fmt: v4l2_format__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_format__bindgen_ty_1 {
    pub pix: v4l2_pix_format,
    pub pix_mp: v4l2_pix_format_mplane,
    pub win: v4l2_window,
    pub vbi: v4l2_vbi_format,
    pub sliced: v4l2_sliced_vbi_format,
    pub sdr: v4l2_sdr_format,
    pub meta: v4l2_meta_format,
    pub raw_data: [__u8; 200usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_format__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_format__bindgen_ty_1>() - 200usize];
    ["Alignment of v4l2_format__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_format__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::pix"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, pix) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::pix_mp"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, pix_mp) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::win"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, win) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::vbi"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, vbi) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::sliced"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, sliced) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::sdr"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, sdr) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::meta"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, meta) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::raw_data"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, raw_data) - 0usize];
};
impl Default for v4l2_format__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_format"][::core::mem::size_of::<v4l2_format>() - 204usize];
    ["Alignment of v4l2_format"][::core::mem::align_of::<v4l2_format>() - 4usize];
    ["Offset of field: v4l2_format::type_"][::core::mem::offset_of!(v4l2_format, type_) - 0usize];
    ["Offset of field: v4l2_format::fmt"][::core::mem::offset_of!(v4l2_format, fmt) - 4usize];
};
impl Default for v4l2_format {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_streamparm {
    pub type_: __u32,
    pub parm: v4l2_streamparm__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_streamparm__bindgen_ty_1 {
    pub capture: v4l2_captureparm,
    pub output: v4l2_outputparm,
    pub raw_data: [__u8; 200usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_streamparm__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_streamparm__bindgen_ty_1>() - 200usize];
    ["Alignment of v4l2_streamparm__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_streamparm__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_streamparm__bindgen_ty_1::capture"]
        [::core::mem::offset_of!(v4l2_streamparm__bindgen_ty_1, capture) - 0usize];
    ["Offset of field: v4l2_streamparm__bindgen_ty_1::output"]
        [::core::mem::offset_of!(v4l2_streamparm__bindgen_ty_1, output) - 0usize];
    ["Offset of field: v4l2_streamparm__bindgen_ty_1::raw_data"]
        [::core::mem::offset_of!(v4l2_streamparm__bindgen_ty_1, raw_data) - 0usize];
};
impl Default for v4l2_streamparm__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_streamparm"][::core::mem::size_of::<v4l2_streamparm>() - 204usize];
    ["Alignment of v4l2_streamparm"][::core::mem::align_of::<v4l2_streamparm>() - 4usize];
    ["Offset of field: v4l2_streamparm::type_"]
        [::core::mem::offset_of!(v4l2_streamparm, type_) - 0usize];
    ["Offset of field: v4l2_streamparm::parm"]
        [::core::mem::offset_of!(v4l2_streamparm, parm) - 4usize];
};
impl Default for v4l2_streamparm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_vsync {
    pub field: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_vsync"][::core::mem::size_of::<v4l2_event_vsync>() - 1usize];
    ["Alignment of v4l2_event_vsync"][::core::mem::align_of::<v4l2_event_vsync>() - 1usize];
    ["Offset of field: v4l2_event_vsync::field"]
        [::core::mem::offset_of!(v4l2_event_vsync, field) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event_ctrl {
    pub changes: __u32,
    pub type_: __u32,
    pub __anon1: v4l2_event_ctrl__bindgen_ty_1,
    pub flags: __u32,
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event_ctrl__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_ctrl__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_event_ctrl__bindgen_ty_1>() - 8usize];
    ["Alignment of v4l2_event_ctrl__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_event_ctrl__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_event_ctrl__bindgen_ty_1::value"]
        [::core::mem::offset_of!(v4l2_event_ctrl__bindgen_ty_1, value) - 0usize];
    ["Offset of field: v4l2_event_ctrl__bindgen_ty_1::value64"]
        [::core::mem::offset_of!(v4l2_event_ctrl__bindgen_ty_1, value64) - 0usize];
};
impl Default for v4l2_event_ctrl__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_ctrl"][::core::mem::size_of::<v4l2_event_ctrl>() - 40usize];
    ["Alignment of v4l2_event_ctrl"][::core::mem::align_of::<v4l2_event_ctrl>() - 8usize];
    ["Offset of field: v4l2_event_ctrl::changes"]
        [::core::mem::offset_of!(v4l2_event_ctrl, changes) - 0usize];
    ["Offset of field: v4l2_event_ctrl::type_"]
        [::core::mem::offset_of!(v4l2_event_ctrl, type_) - 4usize];
    ["Offset of field: v4l2_event_ctrl::flags"]
        [::core::mem::offset_of!(v4l2_event_ctrl, flags) - 16usize];
    ["Offset of field: v4l2_event_ctrl::minimum"]
        [::core::mem::offset_of!(v4l2_event_ctrl, minimum) - 20usize];
    ["Offset of field: v4l2_event_ctrl::maximum"]
        [::core::mem::offset_of!(v4l2_event_ctrl, maximum) - 24usize];
    ["Offset of field: v4l2_event_ctrl::step"]
        [::core::mem::offset_of!(v4l2_event_ctrl, step) - 28usize];
    ["Offset of field: v4l2_event_ctrl::default_value"]
        [::core::mem::offset_of!(v4l2_event_ctrl, default_value) - 32usize];
};
impl Default for v4l2_event_ctrl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_frame_sync {
    pub frame_sequence: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_frame_sync"][::core::mem::size_of::<v4l2_event_frame_sync>() - 4usize];
    ["Alignment of v4l2_event_frame_sync"]
        [::core::mem::align_of::<v4l2_event_frame_sync>() - 4usize];
    ["Offset of field: v4l2_event_frame_sync::frame_sequence"]
        [::core::mem::offset_of!(v4l2_event_frame_sync, frame_sequence) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_src_change {
    pub changes: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_src_change"][::core::mem::size_of::<v4l2_event_src_change>() - 4usize];
    ["Alignment of v4l2_event_src_change"]
        [::core::mem::align_of::<v4l2_event_src_change>() - 4usize];
    ["Offset of field: v4l2_event_src_change::changes"]
        [::core::mem::offset_of!(v4l2_event_src_change, changes) - 0usize];
};
#[doc = " struct v4l2_event_motion_det - motion detection event\n @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the\n                     frame_sequence field is valid.\n @frame_sequence:    the frame sequence number associated with this event.\n @region_mask:       which regions detected motion."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_motion_det {
    pub flags: __u32,
    pub frame_sequence: __u32,
    pub region_mask: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_motion_det"][::core::mem::size_of::<v4l2_event_motion_det>() - 12usize];
    ["Alignment of v4l2_event_motion_det"]
        [::core::mem::align_of::<v4l2_event_motion_det>() - 4usize];
    ["Offset of field: v4l2_event_motion_det::flags"]
        [::core::mem::offset_of!(v4l2_event_motion_det, flags) - 0usize];
    ["Offset of field: v4l2_event_motion_det::frame_sequence"]
        [::core::mem::offset_of!(v4l2_event_motion_det, frame_sequence) - 4usize];
    ["Offset of field: v4l2_event_motion_det::region_mask"]
        [::core::mem::offset_of!(v4l2_event_motion_det, region_mask) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event {
    pub type_: __u32,
    pub u: v4l2_event__bindgen_ty_1,
    pub pending: __u32,
    pub sequence: __u32,
    pub timestamp: timespec,
    pub id: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event__bindgen_ty_1 {
    pub vsync: v4l2_event_vsync,
    pub ctrl: v4l2_event_ctrl,
    pub frame_sync: v4l2_event_frame_sync,
    pub src_change: v4l2_event_src_change,
    pub motion_det: v4l2_event_motion_det,
    pub data: [__u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_event__bindgen_ty_1>() - 64usize];
    ["Alignment of v4l2_event__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_event__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::vsync"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, vsync) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::ctrl"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, ctrl) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::frame_sync"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, frame_sync) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::src_change"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, src_change) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::motion_det"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, motion_det) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::data"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, data) - 0usize];
};
impl Default for v4l2_event__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event"][::core::mem::size_of::<v4l2_event>() - 128usize];
    ["Alignment of v4l2_event"][::core::mem::align_of::<v4l2_event>() - 8usize];
    ["Offset of field: v4l2_event::type_"][::core::mem::offset_of!(v4l2_event, type_) - 0usize];
    ["Offset of field: v4l2_event::u"][::core::mem::offset_of!(v4l2_event, u) - 8usize];
    ["Offset of field: v4l2_event::pending"]
        [::core::mem::offset_of!(v4l2_event, pending) - 72usize];
    ["Offset of field: v4l2_event::sequence"]
        [::core::mem::offset_of!(v4l2_event, sequence) - 76usize];
    ["Offset of field: v4l2_event::timestamp"]
        [::core::mem::offset_of!(v4l2_event, timestamp) - 80usize];
    ["Offset of field: v4l2_event::id"][::core::mem::offset_of!(v4l2_event, id) - 88usize];
    ["Offset of field: v4l2_event::reserved"]
        [::core::mem::offset_of!(v4l2_event, reserved) - 92usize];
};
impl Default for v4l2_event {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_subscription {
    pub type_: __u32,
    pub id: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_subscription"]
        [::core::mem::size_of::<v4l2_event_subscription>() - 32usize];
    ["Alignment of v4l2_event_subscription"]
        [::core::mem::align_of::<v4l2_event_subscription>() - 4usize];
    ["Offset of field: v4l2_event_subscription::type_"]
        [::core::mem::offset_of!(v4l2_event_subscription, type_) - 0usize];
    ["Offset of field: v4l2_event_subscription::id"]
        [::core::mem::offset_of!(v4l2_event_subscription, id) - 4usize];
    ["Offset of field: v4l2_event_subscription::flags"]
        [::core::mem::offset_of!(v4l2_event_subscription, flags) - 8usize];
    ["Offset of field: v4l2_event_subscription::reserved"]
        [::core::mem::offset_of!(v4l2_event_subscription, reserved) - 12usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_match {
    pub type_: __u32,
    pub __anon1: v4l2_dbg_match__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dbg_match__bindgen_ty_1 {
    pub addr: __u32,
    pub name: [libc::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_match__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_dbg_match__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_dbg_match__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_dbg_match__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_dbg_match__bindgen_ty_1::addr"]
        [::core::mem::offset_of!(v4l2_dbg_match__bindgen_ty_1, addr) - 0usize];
    ["Offset of field: v4l2_dbg_match__bindgen_ty_1::name"]
        [::core::mem::offset_of!(v4l2_dbg_match__bindgen_ty_1, name) - 0usize];
};
impl Default for v4l2_dbg_match__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_match"][::core::mem::size_of::<v4l2_dbg_match>() - 36usize];
    ["Alignment of v4l2_dbg_match"][::core::mem::align_of::<v4l2_dbg_match>() - 1usize];
    ["Offset of field: v4l2_dbg_match::type_"]
        [::core::mem::offset_of!(v4l2_dbg_match, type_) - 0usize];
};
impl Default for v4l2_dbg_match {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_register {
    pub match_: v4l2_dbg_match,
    pub size: __u32,
    pub reg: __u64,
    pub val: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_register"][::core::mem::size_of::<v4l2_dbg_register>() - 56usize];
    ["Alignment of v4l2_dbg_register"][::core::mem::align_of::<v4l2_dbg_register>() - 1usize];
    ["Offset of field: v4l2_dbg_register::match_"]
        [::core::mem::offset_of!(v4l2_dbg_register, match_) - 0usize];
    ["Offset of field: v4l2_dbg_register::size"]
        [::core::mem::offset_of!(v4l2_dbg_register, size) - 36usize];
    ["Offset of field: v4l2_dbg_register::reg"]
        [::core::mem::offset_of!(v4l2_dbg_register, reg) - 40usize];
    ["Offset of field: v4l2_dbg_register::val"]
        [::core::mem::offset_of!(v4l2_dbg_register, val) - 48usize];
};
impl Default for v4l2_dbg_register {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_chip_info {
    pub match_: v4l2_dbg_match,
    pub name: [libc::c_char; 32usize],
    pub flags: __u32,
    pub reserved: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_chip_info"][::core::mem::size_of::<v4l2_dbg_chip_info>() - 200usize];
    ["Alignment of v4l2_dbg_chip_info"][::core::mem::align_of::<v4l2_dbg_chip_info>() - 1usize];
    ["Offset of field: v4l2_dbg_chip_info::match_"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, match_) - 0usize];
    ["Offset of field: v4l2_dbg_chip_info::name"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, name) - 36usize];
    ["Offset of field: v4l2_dbg_chip_info::flags"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, flags) - 68usize];
    ["Offset of field: v4l2_dbg_chip_info::reserved"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, reserved) - 72usize];
};
impl Default for v4l2_dbg_chip_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument\n @index:\ton return, index of the first created buffer\n @count:\tentry: number of requested buffers,\n\t\treturn: number of created buffers\n @memory:\tenum v4l2_memory; buffer memory type\n @format:\tframe format, for which buffers are requested\n @capabilities: capabilities of this buffer type.\n @reserved:\tfuture extensions"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_create_buffers {
    pub index: __u32,
    pub count: __u32,
    pub memory: __u32,
    pub format: v4l2_format,
    pub capabilities: __u32,
    pub reserved: [__u32; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_create_buffers"][::core::mem::size_of::<v4l2_create_buffers>() - 248usize];
    ["Alignment of v4l2_create_buffers"][::core::mem::align_of::<v4l2_create_buffers>() - 4usize];
    ["Offset of field: v4l2_create_buffers::index"]
        [::core::mem::offset_of!(v4l2_create_buffers, index) - 0usize];
    ["Offset of field: v4l2_create_buffers::count"]
        [::core::mem::offset_of!(v4l2_create_buffers, count) - 4usize];
    ["Offset of field: v4l2_create_buffers::memory"]
        [::core::mem::offset_of!(v4l2_create_buffers, memory) - 8usize];
    ["Offset of field: v4l2_create_buffers::format"]
        [::core::mem::offset_of!(v4l2_create_buffers, format) - 12usize];
    ["Offset of field: v4l2_create_buffers::capabilities"]
        [::core::mem::offset_of!(v4l2_create_buffers, capabilities) - 216usize];
    ["Offset of field: v4l2_create_buffers::reserved"]
        [::core::mem::offset_of!(v4l2_create_buffers, reserved) - 220usize];
};
impl Default for v4l2_create_buffers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::core::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::core::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::core::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::core::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::core::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::core::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::core::mem::size_of::<_G_fpos_t>() - 12usize];
    ["Alignment of _G_fpos_t"][::core::mem::align_of::<_G_fpos_t>() - 4usize];
    ["Offset of field: _G_fpos_t::__pos"][::core::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::core::mem::offset_of!(_G_fpos_t, __state) - 4usize];
};
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::core::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::core::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::core::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::core::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::core::mem::size_of::<_IO_FILE>() - 152usize];
    ["Alignment of _IO_FILE"][::core::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::core::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::core::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 4usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_read_end) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_read_base) - 12usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_write_base) - 16usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::core::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 20usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_write_end) - 24usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_buf_base) - 28usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_buf_end) - 32usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_save_base) - 36usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_backup_base) - 40usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_save_end) - 44usize];
    ["Offset of field: _IO_FILE::_markers"][::core::mem::offset_of!(_IO_FILE, _markers) - 48usize];
    ["Offset of field: _IO_FILE::_chain"][::core::mem::offset_of!(_IO_FILE, _chain) - 52usize];
    ["Offset of field: _IO_FILE::_fileno"][::core::mem::offset_of!(_IO_FILE, _fileno) - 56usize];
    ["Offset of field: _IO_FILE::_flags2"][::core::mem::offset_of!(_IO_FILE, _flags2) - 60usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::core::mem::offset_of!(_IO_FILE, _old_offset) - 64usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::core::mem::offset_of!(_IO_FILE, _cur_column) - 68usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::core::mem::offset_of!(_IO_FILE, _vtable_offset) - 70usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::core::mem::offset_of!(_IO_FILE, _shortbuf) - 71usize];
    ["Offset of field: _IO_FILE::_lock"][::core::mem::offset_of!(_IO_FILE, _lock) - 72usize];
    ["Offset of field: _IO_FILE::_offset"][::core::mem::offset_of!(_IO_FILE, _offset) - 80usize];
    ["Offset of field: _IO_FILE::_codecvt"][::core::mem::offset_of!(_IO_FILE, _codecvt) - 88usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::core::mem::offset_of!(_IO_FILE, _wide_data) - 92usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::core::mem::offset_of!(_IO_FILE, _freeres_list) - 96usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::core::mem::offset_of!(_IO_FILE, _freeres_buf) - 100usize];
    ["Offset of field: _IO_FILE::__pad5"][::core::mem::offset_of!(_IO_FILE, __pad5) - 104usize];
    ["Offset of field: _IO_FILE::_mode"][::core::mem::offset_of!(_IO_FILE, _mode) - 108usize];
    ["Offset of field: _IO_FILE::_unused2"][::core::mem::offset_of!(_IO_FILE, _unused2) - 112usize];
};
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: libc::c_int,
        __old: *const libc::c_char,
        __newfd: libc::c_int,
        __new: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __pfx: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut libc::c_void,
        __len: usize,
        __modes: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut libc::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const libc::c_char, __arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_uint,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_uint,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: libc::c_int,
        __fmt: *const libc::c_char,
        __arg: __gnuc_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, __arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const libc::c_char, __arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(__w: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: libc::c_uint,
        __n: libc::c_uint,
        __stream: *mut FILE,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: libc::c_uint,
        __n: libc::c_uint,
        __s: *mut FILE,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const libc::c_char);
}
extern "C" {
    pub static mut sys_nerr: libc::c_int;
}
extern "C" {
    pub static sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: libc::c_int) -> libc::c_int;
}
#[repr(u32)]
#[doc = " IMP 设备ID枚举定义."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPDeviceID {
    #[doc = "< 视频源"]
    DEV_ID_FS = 0,
    #[doc = "< 编码器"]
    DEV_ID_ENC = 1,
    #[doc = "< 解码器"]
    DEV_ID_DEC = 2,
    #[doc = "< 算法"]
    DEV_ID_IVS = 3,
    #[doc = "< 图像叠加"]
    DEV_ID_OSD = 4,
    #[doc = "< FB FG1Direct"]
    DEV_ID_FG1DIRECT = 5,
    DEV_ID_RESERVED_START = 6,
    DEV_ID_RESERVED_END = 23,
    NR_MAX_DEVICES = 24,
}
#[doc = " IMPCell枚举定义."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPCell {
    #[doc = "< 设备ID"]
    pub deviceID: IMPDeviceID,
    #[doc = "< 组ID"]
    pub groupID: libc::c_int,
    #[doc = "< 输出ID"]
    pub outputID: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPCell"][::core::mem::size_of::<IMPCell>() - 12usize];
    ["Alignment of IMPCell"][::core::mem::align_of::<IMPCell>() - 4usize];
    ["Offset of field: IMPCell::deviceID"][::core::mem::offset_of!(IMPCell, deviceID) - 0usize];
    ["Offset of field: IMPCell::groupID"][::core::mem::offset_of!(IMPCell, groupID) - 4usize];
    ["Offset of field: IMPCell::outputID"][::core::mem::offset_of!(IMPCell, outputID) - 8usize];
};
impl Default for IMPCell {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " IMP帧图像信息定义."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct IMPFrameInfo {
    #[doc = "< 帧序号"]
    pub index: libc::c_int,
    #[doc = "< 帧所在的Pool的ID"]
    pub pool_idx: libc::c_int,
    #[doc = "< 帧宽"]
    pub width: u32,
    #[doc = "< 帧高"]
    pub height: u32,
    #[doc = "< 帧的图像格式"]
    pub pixfmt: u32,
    #[doc = "< 帧所占用空间大小"]
    pub size: u32,
    #[doc = "< 帧的物理地址"]
    pub phyAddr: u32,
    #[doc = "< 帧的虚拟地址"]
    pub virAddr: u32,
    #[doc = "< 帧的直通地址"]
    pub direct_phyAddr: u32,
    #[doc = "< 帧的时间戳"]
    pub timeStamp: i64,
    #[doc = "< 直通帧的dq时间戳"]
    pub timeStamp_ivdc: i64,
    #[doc = "< 私有数据"]
    pub priv_: __IncompleteArrayField<u32>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFrameInfo"][::core::mem::size_of::<IMPFrameInfo>() - 56usize];
    ["Alignment of IMPFrameInfo"][::core::mem::align_of::<IMPFrameInfo>() - 8usize];
    ["Offset of field: IMPFrameInfo::index"][::core::mem::offset_of!(IMPFrameInfo, index) - 0usize];
    ["Offset of field: IMPFrameInfo::pool_idx"]
        [::core::mem::offset_of!(IMPFrameInfo, pool_idx) - 4usize];
    ["Offset of field: IMPFrameInfo::width"][::core::mem::offset_of!(IMPFrameInfo, width) - 8usize];
    ["Offset of field: IMPFrameInfo::height"]
        [::core::mem::offset_of!(IMPFrameInfo, height) - 12usize];
    ["Offset of field: IMPFrameInfo::pixfmt"]
        [::core::mem::offset_of!(IMPFrameInfo, pixfmt) - 16usize];
    ["Offset of field: IMPFrameInfo::size"][::core::mem::offset_of!(IMPFrameInfo, size) - 20usize];
    ["Offset of field: IMPFrameInfo::phyAddr"]
        [::core::mem::offset_of!(IMPFrameInfo, phyAddr) - 24usize];
    ["Offset of field: IMPFrameInfo::virAddr"]
        [::core::mem::offset_of!(IMPFrameInfo, virAddr) - 28usize];
    ["Offset of field: IMPFrameInfo::direct_phyAddr"]
        [::core::mem::offset_of!(IMPFrameInfo, direct_phyAddr) - 32usize];
    ["Offset of field: IMPFrameInfo::timeStamp"]
        [::core::mem::offset_of!(IMPFrameInfo, timeStamp) - 40usize];
    ["Offset of field: IMPFrameInfo::timeStamp_ivdc"]
        [::core::mem::offset_of!(IMPFrameInfo, timeStamp_ivdc) - 48usize];
    ["Offset of field: IMPFrameInfo::priv_"]
        [::core::mem::offset_of!(IMPFrameInfo, priv_) - 56usize];
};
#[doc = " IMP帧时间参数."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPFrameTimestamp {
    #[doc = "< 时间"]
    pub ts: u64,
    #[doc = "< 下限"]
    pub minus: u64,
    #[doc = "< 上限"]
    pub plus: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFrameTimestamp"][::core::mem::size_of::<IMPFrameTimestamp>() - 24usize];
    ["Alignment of IMPFrameTimestamp"][::core::mem::align_of::<IMPFrameTimestamp>() - 8usize];
    ["Offset of field: IMPFrameTimestamp::ts"]
        [::core::mem::offset_of!(IMPFrameTimestamp, ts) - 0usize];
    ["Offset of field: IMPFrameTimestamp::minus"]
        [::core::mem::offset_of!(IMPFrameTimestamp, minus) - 8usize];
    ["Offset of field: IMPFrameTimestamp::plus"]
        [::core::mem::offset_of!(IMPFrameTimestamp, plus) - 16usize];
};
#[repr(u32)]
#[doc = " 编解码协议类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPPayloadType {
    #[doc = "< JPEG图像协议类型"]
    PT_JPEG = 0,
    #[doc = "< H264视频协议类型"]
    PT_H264 = 1,
    #[doc = "< H265视频协议类型"]
    PT_H265 = 2,
}
#[repr(u32)]
#[doc = " IMP图像格式定义."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPPixelFormat {
    #[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
    PIX_FMT_YUV420P = 0,
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
    PIX_FMT_YUYV422 = 1,
    #[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
    PIX_FMT_UYVY422 = 2,
    #[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    PIX_FMT_YUV422P = 3,
    #[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
    PIX_FMT_YUV444P = 4,
    #[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
    PIX_FMT_YUV410P = 5,
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
    PIX_FMT_YUV411P = 6,
    #[doc = "<\t   Y\t    ,  8bpp"]
    PIX_FMT_GRAY8 = 7,
    #[doc = "<\t   Y\t    ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
    PIX_FMT_MONOWHITE = 8,
    #[doc = "<\t   Y\t    ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
    PIX_FMT_MONOBLACK = 9,
    #[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    PIX_FMT_NV12 = 10,
    #[doc = "< as above, but U and V bytes are swapped"]
    PIX_FMT_NV21 = 11,
    #[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
    PIX_FMT_RGB24 = 12,
    #[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
    PIX_FMT_BGR24 = 13,
    #[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
    PIX_FMT_ARGB = 14,
    #[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
    PIX_FMT_RGBA = 15,
    #[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
    PIX_FMT_ABGR = 16,
    #[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
    PIX_FMT_BGRA = 17,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)\t  5R 6G 5B(lsb), big-endian"]
    PIX_FMT_RGB565BE = 18,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)\t  5R 6G 5B(lsb), little-endian"]
    PIX_FMT_RGB565LE = 19,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0"]
    PIX_FMT_RGB555BE = 20,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0"]
    PIX_FMT_RGB555LE = 21,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)\t 5B 6G 5R(lsb), big-endian"]
    PIX_FMT_BGR565BE = 22,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)\t 5B 6G 5R(lsb), little-endian"]
    PIX_FMT_BGR565LE = 23,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1"]
    PIX_FMT_BGR555BE = 24,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1"]
    PIX_FMT_BGR555LE = 25,
    #[doc = "< packed RGB 8:8:8, 32bpp, 0RGB0RGB..."]
    PIX_FMT_0RGB = 26,
    #[doc = "< packed RGB 8:8:8, 32bpp, RGB0RGB0..."]
    PIX_FMT_RGB0 = 27,
    #[doc = "< packed BGR 8:8:8, 32bpp, 0BGR0BGR..."]
    PIX_FMT_0BGR = 28,
    #[doc = "< packed BGR 8:8:8, 32bpp, BGR0BGR0..."]
    PIX_FMT_BGR0 = 29,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
    PIX_FMT_BAYER_BGGR8 = 30,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
    PIX_FMT_BAYER_RGGB8 = 31,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
    PIX_FMT_BAYER_GBRG8 = 32,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
    PIX_FMT_BAYER_GRBG8 = 33,
    PIX_FMT_RAW = 34,
    PIX_FMT_HSV = 35,
    #[doc = "< number of pixel formats."]
    PIX_FMT_NB = 36,
}
#[doc = " IMP点坐标信息."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPPoint {
    #[doc = "<横坐标"]
    pub x: libc::c_int,
    #[doc = "<纵坐标"]
    pub y: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPPoint"][::core::mem::size_of::<IMPPoint>() - 8usize];
    ["Alignment of IMPPoint"][::core::mem::align_of::<IMPPoint>() - 4usize];
    ["Offset of field: IMPPoint::x"][::core::mem::offset_of!(IMPPoint, x) - 0usize];
    ["Offset of field: IMPPoint::y"][::core::mem::offset_of!(IMPPoint, y) - 4usize];
};
#[doc = " IMP 矩形区域信息.\n\n 如下图所示，当p0(100,100)作为起始点，要使width和height为100时，则p1为(199,199)\n width = abs(p1.x-p0.x)+1   height = abs(p1.y-p0.y)+1  点数等于距离+1\n p0(100,100) _____100______\n            |              |\n            |              |\n         100|              |\n            |              |\n            |______________|\n                           p1(199,199)\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPRect {
    #[doc = "<左上角点坐标信息"]
    pub p0: IMPPoint,
    #[doc = "<右下角点坐标信息"]
    pub p1: IMPPoint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPRect"][::core::mem::size_of::<IMPRect>() - 16usize];
    ["Alignment of IMPRect"][::core::mem::align_of::<IMPRect>() - 4usize];
    ["Offset of field: IMPRect::p0"][::core::mem::offset_of!(IMPRect, p0) - 0usize];
    ["Offset of field: IMPRect::p1"][::core::mem::offset_of!(IMPRect, p1) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPLine {
    #[doc = "<横线：直线的左端点 竖线：直线的右端点"]
    pub p0: IMPPoint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPLine"][::core::mem::size_of::<IMPLine>() - 8usize];
    ["Alignment of IMPLine"][::core::mem::align_of::<IMPLine>() - 4usize];
    ["Offset of field: IMPLine::p0"][::core::mem::offset_of!(IMPLine, p0) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPIVSInterface {
    #[doc = "< 输入参数"]
    pub param: *mut libc::c_void,
    #[doc = "< 参数空间大小"]
    pub paramSize: libc::c_int,
    #[doc = "< 算法需要数据格式"]
    pub pixfmt: IMPPixelFormat,
    #[doc = "< 初始化函数"]
    pub init:
        ::core::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface) -> libc::c_int>,
    #[doc = "< 注销函数"]
    pub exit: ::core::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface)>,
    #[doc = "< 预处理函数，不对传入此函数的frame额外加锁，故无需free frame，返回值：>=0 正确，<0：错误"]
    pub preProcessSync: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, frame: *mut IMPFrameInfo) -> libc::c_int,
    >,
    #[doc = "< 处理函数, SDK IVS 模块对传入此函数的frame 额外加了锁，故此函数必须在该frame使用完毕后尽快使用free_data函数解锁; 此函数是必须实现的函数,算法结果由此函数产生;返回值:0->实际检测正常返回,1->跳帧检测正常返回,-1->错误"]
    pub processAsync: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, frame: *mut IMPFrameInfo) -> libc::c_int,
    >,
    #[doc = "< 获取结果资源"]
    pub getResult: ::core::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            result: *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    #[doc = "< 释放结果资源"]
    pub releaseResult: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, result: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = "< 获得算法参数"]
    pub getParam: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, param: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = "< 设置算法参数"]
    pub setParam: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, param: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = "< 释放由外部通过processAsync输入给算法后被缓存的所有frame"]
    pub flushFrame:
        ::core::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface) -> libc::c_int>,
    #[doc = "< 私有变量"]
    pub priv_: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPIVSInterface"][::core::mem::size_of::<IMPIVSInterface>() - 52usize];
    ["Alignment of IMPIVSInterface"][::core::mem::align_of::<IMPIVSInterface>() - 4usize];
    ["Offset of field: IMPIVSInterface::param"]
        [::core::mem::offset_of!(IMPIVSInterface, param) - 0usize];
    ["Offset of field: IMPIVSInterface::paramSize"]
        [::core::mem::offset_of!(IMPIVSInterface, paramSize) - 4usize];
    ["Offset of field: IMPIVSInterface::pixfmt"]
        [::core::mem::offset_of!(IMPIVSInterface, pixfmt) - 8usize];
    ["Offset of field: IMPIVSInterface::init"]
        [::core::mem::offset_of!(IMPIVSInterface, init) - 12usize];
    ["Offset of field: IMPIVSInterface::exit"]
        [::core::mem::offset_of!(IMPIVSInterface, exit) - 16usize];
    ["Offset of field: IMPIVSInterface::preProcessSync"]
        [::core::mem::offset_of!(IMPIVSInterface, preProcessSync) - 20usize];
    ["Offset of field: IMPIVSInterface::processAsync"]
        [::core::mem::offset_of!(IMPIVSInterface, processAsync) - 24usize];
    ["Offset of field: IMPIVSInterface::getResult"]
        [::core::mem::offset_of!(IMPIVSInterface, getResult) - 28usize];
    ["Offset of field: IMPIVSInterface::releaseResult"]
        [::core::mem::offset_of!(IMPIVSInterface, releaseResult) - 32usize];
    ["Offset of field: IMPIVSInterface::getParam"]
        [::core::mem::offset_of!(IMPIVSInterface, getParam) - 36usize];
    ["Offset of field: IMPIVSInterface::setParam"]
        [::core::mem::offset_of!(IMPIVSInterface, setParam) - 40usize];
    ["Offset of field: IMPIVSInterface::flushFrame"]
        [::core::mem::offset_of!(IMPIVSInterface, flushFrame) - 44usize];
    ["Offset of field: IMPIVSInterface::priv_"]
        [::core::mem::offset_of!(IMPIVSInterface, priv_) - 48usize];
};
impl Default for IMPIVSInterface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " 创建通道组\n\n @fn int IMP_IVS_CreateGroup(int GrpNum);\n\n @param[in] GrpNum IVS功能对应的通道组号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 无\n\n @attention 无"]
    pub fn IMP_IVS_CreateGroup(GrpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 销毁通道组\n\n @fn int IMP_IVS_DestroyGroup(int GrpNum);\n\n @param[in] GrpNum IVS功能对应的通道组号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 无\n\n @attention 无"]
    pub fn IMP_IVS_DestroyGroup(GrpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 创建IVS功能对应的通道\n\n @fn int IMP_IVS_CreateChn(int ChnNum, IMPIVSInterface *handler);\n\n @param[in] ChnNum 通道号\n\n @param[in] handler IVS功能句柄\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 无.\n\n @attention 无"]
    pub fn IMP_IVS_CreateChn(ChnNum: libc::c_int, handler: *mut IMPIVSInterface) -> libc::c_int;
}
extern "C" {
    #[doc = " 销毁IVS功能句柄对应的通道\n\n @fn int IMP_IVS_DestroyChn(int ChnNum);\n\n @param[in] ChnNum 通道号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 无\n\n @attention 无"]
    pub fn IMP_IVS_DestroyChn(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 注册通道到通道组\n\n @fn int IMP_IVS_RegisterChn(int GrpNum, int ChnNum);\n\n @param[in] GrpNum IVS功能对应的通道组号\n @param[in] ChnNum IVS功能对应的通道号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 将号为Chnnum的通道注册到号为Grpnum通道组中\n\n @attention 无"]
    pub fn IMP_IVS_RegisterChn(GrpNum: libc::c_int, ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 从通道组注消通道\n\n @fn int IMP_IVS_UnRegisterChn(int ChnNum);\n\n @param[in] ChnNum IVS功能对应的通道号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 从号为Grpnum的通道组中注销号为Chnnum通道\n\n @attention 无"]
    pub fn IMP_IVS_UnRegisterChn(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 通道开始接收图像\n\n @fn int IMP_IVS_StartRecvPic(int ChnNum);\n\n @param[in] ChnNum 通道号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 通道号为Chnnum的IVS功能通道开始接收图像做智能分析\n\n @attention 无"]
    pub fn IMP_IVS_StartRecvPic(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 通道停止接收图像\n\n @fn int IMP_IVS_StopRecvPic(int ChnNum);\n\n @param[in] ChnNum 通道号\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 通道号为Chnnum的IVS功能通道停止接收图像，暂停智能分析\n\n @attention 无"]
    pub fn IMP_IVS_StopRecvPic(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 阻塞判断是否可以获得IVS功能已计算出的智能分析结果\n\n @fn int IMP_IVS_PollingResult(int ChnNum, int timeoutMs);\n\n @param[in] ChnNum IVS功能对应的通道号\n @param[in] timeout 最大等待时间，单位ms; IMP_IVS_DEFAULT_TIMEOUTMS:库内部默认的等待时间,0:不等待,>0:用户设定的等待时间\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 只有该通道创建时参数IMPIVSInterface结构体中ProcessAsync函数成员返回0时，即实际检测正常返回时，此Polling函数才返回成功\n\n @attention 无"]
    pub fn IMP_IVS_PollingResult(ChnNum: libc::c_int, timeoutMs: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " 获得IVS功能计算出的智能分析结果\n\n @fn int IMP_IVS_GetResult(int ChnNum, void **result);\n\n @param[in] ChnNum IVS功能对应的通道号\n @param[in] result IVS功能对应的通道号输出的结果，返回此通道对应的智能分析算法的结果指针，外部客户无需分配空间。\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 根据不同IVS功能绑定的通道,输出其对应的结果.\n\n @attention 无"]
    pub fn IMP_IVS_GetResult(ChnNum: libc::c_int, result: *mut *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " 释放IVS功能计算出的结果资源\n\n @fn int IMP_IVS_ReleaseResult(int ChnNum, void *result);\n\n @param[in] GrpNum 通道组号\n @param[in] ChnNum IVS功能对应的通道号\n @param[in] result IVS功能对应的通道号输出的结果\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 根据不同IVS功能绑定的通道,释放其输出的结果资源.\n\n @attention 无"]
    pub fn IMP_IVS_ReleaseResult(ChnNum: libc::c_int, result: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " 释放传给Datacallback的参数frame\n\n @fn int IMP_IVS_ReleaseData(void *vaddr);\n\n @param[in] vaddr 释放的空间虚拟地址\n\n @retval 0 成功\n @retval -1 失败\n\n @remark 必须使用此函数释放传给Datacallback的frame参数，否则肯定造成死锁。\n @remark 此接口仅供算法提供商使用，算法使用客户无须关注。\n\n @attention 无"]
    pub fn IMP_IVS_ReleaseData(vaddr: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " 获取通道算法参数\n\n @fn int IMP_IVS_GetParam(int chnNum, void *param);\n\n @param[in] ChnNum IVS功能对应的通道号\n @param[in] param 算法参数虚拟地址指针\n\n @retval 0 成功\n @retval -1 失败\n\n @attention 无"]
    pub fn IMP_IVS_GetParam(chnNum: libc::c_int, param: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " 设置通道算法参数\n\n @fn int IMP_IVS_SetParam(int chnNum, void *param);\n\n @param[in] ChnNum IVS功能对应的通道号\n @param[in] param 算法参数虚拟地址指针\n\n @retval 0 成功\n @retval -1 失败\n\n @attention 无"]
    pub fn IMP_IVS_SetParam(chnNum: libc::c_int, param: *mut libc::c_void) -> libc::c_int;
}
#[doc = " 移动侦测算法的输入结构体"]
#[repr(C)]
#[derive(Debug)]
pub struct IMP_IVS_MoveParam {
    #[doc = "< 移动侦测的灵敏度, 对正常摄像机范围是0-4，对全景摄像机范围是0-8"]
    pub sense: [libc::c_int; 52usize],
    pub skipFrameCnt: libc::c_int,
    #[doc = "< 帧尺寸信息,只需要配置width和height"]
    pub frameInfo: IMPFrameInfo,
    pub roiRect: [IMPRect; 52usize],
    pub roiRectCnt: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_MoveParam"][::core::mem::size_of::<IMP_IVS_MoveParam>() - 1112usize];
    ["Alignment of IMP_IVS_MoveParam"][::core::mem::align_of::<IMP_IVS_MoveParam>() - 8usize];
    ["Offset of field: IMP_IVS_MoveParam::sense"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, sense) - 0usize];
    ["Offset of field: IMP_IVS_MoveParam::skipFrameCnt"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, skipFrameCnt) - 208usize];
    ["Offset of field: IMP_IVS_MoveParam::frameInfo"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, frameInfo) - 216usize];
    ["Offset of field: IMP_IVS_MoveParam::roiRect"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, roiRect) - 272usize];
    ["Offset of field: IMP_IVS_MoveParam::roiRectCnt"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, roiRectCnt) - 1104usize];
};
impl Default for IMP_IVS_MoveParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMP_IVS_MoveOutput {
    pub retRoi: [libc::c_int; 52usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_MoveOutput"][::core::mem::size_of::<IMP_IVS_MoveOutput>() - 208usize];
    ["Alignment of IMP_IVS_MoveOutput"][::core::mem::align_of::<IMP_IVS_MoveOutput>() - 4usize];
    ["Offset of field: IMP_IVS_MoveOutput::retRoi"]
        [::core::mem::offset_of!(IMP_IVS_MoveOutput, retRoi) - 0usize];
};
impl Default for IMP_IVS_MoveOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " 创建移动侦测接口资源\n\n @fn IMPIVSInterface *IMP_IVS_CreateMoveInterface(IMP_IVS_MoveParam *param);\n\n @param[in] param 移动侦测算法的输入结构体参数\n\n @retval 非NULL 成功,返回移动侦测算法接口指针句柄\n @retval NULL 失败\n\n @attention 无"]
    pub fn IMP_IVS_CreateMoveInterface(param: *mut IMP_IVS_MoveParam) -> *mut IMPIVSInterface;
}
extern "C" {
    #[doc = " 销毁移动侦测接口资源\n\n @fn void IMP_IVS_DestroyMoveInterface(IMPIVSInterface *moveInterface);\n\n @param[in] moveInterface 移动侦测算法接口指针句柄\n\n @retval 无返回值\n\n @attention 无"]
    pub fn IMP_IVS_DestroyMoveInterface(moveInterface: *mut IMPIVSInterface);
}
#[doc = " IMP系统版本号定义."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPVersion {
    #[doc = "< IMP系统版本号"]
    pub aVersion: [libc::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPVersion"][::core::mem::size_of::<IMPVersion>() - 64usize];
    ["Alignment of IMPVersion"][::core::mem::align_of::<IMPVersion>() - 1usize];
    ["Offset of field: IMPVersion::aVersion"]
        [::core::mem::offset_of!(IMPVersion, aVersion) - 0usize];
};
impl Default for IMPVersion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_System_Init(void)\n\n IMP系统初始化.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 此API调用后会初始化基础的数据结构，但不会初始化硬件单元.\n\n @attention 在IMP的任何操作之前必须先调用此接口进行初始化."]
    pub fn IMP_System_Init() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_Exit(void)\n\n IMP系统去初始化.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 此函数调用后会释放IMP所有的内存以及句柄，并关闭硬件单元.\n\n @attention 在调用此API后，若要再次使用IMP则需重新进行IMP系统初始化."]
    pub fn IMP_System_Exit() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int64_t IMP_System_GetTimeStamp(void)\n\n 获得IMP系统的时间戳，单位为微秒。\n\n @param 无。\n\n @retval 时间(usec)\n\n @remark 系统初始化后时间戳自动被初始化。系统去初始化后时间戳失效。\n\n @attention 无。"]
    pub fn IMP_System_GetTimeStamp() -> i64;
}
extern "C" {
    #[doc = " @fn int IMP_System_RebaseTimeStamp(int64_t basets)\n\n 设置IMP系统的时间戳，单位为微秒。\n\n @param[in] basets 基础时间。\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_System_RebaseTimeStamp(basets: i64) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn uint32_t IMP_System_ReadReg32(uint32_t u32Addr)\n\n 读取32位寄存器的值。\n\n @param[in] regAddr 寄存器的物理地址。\n\n @retval 寄存器的值（32位）\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_System_ReadReg32(regAddr: u32) -> u32;
}
extern "C" {
    #[doc = " @fn void IMP_System_WriteReg32(uint32_t regAddr, uint32_t value)\n\n 向32位寄存器中写值。\n\n @param[in] regAddr 寄存器的物理地址。\n @param[in] value 要写入的值。\n\n @retval 无\n\n @remark 无。\n\n @attention 在不明确寄存器的含义之前请谨慎调用此API，否则可能会导致系统错误。"]
    pub fn IMP_System_WriteReg32(regAddr: u32, value: u32);
}
extern "C" {
    #[doc = " @fn int IMP_System_GetVersion(IMPVersion *pstVersion)\n\n 获取IMP系统版本号.\n\n @param[out] pstVersion IMP系统版本号结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 无.\n\n @attention 无."]
    pub fn IMP_System_GetVersion(pstVersion: *mut IMPVersion) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn const char* IMP_System_GetCPUInfo(void)\n\n 获取CPU型号信息.\n\n @param 无.\n\n @retval CPU型号字符串.\n\n @remark 返回值是CPU型号类型的字符串,例如对于T10来说,有\"T10\"及\"T10-Lite\".\n\n @attention 无."]
    pub fn IMP_System_GetCPUInfo() -> *const libc::c_char;
}
extern "C" {
    #[doc = " @fn int IMP_System_Bind(IMPCell *srcCell, IMPCell *dstCell)\n\n 绑定源Cell和目的Cell.\n\n @param[in] srcCell 源Cell指针.\n @param[in] dstCell 目的Cell指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 根据Device、Group和Output的概念，每个Device可能有多个Group，每个Group可能有多个Output，\\n\n Group作为Device的输入接口，而Output作为Device的输出接口.因此绑定实际上是将输出Device的某 \\n\n 个Output连接到输入Device的某个Group上.\n @remark 绑定关系成功后，源Cell(Output)产生的数据会自动传送到目的Cell(Group).\n\n @attention 无。"]
    pub fn IMP_System_Bind(srcCell: *mut IMPCell, dstCell: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_UnBind(IMPCell *srcCell, IMPCell *dstCell)\n\n 解除源Cell和目的Cell的绑定.\n\n @param[in] srcCell 源Cell指针.\n @param[in] dstCell 目的Cell指针.\n\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 无.\n\n @attention 无。"]
    pub fn IMP_System_UnBind(srcCell: *mut IMPCell, dstCell: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_GetBindbyDest(IMPCell *dstCell, IMPCell *srcCell)\n\n 获取绑定在目的Cell的源Cell信息.\n\n @param[in] dstCell 目的Cell指针.\n @param[out] srcCell 源Cell指针.\n\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remark 无.\n\n @attention 无。"]
    pub fn IMP_System_GetBindbyDest(dstCell: *mut IMPCell, srcCell: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_System_MemPoolRequest(int poolId, size_t size, const char *name);\n\n 在Rmem上申请mempool\n\n @param[in] poolId     申请的poolID.\n @param[in] size       申请大小.\n @param[in] name       pool名称.\n\n @retval    0          成功.\n @retval    非0        失败.\n\n @remarks\n 视频内存池主要向媒体业务提供大块物理连续内存管理功能,负责内存的分配和回收,\n 充分发挥内存缓存池的作用,让物理内存资源在各个媒体处理模块中合理使用.\n 视频内存池建立在原保留内存RMEM（不由内核建立页表）的基础上进行大块内存管理,\n 每申请一个内存池都是物理连续的内存，之后在该内存池上申请内存同样是申请物理连续的内存.\n 若使用内存池，必须在系统初始化之前配置内存池大小，根据业务的不同,\n 内存池申请的大小和数量不同。\n\n @attention 无."]
    pub fn IMP_System_MemPoolRequest(
        poolId: libc::c_int,
        size: usize,
        name: *mut libc::c_char,
    ) -> libc::c_int;
}
pub const IMP_LOG_LEVEL_UNKNOWN: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_UNKNOWN;
pub const IMP_LOG_LEVEL_RESERVED: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_RESERVED;
pub const IMP_LOG_LEVEL_VERBOSE: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_VERBOSE;
pub const IMP_LOG_LEVEL_DEBUG: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_DEBUG;
pub const IMP_LOG_LEVEL_INFO: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_INFO;
pub const IMP_LOG_LEVEL_WARN: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_WARN;
pub const IMP_LOG_LEVEL_ERROR: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_ERROR;
pub const IMP_LOG_LEVEL_FATAL: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_FATAL;
pub const IMP_LOG_LEVEL_SILENT: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_SILENT;
#[repr(u32)]
#[doc = " define log level"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_11 {
    IMP_LOG_LEVEL_UNKNOWN = 0,
    IMP_LOG_LEVEL_RESERVED = 1,
    IMP_LOG_LEVEL_VERBOSE = 2,
    IMP_LOG_LEVEL_DEBUG = 3,
    IMP_LOG_LEVEL_INFO = 4,
    IMP_LOG_LEVEL_WARN = 5,
    IMP_LOG_LEVEL_ERROR = 6,
    IMP_LOG_LEVEL_FATAL = 7,
    IMP_LOG_LEVEL_SILENT = 8,
}
extern "C" {
    #[doc = " used internal"]
    pub fn imp_log_fun(
        le: libc::c_int,
        op: libc::c_int,
        out: libc::c_int,
        tag: *const libc::c_char,
        file: *const libc::c_char,
        line: libc::c_int,
        func: *const libc::c_char,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    #[doc = " 设置打印选项\n\n @fn void IMP_Log_Set_Option(int op);\n\n @param[in] op 设置打印选项\n"]
    pub fn IMP_Log_Set_Option(op: libc::c_int);
}
extern "C" {
    #[doc = " 获取打印选项\n\n @fn int IMP_Log_Get_Option(void );\n\n @retval 返回系统中的打印选项\n"]
    pub fn IMP_Log_Get_Option() -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(__s: *mut libc::c_void, __c: libc::c_int, __n: libc::c_uint)
        -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __l: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: libc::c_uint) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: locale_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: libc::c_uint);
}
extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> *mut libc::c_char;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_int;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [libc::c_char; 16usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sem_t"][::core::mem::size_of::<sem_t>() - 16usize];
    ["Alignment of sem_t"][::core::mem::align_of::<sem_t>() - 4usize];
    ["Offset of field: sem_t::__size"][::core::mem::offset_of!(sem_t, __size) - 0usize];
    ["Offset of field: sem_t::__align"][::core::mem::offset_of!(sem_t, __align) - 0usize];
};
impl Default for sem_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: libc::c_int,
        __value: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_open(__name: *const libc::c_char, __oflag: libc::c_int, ...) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_getvalue(__sem: *mut sem_t, __sval: *mut libc::c_int) -> libc::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> libc::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> libc::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: f64, __y: f64) -> libc::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub static mut signgam: libc::c_int;
}
pub type wchar_t = libc::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::core::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::core::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::core::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::core::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::core::mem::size_of::<ldiv_t>() - 8usize];
    ["Alignment of ldiv_t"][::core::mem::align_of::<ldiv_t>() - 4usize];
    ["Offset of field: ldiv_t::quot"][::core::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::core::mem::offset_of!(ldiv_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::core::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::core::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::core::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::core::mem::offset_of!(lldiv_t, rem) - 8usize];
};
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::core::mem::size_of::<random_data>() - 28usize];
    ["Alignment of random_data"][::core::mem::align_of::<random_data>() - 4usize];
    ["Offset of field: random_data::fptr"][::core::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::core::mem::offset_of!(random_data, rptr) - 4usize];
    ["Offset of field: random_data::state"][::core::mem::offset_of!(random_data, state) - 8usize];
    ["Offset of field: random_data::rand_type"]
        [::core::mem::offset_of!(random_data, rand_type) - 12usize];
    ["Offset of field: random_data::rand_deg"]
        [::core::mem::offset_of!(random_data, rand_deg) - 16usize];
    ["Offset of field: random_data::rand_sep"]
        [::core::mem::offset_of!(random_data, rand_sep) - 20usize];
    ["Offset of field: random_data::end_ptr"]
        [::core::mem::offset_of!(random_data, end_ptr) - 24usize];
};
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::core::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::core::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::core::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::core::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::core::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::core::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::core::mem::offset_of!(drand48_data, __a) - 16usize];
};
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn malloc(__size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: libc::c_uint, __size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut libc::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn alloca(__size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: usize,
        __size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: libc::c_int, __arg: *mut libc::c_void),
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut libc::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __buf: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut libc::c_char,
        __tokens: *const *mut libc::c_char,
        __valuep: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int) -> libc::c_int;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __type: libc::c_int,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;
}
extern "C" {
    pub fn close(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn alarm(__seconds: libc::c_uint) -> libc::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> libc::c_int;
}
extern "C" {
    pub fn pause() -> libc::c_int;
}
extern "C" {
    pub fn chown(__file: *const libc::c_char, __owner: __uid_t, __group: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn fchown(__fd: libc::c_int, __owner: __uid_t, __group: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn lchown(__file: *const libc::c_char, __owner: __uid_t, __group: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn chdir(__path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn fchdir(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut libc::c_char, __size: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn dup(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut libc::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const libc::c_char,
        __argv: *const *mut libc::c_char,
        __envp: *const *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: libc::c_int,
        __argv: *const *mut libc::c_char,
        __envp: *const *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn execv(__path: *const libc::c_char, __argv: *const *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn execle(__path: *const libc::c_char, __arg: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn execl(__path: *const libc::c_char, __arg: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn execvp(__file: *const libc::c_char, __argv: *const *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn execlp(__file: *const libc::c_char, __arg: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn nice(__inc: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _exit(__status: libc::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_LINK_MAX;
pub const _PC_MAX_CANON: _bindgen_ty_13 = _bindgen_ty_13::_PC_MAX_CANON;
pub const _PC_MAX_INPUT: _bindgen_ty_13 = _bindgen_ty_13::_PC_MAX_INPUT;
pub const _PC_NAME_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_NAME_MAX;
pub const _PC_PATH_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_PATH_MAX;
pub const _PC_PIPE_BUF: _bindgen_ty_13 = _bindgen_ty_13::_PC_PIPE_BUF;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_13 = _bindgen_ty_13::_PC_CHOWN_RESTRICTED;
pub const _PC_NO_TRUNC: _bindgen_ty_13 = _bindgen_ty_13::_PC_NO_TRUNC;
pub const _PC_VDISABLE: _bindgen_ty_13 = _bindgen_ty_13::_PC_VDISABLE;
pub const _PC_SYNC_IO: _bindgen_ty_13 = _bindgen_ty_13::_PC_SYNC_IO;
pub const _PC_ASYNC_IO: _bindgen_ty_13 = _bindgen_ty_13::_PC_ASYNC_IO;
pub const _PC_PRIO_IO: _bindgen_ty_13 = _bindgen_ty_13::_PC_PRIO_IO;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_13 = _bindgen_ty_13::_PC_SOCK_MAXBUF;
pub const _PC_FILESIZEBITS: _bindgen_ty_13 = _bindgen_ty_13::_PC_FILESIZEBITS;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_INCR_XFER_SIZE;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_MAX_XFER_SIZE;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_MIN_XFER_SIZE;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_XFER_ALIGN;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_13 = _bindgen_ty_13::_PC_ALLOC_SIZE_MIN;
pub const _PC_SYMLINK_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_SYMLINK_MAX;
pub const _PC_2_SYMLINKS: _bindgen_ty_13 = _bindgen_ty_13::_PC_2_SYMLINKS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_13 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_ARG_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_ARG_MAX;
pub const _SC_CHILD_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHILD_MAX;
pub const _SC_CLK_TCK: _bindgen_ty_14 = _bindgen_ty_14::_SC_CLK_TCK;
pub const _SC_NGROUPS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NGROUPS_MAX;
pub const _SC_OPEN_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_OPEN_MAX;
pub const _SC_STREAM_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_STREAM_MAX;
pub const _SC_TZNAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TZNAME_MAX;
pub const _SC_JOB_CONTROL: _bindgen_ty_14 = _bindgen_ty_14::_SC_JOB_CONTROL;
pub const _SC_SAVED_IDS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SAVED_IDS;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_14 = _bindgen_ty_14::_SC_REALTIME_SIGNALS;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_14 = _bindgen_ty_14::_SC_PRIORITY_SCHEDULING;
pub const _SC_TIMERS: _bindgen_ty_14 = _bindgen_ty_14::_SC_TIMERS;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_ASYNCHRONOUS_IO;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_PRIORITIZED_IO;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYNCHRONIZED_IO;
pub const _SC_FSYNC: _bindgen_ty_14 = _bindgen_ty_14::_SC_FSYNC;
pub const _SC_MAPPED_FILES: _bindgen_ty_14 = _bindgen_ty_14::_SC_MAPPED_FILES;
pub const _SC_MEMLOCK: _bindgen_ty_14 = _bindgen_ty_14::_SC_MEMLOCK;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_14 = _bindgen_ty_14::_SC_MEMLOCK_RANGE;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_14 = _bindgen_ty_14::_SC_MEMORY_PROTECTION;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_14 = _bindgen_ty_14::_SC_MESSAGE_PASSING;
pub const _SC_SEMAPHORES: _bindgen_ty_14 = _bindgen_ty_14::_SC_SEMAPHORES;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHARED_MEMORY_OBJECTS;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_AIO_LISTIO_MAX;
pub const _SC_AIO_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_AIO_MAX;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_AIO_PRIO_DELTA_MAX;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_DELAYTIMER_MAX;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_MQ_OPEN_MAX;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_MQ_PRIO_MAX;
pub const _SC_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_VERSION;
pub const _SC_PAGESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_PAGESIZE;
pub const _SC_RTSIG_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_RTSIG_MAX;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SEM_NSEMS_MAX;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SEM_VALUE_MAX;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SIGQUEUE_MAX;
pub const _SC_TIMER_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TIMER_MAX;
pub const _SC_BC_BASE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_BASE_MAX;
pub const _SC_BC_DIM_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_DIM_MAX;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_SCALE_MAX;
pub const _SC_BC_STRING_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_STRING_MAX;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_COLL_WEIGHTS_MAX;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_EQUIV_CLASS_MAX;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_EXPR_NEST_MAX;
pub const _SC_LINE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_LINE_MAX;
pub const _SC_RE_DUP_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_RE_DUP_MAX;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHARCLASS_NAME_MAX;
pub const _SC_2_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_VERSION;
pub const _SC_2_C_BIND: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_C_BIND;
pub const _SC_2_C_DEV: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_C_DEV;
pub const _SC_2_FORT_DEV: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_FORT_DEV;
pub const _SC_2_FORT_RUN: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_FORT_RUN;
pub const _SC_2_SW_DEV: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_SW_DEV;
pub const _SC_2_LOCALEDEF: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_LOCALEDEF;
pub const _SC_PII: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII;
pub const _SC_PII_XTI: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_XTI;
pub const _SC_PII_SOCKET: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_SOCKET;
pub const _SC_PII_INTERNET: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_INTERNET;
pub const _SC_PII_OSI: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI;
pub const _SC_POLL: _bindgen_ty_14 = _bindgen_ty_14::_SC_POLL;
pub const _SC_SELECT: _bindgen_ty_14 = _bindgen_ty_14::_SC_SELECT;
pub const _SC_UIO_MAXIOV: _bindgen_ty_14 = _bindgen_ty_14::_SC_UIO_MAXIOV;
pub const _SC_IOV_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_UIO_MAXIOV;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_INTERNET_STREAM;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_INTERNET_DGRAM;
pub const _SC_PII_OSI_COTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI_COTS;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI_CLTS;
pub const _SC_PII_OSI_M: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI_M;
pub const _SC_T_IOV_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_T_IOV_MAX;
pub const _SC_THREADS: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREADS;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_SAFE_FUNCTIONS;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_GETGR_R_SIZE_MAX;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_GETPW_R_SIZE_MAX;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_LOGIN_NAME_MAX;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TTY_NAME_MAX;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_DESTRUCTOR_ITERATIONS;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_KEYS_MAX;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_STACK_MIN;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_THREADS_MAX;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_ATTR_STACKADDR;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_ATTR_STACKSIZE;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_PRIORITY_SCHEDULING;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_PRIO_INHERIT;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_PRIO_PROTECT;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_PROCESS_SHARED;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_14 = _bindgen_ty_14::_SC_NPROCESSORS_CONF;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_14 = _bindgen_ty_14::_SC_NPROCESSORS_ONLN;
pub const _SC_PHYS_PAGES: _bindgen_ty_14 = _bindgen_ty_14::_SC_PHYS_PAGES;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_14 = _bindgen_ty_14::_SC_AVPHYS_PAGES;
pub const _SC_ATEXIT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_ATEXIT_MAX;
pub const _SC_PASS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_PASS_MAX;
pub const _SC_XOPEN_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_VERSION;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XCU_VERSION;
pub const _SC_XOPEN_UNIX: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_UNIX;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_CRYPT;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_ENH_I18N;
pub const _SC_XOPEN_SHM: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_SHM;
pub const _SC_2_CHAR_TERM: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_CHAR_TERM;
pub const _SC_2_C_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_C_VERSION;
pub const _SC_2_UPE: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_UPE;
pub const _SC_XOPEN_XPG2: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XPG2;
pub const _SC_XOPEN_XPG3: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XPG3;
pub const _SC_XOPEN_XPG4: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XPG4;
pub const _SC_CHAR_BIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHAR_BIT;
pub const _SC_CHAR_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHAR_MAX;
pub const _SC_CHAR_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHAR_MIN;
pub const _SC_INT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_INT_MAX;
pub const _SC_INT_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_INT_MIN;
pub const _SC_LONG_BIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_LONG_BIT;
pub const _SC_WORD_BIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_WORD_BIT;
pub const _SC_MB_LEN_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_MB_LEN_MAX;
pub const _SC_NZERO: _bindgen_ty_14 = _bindgen_ty_14::_SC_NZERO;
pub const _SC_SSIZE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SSIZE_MAX;
pub const _SC_SCHAR_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SCHAR_MAX;
pub const _SC_SCHAR_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_SCHAR_MIN;
pub const _SC_SHRT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHRT_MAX;
pub const _SC_SHRT_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHRT_MIN;
pub const _SC_UCHAR_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_UCHAR_MAX;
pub const _SC_UINT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_UINT_MAX;
pub const _SC_ULONG_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_ULONG_MAX;
pub const _SC_USHRT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_USHRT_MAX;
pub const _SC_NL_ARGMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_ARGMAX;
pub const _SC_NL_LANGMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_LANGMAX;
pub const _SC_NL_MSGMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_MSGMAX;
pub const _SC_NL_NMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_NMAX;
pub const _SC_NL_SETMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_SETMAX;
pub const _SC_NL_TEXTMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_TEXTMAX;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_ILP32_OFF32;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_ILP32_OFFBIG;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_LP64_OFF64;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_LPBIG_OFFBIG;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_LEGACY;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_REALTIME;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_REALTIME_THREADS;
pub const _SC_ADVISORY_INFO: _bindgen_ty_14 = _bindgen_ty_14::_SC_ADVISORY_INFO;
pub const _SC_BARRIERS: _bindgen_ty_14 = _bindgen_ty_14::_SC_BARRIERS;
pub const _SC_BASE: _bindgen_ty_14 = _bindgen_ty_14::_SC_BASE;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_14 = _bindgen_ty_14::_SC_C_LANG_SUPPORT;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_C_LANG_SUPPORT_R;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_14 = _bindgen_ty_14::_SC_CLOCK_SELECTION;
pub const _SC_CPUTIME: _bindgen_ty_14 = _bindgen_ty_14::_SC_CPUTIME;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_CPUTIME;
pub const _SC_DEVICE_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_DEVICE_IO;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_14 = _bindgen_ty_14::_SC_DEVICE_SPECIFIC;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_DEVICE_SPECIFIC_R;
pub const _SC_FD_MGMT: _bindgen_ty_14 = _bindgen_ty_14::_SC_FD_MGMT;
pub const _SC_FIFO: _bindgen_ty_14 = _bindgen_ty_14::_SC_FIFO;
pub const _SC_PIPE: _bindgen_ty_14 = _bindgen_ty_14::_SC_PIPE;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_14 = _bindgen_ty_14::_SC_FILE_ATTRIBUTES;
pub const _SC_FILE_LOCKING: _bindgen_ty_14 = _bindgen_ty_14::_SC_FILE_LOCKING;
pub const _SC_FILE_SYSTEM: _bindgen_ty_14 = _bindgen_ty_14::_SC_FILE_SYSTEM;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_14 = _bindgen_ty_14::_SC_MONOTONIC_CLOCK;
pub const _SC_MULTI_PROCESS: _bindgen_ty_14 = _bindgen_ty_14::_SC_MULTI_PROCESS;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SINGLE_PROCESS;
pub const _SC_NETWORKING: _bindgen_ty_14 = _bindgen_ty_14::_SC_NETWORKING;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_14 = _bindgen_ty_14::_SC_READER_WRITER_LOCKS;
pub const _SC_SPIN_LOCKS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SPIN_LOCKS;
pub const _SC_REGEXP: _bindgen_ty_14 = _bindgen_ty_14::_SC_REGEXP;
pub const _SC_REGEX_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_REGEX_VERSION;
pub const _SC_SHELL: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHELL;
pub const _SC_SIGNALS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SIGNALS;
pub const _SC_SPAWN: _bindgen_ty_14 = _bindgen_ty_14::_SC_SPAWN;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_14 = _bindgen_ty_14::_SC_SPORADIC_SERVER;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_SPORADIC_SERVER;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYSTEM_DATABASE;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYSTEM_DATABASE_R;
pub const _SC_TIMEOUTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_TIMEOUTS;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_TYPED_MEMORY_OBJECTS;
pub const _SC_USER_GROUPS: _bindgen_ty_14 = _bindgen_ty_14::_SC_USER_GROUPS;
pub const _SC_USER_GROUPS_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_USER_GROUPS_R;
pub const _SC_2_PBS: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_ACCOUNTING;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_LOCATE;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_MESSAGE;
pub const _SC_2_PBS_TRACK: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_TRACK;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYMLOOP_MAX;
pub const _SC_STREAMS: _bindgen_ty_14 = _bindgen_ty_14::_SC_STREAMS;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_CHECKPOINT;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_ILP32_OFF32;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_ILP32_OFFBIG;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_LP64_OFF64;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_LPBIG_OFFBIG;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_HOST_NAME_MAX;
pub const _SC_TRACE: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_EVENT_FILTER;
pub const _SC_TRACE_INHERIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_INHERIT;
pub const _SC_TRACE_LOG: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_LOG;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_ICACHE_SIZE;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_ICACHE_ASSOC;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_ICACHE_LINESIZE;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_DCACHE_SIZE;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_DCACHE_ASSOC;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_DCACHE_LINESIZE;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL2_CACHE_SIZE;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL2_CACHE_ASSOC;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL2_CACHE_LINESIZE;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL3_CACHE_SIZE;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL3_CACHE_ASSOC;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL3_CACHE_LINESIZE;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL4_CACHE_SIZE;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL4_CACHE_ASSOC;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL4_CACHE_LINESIZE;
pub const _SC_IPV6: _bindgen_ty_14 = _bindgen_ty_14::_SC_IPV6;
pub const _SC_RAW_SOCKETS: _bindgen_ty_14 = _bindgen_ty_14::_SC_RAW_SOCKETS;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_ILP32_OFF32;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_ILP32_OFFBIG;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_LP64_OFF64;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_LPBIG_OFFBIG;
pub const _SC_SS_REPL_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SS_REPL_MAX;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_EVENT_NAME_MAX;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_NAME_MAX;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_SYS_MAX;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_USER_EVENT_MAX;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_STREAMS;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_ROBUST_PRIO_INHERIT;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_ROBUST_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_14 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
pub const _CS_PATH: _bindgen_ty_15 = _bindgen_ty_15::_CS_PATH;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_15 = _bindgen_ty_15::_CS_GNU_LIBC_VERSION;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_15 = _bindgen_ty_15::_CS_GNU_LIBPTHREAD_VERSION;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _CS_LFS_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_CFLAGS;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_LDFLAGS;
pub const _CS_LFS_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_LIBS;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_LINTFLAGS;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_CFLAGS;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_LDFLAGS;
pub const _CS_LFS64_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_LIBS;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_CFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_LDFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_LIBS;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_CFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_LDFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_LIBS;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LP64_OFF64_CFLAGS;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LP64_OFF64_LDFLAGS;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LP64_OFF64_LIBS;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LP64_OFF64_LINTFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_CFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_LIBS;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_LIBS;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_LIBS;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_V6_ENV: _bindgen_ty_15 = _bindgen_ty_15::_CS_V6_ENV;
pub const _CS_V7_ENV: _bindgen_ty_15 = _bindgen_ty_15::_CS_V7_ENV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_15 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
extern "C" {
    pub fn pathconf(__path: *const libc::c_char, __name: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: libc::c_int, __name: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn sysconf(__name: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn confstr(__name: libc::c_int, __buf: *mut libc::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn setpgrp() -> libc::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: libc::c_int, __list: *mut __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> libc::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> libc::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> libc::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> libc::c_int;
}
extern "C" {
    pub fn ttyname(__fd: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ttyname_r(__fd: libc::c_int, __buf: *mut libc::c_char, __buflen: usize) -> libc::c_int;
}
extern "C" {
    pub fn isatty(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ttyslot() -> libc::c_int;
}
extern "C" {
    pub fn link(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: libc::c_int,
        __from: *const libc::c_char,
        __tofd: libc::c_int,
        __to: *const libc::c_char,
        __flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn readlink(__path: *const libc::c_char, __buf: *mut libc::c_char, __len: usize) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const libc::c_char,
        __tofd: libc::c_int,
        __to: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: libc::c_int,
        __name: *const libc::c_char,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: libc::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: libc::c_int, __pgrp_id: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut libc::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut libc::c_char, __name_len: usize) -> libc::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub static mut optarg: *mut libc::c_char;
}
extern "C" {
    pub static mut optind: libc::c_int;
}
extern "C" {
    pub static mut opterr: libc::c_int;
}
extern "C" {
    pub static mut optopt: libc::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: libc::c_int,
        ___argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn sethostid(__id: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn vhangup() -> libc::c_int;
}
extern "C" {
    pub fn revoke(__file: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut libc::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn acct(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut libc::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: libc::c_int, __noclose: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn chroot(__path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fsync(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn gethostid() -> libc::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> libc::c_int;
}
extern "C" {
    pub fn getdtablesize() -> libc::c_int;
}
extern "C" {
    pub fn truncate(__file: *const libc::c_char, __length: __off_t) -> libc::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut libc::c_void;
}
extern "C" {
    pub fn syscall(__sysno: libc::c_long, ...) -> libc::c_long;
}
extern "C" {
    pub fn lockf(__fd: libc::c_int, __cmd: libc::c_int, __len: __off_t) -> libc::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn crypt(__key: *const libc::c_char, __salt: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn getentropy(__buffer: *mut libc::c_void, __length: usize) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: libc::c_ulong,
    pub st_pad1: [libc::c_long; 3usize],
    pub st_ino: __ino_t,
    pub st_mode: __mode_t,
    pub st_nlink: __nlink_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub st_rdev: libc::c_ulong,
    pub st_pad2: [libc::c_long; 2usize],
    pub st_size: __off_t,
    pub st_pad3: libc::c_long,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_pad5: [libc::c_long; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::core::mem::size_of::<stat>() - 144usize];
    ["Alignment of stat"][::core::mem::align_of::<stat>() - 4usize];
    ["Offset of field: stat::st_dev"][::core::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::st_pad1"][::core::mem::offset_of!(stat, st_pad1) - 4usize];
    ["Offset of field: stat::st_ino"][::core::mem::offset_of!(stat, st_ino) - 16usize];
    ["Offset of field: stat::st_mode"][::core::mem::offset_of!(stat, st_mode) - 20usize];
    ["Offset of field: stat::st_nlink"][::core::mem::offset_of!(stat, st_nlink) - 24usize];
    ["Offset of field: stat::st_uid"][::core::mem::offset_of!(stat, st_uid) - 28usize];
    ["Offset of field: stat::st_gid"][::core::mem::offset_of!(stat, st_gid) - 32usize];
    ["Offset of field: stat::st_rdev"][::core::mem::offset_of!(stat, st_rdev) - 36usize];
    ["Offset of field: stat::st_pad2"][::core::mem::offset_of!(stat, st_pad2) - 40usize];
    ["Offset of field: stat::st_size"][::core::mem::offset_of!(stat, st_size) - 48usize];
    ["Offset of field: stat::st_pad3"][::core::mem::offset_of!(stat, st_pad3) - 52usize];
    ["Offset of field: stat::st_atim"][::core::mem::offset_of!(stat, st_atim) - 56usize];
    ["Offset of field: stat::st_mtim"][::core::mem::offset_of!(stat, st_mtim) - 64usize];
    ["Offset of field: stat::st_ctim"][::core::mem::offset_of!(stat, st_ctim) - 72usize];
    ["Offset of field: stat::st_blksize"][::core::mem::offset_of!(stat, st_blksize) - 80usize];
    ["Offset of field: stat::st_blocks"][::core::mem::offset_of!(stat, st_blocks) - 84usize];
    ["Offset of field: stat::st_pad5"][::core::mem::offset_of!(stat, st_pad5) - 88usize];
};
extern "C" {
    pub fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
}
extern "C" {
    pub fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __buf: *mut stat,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
}
extern "C" {
    pub fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn fchmod(__fd: libc::c_int, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __mode: __mode_t,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn mkdirat(__fd: libc::c_int, __path: *const libc::c_char, __mode: __mode_t)
        -> libc::c_int;
}
extern "C" {
    pub fn mknod(__path: *const libc::c_char, __mode: __mode_t, __dev: __dev_t) -> libc::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __times: *const timespec,
        __flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn futimens(__fd: libc::c_int, __times: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn __fxstat(
        __ver: libc::c_int,
        __fildes: libc::c_int,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __lxstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __fxstatat(
        __ver: libc::c_int,
        __fildes: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __xmknod(
        __ver: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __xmknodat(
        __ver: libc::c_int,
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_type: libc::c_short,
    pub l_whence: libc::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_sysid: libc::c_long,
    pub l_pid: __pid_t,
    pub __glibc_reserved0: [libc::c_long; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flock"][::core::mem::size_of::<flock>() - 36usize];
    ["Alignment of flock"][::core::mem::align_of::<flock>() - 4usize];
    ["Offset of field: flock::l_type"][::core::mem::offset_of!(flock, l_type) - 0usize];
    ["Offset of field: flock::l_whence"][::core::mem::offset_of!(flock, l_whence) - 2usize];
    ["Offset of field: flock::l_start"][::core::mem::offset_of!(flock, l_start) - 4usize];
    ["Offset of field: flock::l_len"][::core::mem::offset_of!(flock, l_len) - 8usize];
    ["Offset of field: flock::l_sysid"][::core::mem::offset_of!(flock, l_sysid) - 12usize];
    ["Offset of field: flock::l_pid"][::core::mem::offset_of!(flock, l_pid) - 16usize];
    ["Offset of field: flock::__glibc_reserved0"]
        [::core::mem::offset_of!(flock, __glibc_reserved0) - 20usize];
};
pub type flock_t = flock;
extern "C" {
    pub fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, ...) -> libc::c_int;
}
extern "C" {
    pub fn open(__file: *const libc::c_char, __oflag: libc::c_int, ...) -> libc::c_int;
}
extern "C" {
    pub fn openat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __oflag: libc::c_int,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn creat(__file: *const libc::c_char, __mode: mode_t) -> libc::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: libc::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: libc::c_int, __offset: off_t, __len: off_t) -> libc::c_int;
}
#[repr(u32)]
#[doc = " 摄像头控制总线类型枚举"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPSensorControlBusType {
    #[doc = "< I2C控制总线"]
    TX_SENSOR_CONTROL_INTERFACE_I2C = 1,
    #[doc = "< SPI控制总线"]
    TX_SENSOR_CONTROL_INTERFACE_SPI = 2,
}
#[doc = " 摄像头控制总线类型是I2C时，需要配置的参数结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPI2CInfo {
    #[doc = "< I2C设备名字，必须与摄像头驱动中struct i2c_device_id中name变量一致"]
    pub type_: [libc::c_char; 20usize],
    #[doc = "< I2C地址"]
    pub addr: libc::c_int,
    #[doc = "< I2C控制器"]
    pub i2c_adapter_id: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPI2CInfo"][::core::mem::size_of::<IMPI2CInfo>() - 28usize];
    ["Alignment of IMPI2CInfo"][::core::mem::align_of::<IMPI2CInfo>() - 4usize];
    ["Offset of field: IMPI2CInfo::type_"][::core::mem::offset_of!(IMPI2CInfo, type_) - 0usize];
    ["Offset of field: IMPI2CInfo::addr"][::core::mem::offset_of!(IMPI2CInfo, addr) - 20usize];
    ["Offset of field: IMPI2CInfo::i2c_adapter_id"]
        [::core::mem::offset_of!(IMPI2CInfo, i2c_adapter_id) - 24usize];
};
#[doc = " 摄像头控制总线类型是SPI时，需要配置的参数结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPSPIInfo {
    #[doc = "< SPI设备名字，必须与摄像头驱动中struct spi_device_id中name变量一致"]
    pub modalias: [libc::c_char; 32usize],
    #[doc = "< SPI总线地址"]
    pub bus_num: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPSPIInfo"][::core::mem::size_of::<IMPSPIInfo>() - 36usize];
    ["Alignment of IMPSPIInfo"][::core::mem::align_of::<IMPSPIInfo>() - 4usize];
    ["Offset of field: IMPSPIInfo::modalias"]
        [::core::mem::offset_of!(IMPSPIInfo, modalias) - 0usize];
    ["Offset of field: IMPSPIInfo::bus_num"]
        [::core::mem::offset_of!(IMPSPIInfo, bus_num) - 32usize];
};
#[doc = " 摄像头注册信息结构体"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPSensorInfo {
    #[doc = "< 摄像头名字"]
    pub name: [libc::c_char; 32usize],
    #[doc = "< 摄像头ID"]
    pub sensor_id: u16,
    #[doc = "< 摄像头控制总线类型"]
    pub cbus_type: IMPSensorControlBusType,
    pub __anon1: IMPSensorInfo__bindgen_ty_1,
    #[doc = "< 摄像头reset接口链接的GPIO，注意：现在没有启用该参数"]
    pub rst_gpio: libc::c_ushort,
    #[doc = "< 摄像头power down接口链接的GPIO，注意：现在没有启用该参数"]
    pub pwdn_gpio: libc::c_ushort,
    #[doc = "< 摄像头power 接口链接的GPIO，注意：现在没有启用该参数"]
    pub power_gpio: libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPSensorInfo__bindgen_ty_1 {
    #[doc = "< I2C总线信息"]
    pub i2c: IMPI2CInfo,
    #[doc = "< SPI总线信息"]
    pub spi: IMPSPIInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPSensorInfo__bindgen_ty_1"]
        [::core::mem::size_of::<IMPSensorInfo__bindgen_ty_1>() - 36usize];
    ["Alignment of IMPSensorInfo__bindgen_ty_1"]
        [::core::mem::align_of::<IMPSensorInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: IMPSensorInfo__bindgen_ty_1::i2c"]
        [::core::mem::offset_of!(IMPSensorInfo__bindgen_ty_1, i2c) - 0usize];
    ["Offset of field: IMPSensorInfo__bindgen_ty_1::spi"]
        [::core::mem::offset_of!(IMPSensorInfo__bindgen_ty_1, spi) - 0usize];
};
impl Default for IMPSensorInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPSensorInfo"][::core::mem::size_of::<IMPSensorInfo>() - 84usize];
    ["Alignment of IMPSensorInfo"][::core::mem::align_of::<IMPSensorInfo>() - 4usize];
    ["Offset of field: IMPSensorInfo::name"][::core::mem::offset_of!(IMPSensorInfo, name) - 0usize];
    ["Offset of field: IMPSensorInfo::sensor_id"]
        [::core::mem::offset_of!(IMPSensorInfo, sensor_id) - 32usize];
    ["Offset of field: IMPSensorInfo::cbus_type"]
        [::core::mem::offset_of!(IMPSensorInfo, cbus_type) - 36usize];
    ["Offset of field: IMPSensorInfo::rst_gpio"]
        [::core::mem::offset_of!(IMPSensorInfo, rst_gpio) - 76usize];
    ["Offset of field: IMPSensorInfo::pwdn_gpio"]
        [::core::mem::offset_of!(IMPSensorInfo, pwdn_gpio) - 78usize];
    ["Offset of field: IMPSensorInfo::power_gpio"]
        [::core::mem::offset_of!(IMPSensorInfo, power_gpio) - 80usize];
};
impl Default for IMPSensorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Open(void)\n\n 打开ISP模块\n\n @param 无\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 创建ISP模块，准备向ISP添加sensor，并开启ISP效果调试功能。\n\n @attention 这个函数必须在添加sensor之前被调用。"]
    pub fn IMP_ISP_Open() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Close(void)\n\n 关闭ISP模块\n\n @param 无\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark ISP模块，ISP模块不再工作。\n\n @attention 在使用这个函数之前，必须保证所有FrameSource和效果调试功能已经关闭，所有sensor都已被卸载."]
    pub fn IMP_ISP_Close() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetDefaultBinPath(char *path)\n\n 设置ISP bin文件默认路径\n\n @param[in] path  需要设置的bin文件路径\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 设置用户自定义ISP启动时Bin文件的绝对路径。\n\n @attention 这个函数必须在添加sensor之前、打开ISP之后被调用。"]
    pub fn IMP_ISP_SetDefaultBinPath(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetDefaultBinPath(char *path)\n\n 获取ISP bin文件默认路径\n\n @param[out] path\t需要获取的bin文件路径\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 获取用户自定义ISP启动时Bin文件的绝对路径。\n\n @attention 这个函数必须在添加sensor之后被调用。\n @attention 一次只能获取单个ISP的bin文件路径属性。"]
    pub fn IMP_ISP_GetDefaultBinPath(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_AddSensor(IMPSensorInfo *pinfo)\n\n 添加一个sensor，用于向ISP模块提供数据源\n\n @param[in] pinfo 需要添加sensor的信息指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 添加一个摄像头，用于提供图像。\n\n @attention 在使用这个函数之前，必须保证摄像头驱动已经注册进内核."]
    pub fn IMP_ISP_AddSensor(pinfo: *mut IMPSensorInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DelSensor(IMPSensorInfo *pinfo)\n\n 删除一个sensor\n\n @param[in] pinfo 需要删除sensor的信息指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 删除一个摄像头。\n\n @attention 在使用这个函数之前，必须保证摄像头已经停止工作，即调用了IMP_ISP_DisableSensor函数."]
    pub fn IMP_ISP_DelSensor(pinfo: *mut IMPSensorInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_EnableSensor(void)\n\n 使能一个sensor\n\n @param 无\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 使能一个摄像头，使之开始传输图像, 这样FrameSource才能输出图像，同时ISP才能进行效果调试。\n\n @attention 在使用这个函数之前，必须保证摄像头已经被添加进ISP模块."]
    pub fn IMP_ISP_EnableSensor() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DisableSensor(void)\n\n 不使能一个sensor\n\n @param 无\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 不使能一个摄像头，使之停止传输图像, 这样FrameSource无法输出图像，同时ISP也不能进行效果调试。\n\n @attention 在使用这个函数之前，必须保证所有FrameSource都已停止输出图像，同时效果调试也在不使能态."]
    pub fn IMP_ISP_DisableSensor() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_SetSensorRegister(uint32_t reg, uint32_t value)\n\n 设置sensor一个寄存器的值\n\n @param[in] reg 寄存器地址\n\n @param[in] value 寄存器值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 可以直接设置一个sensor寄存器的值。\n\n @attention 在使用这个函数之前，必须保证摄像头已经被使能."]
    pub fn IMP_ISP_SetSensorRegister(reg: u32, value: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_GetSensorRegister(uint32_t reg, uint32_t *value)\n\n 获取sensor一个寄存器的值\n\n @param[in] reg 寄存器地址\n\n @param[in] value 寄存器值的指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 可以直接获取一个sensor寄存器的值。\n\n @attention 在使用这个函数之前，必须保证摄像头已经被使能."]
    pub fn IMP_ISP_GetSensorRegister(reg: u32, value: *mut u32) -> libc::c_int;
}
#[repr(u32)]
#[doc = " ISP功能开关"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPTuningOpsMode {
    #[doc = "< 不使能该模块功能"]
    IMPISP_TUNING_OPS_MODE_DISABLE = 0,
    #[doc = "< 使能该模块功能"]
    IMPISP_TUNING_OPS_MODE_ENABLE = 1,
    #[doc = "< 用于判断参数的有效性，参数大小必须小于这个值"]
    IMPISP_TUNING_OPS_MODE_BUTT = 2,
}
#[repr(u32)]
#[doc = " ISP功能选用开关"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPTuningOpsType {
    #[doc = "< 该模块的操作为自动模式"]
    IMPISP_TUNING_OPS_TYPE_AUTO = 0,
    #[doc = "< 该模块的操作为手动模式"]
    IMPISP_TUNING_OPS_TYPE_MANUAL = 1,
    #[doc = "< 用于判断参数的有效性，参数大小必须小于这个值"]
    IMPISP_TUNING_OPS_TYPE_BUTT = 2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPZone {
    #[doc = "< 各区域信息"]
    pub zone: [[libc::c_uint; 15usize]; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPZone"][::core::mem::size_of::<IMPISPZone>() - 900usize];
    ["Alignment of IMPISPZone"][::core::mem::align_of::<IMPISPZone>() - 1usize];
    ["Offset of field: IMPISPZone::zone"][::core::mem::offset_of!(IMPISPZone, zone) - 0usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_EnableTuning(void)\n\n 使能ISP效果调试功能\n\n @param 无\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor被执行且返回成功."]
    pub fn IMP_ISP_EnableTuning() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DisableTuning(void)\n\n 不使能ISP效果调试功能\n\n @param 无\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证在不使能sensor之前，先不使能ISP效果调试（即调用此函数）."]
    pub fn IMP_ISP_DisableTuning() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSensorFPS(uint32_t fps_num, uint32_t fps_den)\n\n 设置摄像头输出帧率\n\n @param[in] fps_num 设定帧率的分子参数\n @param[in] fps_den 设定帧率的分母参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor 和 IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSensorFPS(fps_num: u32, fps_den: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorFPS(uint32_t *fps_num, uint32_t *fps_den)\n\n 获取摄像头输出帧率\n\n @param[in] fps_num 获取帧率分子参数的指针\n @param[in] fps_den 获取帧率分母参数的指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor 和 IMP_ISP_EnableTuning已被调用。\n @attention 在使能帧通道开始传输数据之前必须先调用此函数获取摄像头默认帧率。"]
    pub fn IMP_ISP_Tuning_GetSensorFPS(fps_num: *mut u32, fps_den: *mut u32) -> libc::c_int;
}
#[repr(u32)]
#[doc = " ISP抗闪频属性参数结构体。"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAntiflickerAttr {
    #[doc = "< 不使能ISP抗闪频功能"]
    IMPISP_ANTIFLICKER_DISABLE = 0,
    #[doc = "< 使能ISP抗闪频功能, 并设置频率为50HZ"]
    IMPISP_ANTIFLICKER_50HZ = 1,
    #[doc = "< 使能ISP抗闪频功能，并设置频率为60HZ"]
    IMPISP_ANTIFLICKER_60HZ = 2,
    #[doc = "< 用于判断参数的有效性，参数大小必须小于这个值"]
    IMPISP_ANTIFLICKER_BUTT = 3,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAntiFlickerAttr(IMPISPAntiflickerAttr attr)\n\n 设置ISP抗闪频属性\n\n @param[in] attr 设置参数值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetAntiFlickerAttr(attr: IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAntiFlickerAttr(IMPISPAntiflickerAttr *pattr)\n\n 获得ISP抗闪频属性\n\n @param[in] pattr 获取参数值指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetAntiFlickerAttr(pattr: *mut IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBrightness(unsigned char bright)\n\n 设置ISP 综合效果图片亮度\n\n @param[in] bright 图片亮度参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加亮度，小于128降低亮度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetBrightness(bright: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBrightness(unsigned char *pbright)\n\n 获取ISP 综合效果图片亮度\n\n @param[in] bright 图片亮度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加亮度，小于128降低亮度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetBrightness(pbright: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetContrast(unsigned char contrast)\n\n 设置ISP 综合效果图片对比度\n\n @param[in] contrast 图片对比度参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加对比度，小于128降低对比度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetContrast(contrast: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetContrast(unsigned char *pcontrast)\n\n 获取ISP 综合效果图片对比度\n\n @param[in] contrast 图片对比度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加对比度，小于128降低对比度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetContrast(pcontrast: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSharpness(unsigned char sharpness)\n\n 设置ISP 综合效果图片锐度\n\n @param[in] sharpness 图片锐度参数值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加锐度，小于128降低锐度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetSharpness(sharpness: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSharpness(unsigned char *psharpness)\n\n 获取ISP 综合效果图片锐度\n\n @param[in] sharpness 图片锐度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加锐度，小于128降低锐度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetSharpness(psharpness: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBcshHue(unsigned char hue)\n\n 设置图像的色调\n\n @param[in] hue 图像的色调参考值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128正向调节色调，小于128反向调节色调，调节范围0~255。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetBcshHue(hue: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBcshHue(unsigned char *hue)\n\n 获取图像的色调值。\n\n @param[out] hue 图像的色调参数指针。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128代表正向调节色调，小于128代表反向调节色调，范围0~255。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetBcshHue(hue: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSaturation(unsigned char sat)\n\n 设置ISP 综合效果图片饱和度\n\n @param[in] sat 图片饱和度参数值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加饱和度，小于128降低饱和度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetSaturation(sat: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSaturation(unsigned char *psat)\n\n 获取ISP 综合效果图片饱和度\n\n @param[in] sat 图片饱和度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加饱和度，小于128降低饱和度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetSaturation(psat: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPBypass(IMPISPTuningOpsMode enable)\n\n ISP模块是否bypass\n\n @param[in] enable 是否bypass输出模式\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 在使用这个函数之前，必须保证ISP模块是关闭的."]
    pub fn IMP_ISP_Tuning_SetISPBypass(enable: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetTotalGain(uint32_t *gain)\n\n 获取ISP输出图像的整体增益值\n\n @param[in] gain 获取增益值参数的指针,其数据存放格式为[24.8]，高24bit为整数，低8bit为小数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor 和 IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetTotalGain(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " 设置ISP图像镜面效果功能是否使能\n\n @fn int IMP_ISP_Tuning_SetISPHflip(IMPISPTuningOpsMode mode)\n\n @param[in] mode 是否使能镜面效果\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPHflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPHflip(IMPISPTuningOpsMode *pmode)\n\n 获取ISP图像镜面效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPHflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip(IMPISPTuningOpsMode mode)\n\n 设置ISP图像上下反转效果功能是否使能\n\n @param[in] mode 是否使能图像上下反转\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPVflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPVflip(IMPISPTuningOpsMode *pmode)\n\n 获取ISP图像上下反转效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPVflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " 设置Sensor图像镜面效果功能是否使能\n\n @fn int IMP_ISP_Tuning_SetSensorHflip(IMPISPTuningOpsMode mode)\n\n @param[in] mode 是否使能镜面效果\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSensorHflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorHflip(IMPISPTuningOpsMode *pmode)\n\n 获取Sensor图像镜面效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetSensorHflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip(IMPISPTuningOpsMode mode)\n\n 设置Sensor图像上下反转效果功能是否使能\n\n @param[in] mode 是否使能图像上下反转\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSensorVflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorVflip(IMPISPTuningOpsMode *pmode)\n\n 获取Sensor图像上下反转效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetSensorVflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
#[repr(u32)]
#[doc = " ISP 工作模式配置，正常模式或夜视模式。"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPRunningMode {
    #[doc = "< 正常模式"]
    IMPISP_RUNNING_MODE_DAY = 0,
    #[doc = "< 夜视模式"]
    IMPISP_RUNNING_MODE_NIGHT = 1,
    #[doc = "< 最大值"]
    IMPISP_RUNNING_MODE_BUTT = 2,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPRunningMode(IMPISPRunningMode mode)\n\n 设置ISP工作模式，正常模式或夜视模式；默认为正常模式。\n\n @param[in] mode运行模式参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n 示例：\n @code\n IMPISPRunningMode mode;\n\n\tif( it is during a night now){\nmode = IMPISP_RUNNING_MODE_NIGHT\n}else{\nmode = IMPISP_RUNNING_MODE_DAY;\n}\nret = IMP_ISP_Tuning_SetISPRunningMode(mode);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetISPRunningMode error !\\n\");\nreturn -1;\n}\n\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPRunningMode(mode: IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPRunningMode(IMPISPRunningMode *pmode)\n\n 获取ISP工作模式，正常模式或夜视模式。\n\n @param[in] pmode操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPRunningMode(pmode: *mut IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPCustomMode(IMPISPTuningOpsMode mode)\n\n 使能ISP Custom Mode，加载另外一套效果参数.\n\n @param[in] mode Custom 模式，使能或者关闭\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPCustomMode(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPCustomMode(IMPISPTuningOpsMode mode)\n\n 获取ISP Custom Mode的状态.\n\n @param[out] mode Custom 模式，使能或者关闭\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPCustomMode(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
#[doc = " gamma"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPGamma {
    #[doc = "< gamma参数数组，有129个点"]
    pub gamma: [u16; 129usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPGamma"][::core::mem::size_of::<IMPISPGamma>() - 258usize];
    ["Alignment of IMPISPGamma"][::core::mem::align_of::<IMPISPGamma>() - 2usize];
    ["Offset of field: IMPISPGamma::gamma"][::core::mem::offset_of!(IMPISPGamma, gamma) - 0usize];
};
impl Default for IMPISPGamma {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetGamma(IMPISPGamma *gamma)\n\n 设置GAMMA参数.\n @param[in] gamma gamma参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetGamma(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetGamma(IMPISPGamma *gamma)\n\n 获取GAMMA参数.\n @param[out] gamma gamma参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetGamma(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeComp(int comp)\n\n 设置AE补偿。AE补偿参数可以调整图像AE target，范围为[0-255].\n @param[in] comp AE补偿参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeComp(comp: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeComp(int *comp)\n\n 获取AE补偿。\n @param[out] comp AE补偿参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeComp(comp: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeLuma(int *luma)\n\n 获取画面平均亮度。\n\n @param[out] luma AE亮度参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeLuma(luma: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeFreeze(IMPISPTuningOpsMode mode)\n\n 使能AE Freeze功能.\n\n @param[in] mode AE Freeze功能使能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeFreeze(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
#[repr(u32)]
#[doc = " 曝光模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_expr_mode {
    #[doc = "< 自动模式"]
    ISP_CORE_EXPR_MODE_AUTO = 0,
    #[doc = "< 手动模式"]
    ISP_CORE_EXPR_MODE_MANUAL = 1,
}
#[repr(u32)]
#[doc = " 曝光单位"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_expr_unit {
    #[doc = "< 行"]
    ISP_CORE_EXPR_UNIT_LINE = 0,
    #[doc = "< 毫秒"]
    ISP_CORE_EXPR_UNIT_US = 1,
}
#[doc = " 曝光参数"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union isp_core_expr_attr {
    pub s_attr: isp_core_expr_attr__bindgen_ty_1,
    pub g_attr: isp_core_expr_attr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_expr_attr__bindgen_ty_1 {
    #[doc = "< 设置的曝光模式"]
    pub mode: isp_core_expr_mode,
    #[doc = "< 设置的曝光单位"]
    pub unit: isp_core_expr_unit,
    pub time: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_expr_attr__bindgen_ty_1"]
        [::core::mem::size_of::<isp_core_expr_attr__bindgen_ty_1>() - 12usize];
    ["Alignment of isp_core_expr_attr__bindgen_ty_1"]
        [::core::mem::align_of::<isp_core_expr_attr__bindgen_ty_1>() - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_1::mode"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_1, mode) - 0usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_1::unit"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_1, unit) - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_1::time"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_1, time) - 8usize];
};
impl Default for isp_core_expr_attr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_expr_attr__bindgen_ty_2 {
    #[doc = "< 获取的曝光模式"]
    pub mode: isp_core_expr_mode,
    #[doc = "< 获取的曝光时间，单位为行"]
    pub integration_time: u16,
    #[doc = "< 获取的曝光最小时间，单位为行"]
    pub integration_time_min: u16,
    #[doc = "< 获取的曝光最大时间，单位为行"]
    pub integration_time_max: u16,
    #[doc = "< 获取的一行曝光时间对应的微妙数"]
    pub one_line_expr_in_us: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_expr_attr__bindgen_ty_2"]
        [::core::mem::size_of::<isp_core_expr_attr__bindgen_ty_2>() - 12usize];
    ["Alignment of isp_core_expr_attr__bindgen_ty_2"]
        [::core::mem::align_of::<isp_core_expr_attr__bindgen_ty_2>() - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::mode"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, mode) - 0usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::integration_time"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, integration_time) - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::integration_time_min"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, integration_time_min) - 6usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::integration_time_max"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, integration_time_max) - 8usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::one_line_expr_in_us"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, one_line_expr_in_us) - 10usize];
};
impl Default for isp_core_expr_attr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_expr_attr"][::core::mem::size_of::<isp_core_expr_attr>() - 12usize];
    ["Alignment of isp_core_expr_attr"][::core::mem::align_of::<isp_core_expr_attr>() - 4usize];
    ["Offset of field: isp_core_expr_attr::s_attr"]
        [::core::mem::offset_of!(isp_core_expr_attr, s_attr) - 0usize];
    ["Offset of field: isp_core_expr_attr::g_attr"]
        [::core::mem::offset_of!(isp_core_expr_attr, g_attr) - 0usize];
};
impl Default for isp_core_expr_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 曝光参数"]
pub type IMPISPExpr = isp_core_expr_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetExpr(IMPISPExpr *expr)\n\n 设置AE参数。\n\n @param[in] expr AE参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetExpr(expr: *mut IMPISPExpr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetExpr(IMPISPExpr *expr)\n\n 获取AE参数。\n\n @param[out] expr AE参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetExpr(expr: *mut IMPISPExpr) -> libc::c_int;
}
#[doc = " 曝光统计区域选择"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union isp_core_ae_roi_select {
    pub __anon1: isp_core_ae_roi_select__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_ae_roi_select__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_ae_roi_select__bindgen_ty_1"]
        [::core::mem::size_of::<isp_core_ae_roi_select__bindgen_ty_1>() - 4usize];
    ["Alignment of isp_core_ae_roi_select__bindgen_ty_1"]
        [::core::mem::align_of::<isp_core_ae_roi_select__bindgen_ty_1>() - 4usize];
};
impl isp_core_ae_roi_select__bindgen_ty_1 {
    #[inline]
    pub fn endy(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_endy(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn endx(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_endx(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn starty(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_starty(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn startx(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_startx(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endy: libc::c_uint,
        endx: libc::c_uint,
        starty: libc::c_uint,
        startx: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let endy: u32 = unsafe { ::core::mem::transmute(endy) };
            endy as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let endx: u32 = unsafe { ::core::mem::transmute(endx) };
            endx as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let starty: u32 = unsafe { ::core::mem::transmute(starty) };
            starty as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let startx: u32 = unsafe { ::core::mem::transmute(startx) };
            startx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_ae_roi_select"][::core::mem::size_of::<isp_core_ae_roi_select>() - 4usize];
    ["Alignment of isp_core_ae_roi_select"]
        [::core::mem::align_of::<isp_core_ae_roi_select>() - 4usize];
    ["Offset of field: isp_core_ae_roi_select::value"]
        [::core::mem::offset_of!(isp_core_ae_roi_select, value) - 0usize];
};
impl Default for isp_core_ae_roi_select {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 曝光统计区域选择"]
pub type IMPISPAERoi = isp_core_ae_roi_select;
#[repr(u32)]
#[doc = " 白平衡模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_wb_mode {
    #[doc = "< 自动模式"]
    ISP_CORE_WB_MODE_AUTO = 0,
    #[doc = "< 手动模式"]
    ISP_CORE_WB_MODE_MANUAL = 1,
    #[doc = "< 晴天"]
    ISP_CORE_WB_MODE_DAY_LIGHT = 2,
    #[doc = "< 阴天"]
    ISP_CORE_WB_MODE_CLOUDY = 3,
    #[doc = "< 白炽灯"]
    ISP_CORE_WB_MODE_INCANDESCENT = 4,
    #[doc = "< 荧光灯"]
    ISP_CORE_WB_MODE_FLOURESCENT = 5,
    #[doc = "< 黄昏"]
    ISP_CORE_WB_MODE_TWILIGHT = 6,
    #[doc = "< 阴影"]
    ISP_CORE_WB_MODE_SHADE = 7,
    #[doc = "< 暖色荧光灯"]
    ISP_CORE_WB_MODE_WARM_FLOURESCENT = 8,
    #[doc = "< 自定义模式"]
    ISP_CORE_WB_MODE_CUSTOM = 9,
}
#[doc = " 白平衡参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_wb_attr {
    #[doc = "< 白平衡模式，分为自动与手动模式"]
    pub mode: isp_core_wb_mode,
    #[doc = "< 红色增益，手动模式时有效"]
    pub rgain: u16,
    #[doc = "< 蓝色增益，手动模式时有效"]
    pub bgain: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_wb_attr"][::core::mem::size_of::<isp_core_wb_attr>() - 8usize];
    ["Alignment of isp_core_wb_attr"][::core::mem::align_of::<isp_core_wb_attr>() - 4usize];
    ["Offset of field: isp_core_wb_attr::mode"]
        [::core::mem::offset_of!(isp_core_wb_attr, mode) - 0usize];
    ["Offset of field: isp_core_wb_attr::rgain"]
        [::core::mem::offset_of!(isp_core_wb_attr, rgain) - 4usize];
    ["Offset of field: isp_core_wb_attr::bgain"]
        [::core::mem::offset_of!(isp_core_wb_attr, bgain) - 6usize];
};
impl Default for isp_core_wb_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 白平衡参数"]
pub type IMPISPWB = isp_core_wb_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB(IMPISPWB *wb)\n\n 设置白平衡功能设置。可以设置自动与手动模式，手动模式主要通过设置rgain、bgain实现。\n\n @param[in] wb 设置的白平衡参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetWB(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetWB(IMPISPWB *wb)\n\n 获取白平衡功能设置。\n\n @param[out] wb 获取的白平衡参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetWB(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_Statis(IMPISPWB *wb)\n\n 获取白平衡统计值。\n\n @param[out] wb 获取的白平衡统计值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetWB_Statis(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_GOL_Statis(IMPISPWB *wb)\n\n 获取白平衡全局统计值。\n\n @param[out] wb 获取的白平衡全局统计值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetWB_GOL_Statis(wb: *mut IMPISPWB) -> libc::c_int;
}
#[doc = " Cluster 模式白平衡参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBCluster {
    pub ClusterEn: IMPISPTuningOpsMode,
    pub ToleranceEn: IMPISPTuningOpsMode,
    pub tolerance_th: libc::c_uint,
    pub awb_cluster: [libc::c_uint; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBCluster"][::core::mem::size_of::<IMPISPAWBCluster>() - 40usize];
    ["Alignment of IMPISPAWBCluster"][::core::mem::align_of::<IMPISPAWBCluster>() - 4usize];
    ["Offset of field: IMPISPAWBCluster::ClusterEn"]
        [::core::mem::offset_of!(IMPISPAWBCluster, ClusterEn) - 0usize];
    ["Offset of field: IMPISPAWBCluster::ToleranceEn"]
        [::core::mem::offset_of!(IMPISPAWBCluster, ToleranceEn) - 4usize];
    ["Offset of field: IMPISPAWBCluster::tolerance_th"]
        [::core::mem::offset_of!(IMPISPAWBCluster, tolerance_th) - 8usize];
    ["Offset of field: IMPISPAWBCluster::awb_cluster"]
        [::core::mem::offset_of!(IMPISPAWBCluster, awb_cluster) - 12usize];
};
impl Default for IMPISPAWBCluster {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbClust(IMPISPAWBCluster *awb_cluster);\n\n 设置CLuster AWB模式的参数。\n\n @param[in] CLuster AWB 模式的参数，包括使能、阈值等，awb_cluster[]设置，请咨询Tuning人员。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbClust(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbClust(IMPISPAWBCluster *awb_cluster)\n\n 获取CLuster AWB模式下的参数。\n\n @param[out] CLuster AWB 模式的参数，包括使能、阈值等。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbClust(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAWBCtTrend {
    pub trend_array: [libc::c_uint; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBCtTrend"][::core::mem::size_of::<IMPISPAWBCtTrend>() - 24usize];
    ["Alignment of IMPISPAWBCtTrend"][::core::mem::align_of::<IMPISPAWBCtTrend>() - 4usize];
    ["Offset of field: IMPISPAWBCtTrend::trend_array"]
        [::core::mem::offset_of!(IMPISPAWBCtTrend, trend_array) - 0usize];
};
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbCtTrend(IMPISPAWBCtTrend *ct_trend);\n\n 通过rgain与bgain的offset，设置不同色温下的色温偏向。\n\n @param[in] ct_trend 包含高中低三个色温下的rgain、bgain offset\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbCtTrend(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_GetAwbCtTrend(IMPISPAWBCtTrend *ct_trend);\n\n 获取不同色温下的色温偏向，即rgain offset与bgain offset，\n\n @param[out] ct_trend 包含高中低三个色温下的rgain、bgain offset\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbCtTrend(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
#[doc = " ISP WB COEFFT parameter structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_rgb_coefft_wb_attr {
    pub rgb_coefft_wb_r: libc::c_ushort,
    pub rgb_coefft_wb_g: libc::c_ushort,
    pub rgb_coefft_wb_b: libc::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_rgb_coefft_wb_attr"]
        [::core::mem::size_of::<isp_core_rgb_coefft_wb_attr>() - 6usize];
    ["Alignment of isp_core_rgb_coefft_wb_attr"]
        [::core::mem::align_of::<isp_core_rgb_coefft_wb_attr>() - 2usize];
    ["Offset of field: isp_core_rgb_coefft_wb_attr::rgb_coefft_wb_r"]
        [::core::mem::offset_of!(isp_core_rgb_coefft_wb_attr, rgb_coefft_wb_r) - 0usize];
    ["Offset of field: isp_core_rgb_coefft_wb_attr::rgb_coefft_wb_g"]
        [::core::mem::offset_of!(isp_core_rgb_coefft_wb_attr, rgb_coefft_wb_g) - 2usize];
    ["Offset of field: isp_core_rgb_coefft_wb_attr::rgb_coefft_wb_b"]
        [::core::mem::offset_of!(isp_core_rgb_coefft_wb_attr, rgb_coefft_wb_b) - 4usize];
};
#[doc = " ISP WB COEFFT parameter structure."]
pub type IMPISPCOEFFTWB = isp_core_rgb_coefft_wb_attr;
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_GetRgbCoefft(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n 获取sensor AWB RGB通道偏移参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_Awb_GetRgbCoefft(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_SetRgbCoefft(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n 设置sensor可以设置AWB RGB通道偏移参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。\n\n 示例：\n @code\n IMPISPCOEFFTWB isp_core_rgb_coefft_wb_attr;\n\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_r=x;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_g=y;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_b=z;\nIMP_ISP_Tuning_Awb_SetRgbCoefft(&isp_core_rgb_coefft_wb_attr);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_Awb_SetRgbCoefft error !\\n\");\nreturn -1;\n}"]
    pub fn IMP_ISP_Tuning_Awb_SetRgbCoefft(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxAgain(uint32_t gain)\n\n 设置sensor可以设置最大Again。\n\n @param[in] gain sensor可以设置的最大again.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMaxAgain(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxAgain(uint32_t *gain)\n\n 获取sensor可以设置最大Again。\n\n @param[out] gain sensor可以设置的最大again.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMaxAgain(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxDgain(uint32_t gain)\n\n 设置ISP可以设置的最大Dgain。\n\n @param[in] ISP Dgain 可以设置的最大dgain.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMaxDgain(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxDgain(uint32_t *gain)\n\n 获取ISP设置的最大Dgain。\n\n @param[out] ISP Dgain 可以得到设置的最大的dgain.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMaxDgain(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetVideoDrop(void (*cb)(void))\n\n 设置视频丢失功能。当出现sensor与主板的连接线路出现问题时，设置的回调函数会被执行。\n\n @param[in] cb 回调函数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetVideoDrop(
        cb: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHiLightDepress(uint32_t strength)\n\n 设置强光抑制强度。\n\n @param[in] strength 强光抑制强度参数.取值范围为［0-10], 0表示关闭功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetHiLightDepress(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHiLightDepress(uint32_t *strength)\n\n 获取强光抑制的强度。\n\n @param[out] strength 可以得到设置的强光抑制的强度.0表示关闭此功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetHiLightDepress(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBacklightComp(uint32_t strength)\n\n 设置背光补偿强度。\n\n @param[in] strength 背光补偿强度参数.取值范围为［0-10], 0表示关闭功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetBacklightComp(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBacklightComp(uint32_t *strength)\n\n 获取背光补偿的强度。\n\n @param[out] strength 可以得到设置的背光补偿的强度.0表示关闭此功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetBacklightComp(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetTemperStrength(uint32_t ratio)\n\n 设置3D降噪强度。\n\n @param[in] ratio 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]. *\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetTemperStrength(ratio: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSinterStrength(uint32_t ratio)\n\n 设置2D降噪强度。\n\n @param[in] ratio 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255].\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSinterStrength(ratio: u32) -> libc::c_int;
}
#[doc = " ISP EV 参数。"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPEVAttr {
    #[doc = "< 曝光值"]
    pub ev: u32,
    #[doc = "< 曝光时间"]
    pub expr_us: u32,
    #[doc = "<log格式曝光时间"]
    pub ev_log2: u32,
    #[doc = "< 模拟增益"]
    pub again: u32,
    #[doc = "< 数字增益"]
    pub dgain: u32,
    #[doc = "< log格式增益"]
    pub gain_log2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPEVAttr"][::core::mem::size_of::<IMPISPEVAttr>() - 24usize];
    ["Alignment of IMPISPEVAttr"][::core::mem::align_of::<IMPISPEVAttr>() - 4usize];
    ["Offset of field: IMPISPEVAttr::ev"][::core::mem::offset_of!(IMPISPEVAttr, ev) - 0usize];
    ["Offset of field: IMPISPEVAttr::expr_us"]
        [::core::mem::offset_of!(IMPISPEVAttr, expr_us) - 4usize];
    ["Offset of field: IMPISPEVAttr::ev_log2"]
        [::core::mem::offset_of!(IMPISPEVAttr, ev_log2) - 8usize];
    ["Offset of field: IMPISPEVAttr::again"]
        [::core::mem::offset_of!(IMPISPEVAttr, again) - 12usize];
    ["Offset of field: IMPISPEVAttr::dgain"]
        [::core::mem::offset_of!(IMPISPEVAttr, dgain) - 16usize];
    ["Offset of field: IMPISPEVAttr::gain_log2"]
        [::core::mem::offset_of!(IMPISPEVAttr, gain_log2) - 20usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetEVAttr(IMPISPEVAttr *attr)\n\n 获取EV属性。\n @param[out] attr EV属性参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetEVAttr(attr: *mut IMPISPEVAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableMovestate(void)\n\n 当sensor在运动时，设置ISP进入运动态。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_EnableMovestate() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_DisableMovestate(void)\n\n 当sensor从运动态恢复为静止态，设置ISP不使能运动态。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_Tuning_EnableMovestate已被调用。"]
    pub fn IMP_ISP_Tuning_DisableMovestate() -> libc::c_int;
}
#[repr(u32)]
#[doc = " 模式选择选项"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPTuningMode {
    #[doc = "< 该模块的操作为自动模式"]
    IMPISP_TUNING_MODE_AUTO = 0,
    #[doc = "< 该模块的操作为手动模式"]
    IMPISP_TUNING_MODE_MANUAL = 1,
    #[doc = "< 该模块的操作为设置范围模式"]
    IMPISP_TUNING_MODE_RANGE = 2,
    #[doc = "< 用于判断参数的有效性，参数大小必须小于这个值"]
    IMPISP_TUNING_MODE_BUTT = 3,
}
#[doc = " 权重信息"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPWeight {
    #[doc = "< 各区域权重信息 [0 ~ 8]"]
    pub weight: [[libc::c_uchar; 15usize]; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPWeight"][::core::mem::size_of::<IMPISPWeight>() - 225usize];
    ["Alignment of IMPISPWeight"][::core::mem::align_of::<IMPISPWeight>() - 1usize];
    ["Offset of field: IMPISPWeight::weight"]
        [::core::mem::offset_of!(IMPISPWeight, weight) - 0usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeWeight(IMPISPWeight *ae_weight)\n\n 设置AE统计区域的权重。\n\n @param[in] ae_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeWeight(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeWeight(IMPISPWeight *ae_weight)\n\n 获取AE统计区域的权重。\n\n @param[out] ae_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeWeight(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_GetROI(IMPISPWeight *roi_weight)\n\n 获取AE感兴趣区域，用于场景判断。\n\n @param[out] roi_weight AE感兴趣区域权重。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_AE_GetROI(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_SetROI(IMPISPWeight *roi_weight)\n\n 获取AE感兴趣区域，用于场景判断。\n\n @param[in] roi_weight AE感兴趣区域权重。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_AE_SetROI(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbWeight(IMPISPWeight *awb_weight)\n\n 设置AWB统计区域的权重。\n\n @param[in] awb_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbWeight(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbWeight(IMPISPWeight *awb_weight)\n\n 获取AWB统计区域的权重。\n\n @param[out] awb_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbWeight(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
#[doc = " AWB统计值"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBZone {
    #[doc = "< 15*15块，RGB三个通道在每个块的亮度统计平均值"]
    pub zone_r: [libc::c_uchar; 225usize],
    #[doc = "< 15*15块，RGB三个通道在每个块的亮度统计平均值"]
    pub zone_g: [libc::c_uchar; 225usize],
    #[doc = "< 15*15块，RGB三个通道在每个块的亮度统计平均值"]
    pub zone_b: [libc::c_uchar; 225usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBZone"][::core::mem::size_of::<IMPISPAWBZone>() - 675usize];
    ["Alignment of IMPISPAWBZone"][::core::mem::align_of::<IMPISPAWBZone>() - 1usize];
    ["Offset of field: IMPISPAWBZone::zone_r"]
        [::core::mem::offset_of!(IMPISPAWBZone, zone_r) - 0usize];
    ["Offset of field: IMPISPAWBZone::zone_g"]
        [::core::mem::offset_of!(IMPISPAWBZone, zone_g) - 225usize];
    ["Offset of field: IMPISPAWBZone::zone_b"]
        [::core::mem::offset_of!(IMPISPAWBZone, zone_b) - 450usize];
};
impl Default for IMPISPAWBZone {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbZone(IMPISPAWBZONE *awb_zone)\n\n 获取WB在每个块，不同通道的统计平均值。\n\n @param[out] awb_zone 白平衡统计信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbZone(awb_zone: *mut IMPISPAWBZone) -> libc::c_int;
}
#[repr(u32)]
#[doc = " AWB algorithm"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAWBAlgo {
    IMPISP_AWB_ALGO_NORMAL = 0,
    IMPISP_AWB_ALGO_GRAYWORLD = 1,
    IMPISP_AWB_ALGO_REWEIGHT = 2,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_ALGO(IMPISPAWBALGO wb_algo)\n\n 设置AWB统计的模式。\n\n @param[in] wb_algo AWB统计的不同模式。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetWB_ALGO(wb_algo: IMPISPAWBAlgo) -> libc::c_int;
}
#[doc = " AE统计值参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAEHist {
    #[doc = "< AE统计直方图bin边界 [0 ~ 255]"]
    pub ae_histhresh: [libc::c_uchar; 4usize],
    #[doc = "< AE统计直方图bin值 [0 ~ 65535]"]
    pub ae_hist: [libc::c_ushort; 5usize],
    #[doc = "< 水平方向有效统计区域个数 [0 ~ 15]"]
    pub ae_stat_nodeh: libc::c_uchar,
    #[doc = "< 垂直方向有效统计区域个数 [0 ~ 15]"]
    pub ae_stat_nodev: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEHist"][::core::mem::size_of::<IMPISPAEHist>() - 16usize];
    ["Alignment of IMPISPAEHist"][::core::mem::align_of::<IMPISPAEHist>() - 2usize];
    ["Offset of field: IMPISPAEHist::ae_histhresh"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_histhresh) - 0usize];
    ["Offset of field: IMPISPAEHist::ae_hist"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_hist) - 4usize];
    ["Offset of field: IMPISPAEHist::ae_stat_nodeh"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_stat_nodeh) - 14usize];
    ["Offset of field: IMPISPAEHist::ae_stat_nodev"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_stat_nodev) - 15usize];
};
#[doc = " AE统计值参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEHistOrigin {
    #[doc = "< AE统计直方图256 bin值"]
    pub ae_hist: [libc::c_uint; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEHistOrigin"][::core::mem::size_of::<IMPISPAEHistOrigin>() - 1024usize];
    ["Alignment of IMPISPAEHistOrigin"][::core::mem::align_of::<IMPISPAEHistOrigin>() - 4usize];
    ["Offset of field: IMPISPAEHistOrigin::ae_hist"]
        [::core::mem::offset_of!(IMPISPAEHistOrigin, ae_hist) - 0usize];
};
impl Default for IMPISPAEHistOrigin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeHist(IMPISPAEHist *ae_hist)\n\n 设置AE统计相关参数。\n\n @param[in] ae_hist AE统计相关参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeHist(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist(IMPISPAEHist *ae_hist)\n\n 获取AE统计值。\n\n @param[out] ae_hist AE统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeHist(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Origin(IMPISPAEHistOrigin *ae_hist)\n\n 获取AE 256 bin统计值。\n\n @param[out] ae_hist AE统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeHist_Origin(ae_hist: *mut IMPISPAEHistOrigin) -> libc::c_int;
}
#[doc = " AWB统计值"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_awb_sta_info {
    #[doc = "< AWB加权r/g平均值 [0 ~ 4095]"]
    pub r_gain: libc::c_ushort,
    #[doc = "< AWB加权b/g平均值 [0 ~ 4095]"]
    pub b_gain: libc::c_ushort,
    #[doc = "< 用于AWB统计的像素数 [0 ~ 4294967295]"]
    pub awb_sum: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_awb_sta_info"][::core::mem::size_of::<isp_core_awb_sta_info>() - 8usize];
    ["Alignment of isp_core_awb_sta_info"]
        [::core::mem::align_of::<isp_core_awb_sta_info>() - 4usize];
    ["Offset of field: isp_core_awb_sta_info::r_gain"]
        [::core::mem::offset_of!(isp_core_awb_sta_info, r_gain) - 0usize];
    ["Offset of field: isp_core_awb_sta_info::b_gain"]
        [::core::mem::offset_of!(isp_core_awb_sta_info, b_gain) - 2usize];
    ["Offset of field: isp_core_awb_sta_info::awb_sum"]
        [::core::mem::offset_of!(isp_core_awb_sta_info, awb_sum) - 4usize];
};
#[repr(u32)]
#[doc = " AWB统计模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_awb_stats_mode {
    #[doc = "< 延迟模式"]
    IMPISP_AWB_STATS_LEGACY_MODE = 0,
    #[doc = "< 当前模式"]
    IMPISP_AWB_STATS_CURRENT_MODE = 1,
    IMPISP_AWB_STATS_MODE_BUTT = 2,
}
#[doc = " AWB统计值参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBHist {
    #[doc = "< AWB统计值"]
    pub awb_stat: isp_core_awb_sta_info,
    #[doc = "< AWB统计模式"]
    pub awb_stats_mode: isp_core_awb_stats_mode,
    #[doc = "< AWB统计数值上限 [0 ~ 1023]"]
    pub awb_whitelevel: libc::c_ushort,
    #[doc = "< AWB统计数值下限 [0 ~ 1023]"]
    pub awb_blacklevel: libc::c_ushort,
    #[doc = "< AWB统计白点区域r/g最大值 [0 ~ 4095]"]
    pub cr_ref_max: libc::c_ushort,
    #[doc = "< AWB统计白点区域r/g最小值 [0 ~ 4095]"]
    pub cr_ref_min: libc::c_ushort,
    #[doc = "< AWB统计白点区域b/g最大值  [0 ~ 4095]"]
    pub cb_ref_max: libc::c_ushort,
    #[doc = "< AWB统计白点区域b/g最大值  [0 ~ 4095]"]
    pub cb_ref_min: libc::c_ushort,
    #[doc = "< 水平方向有效统计区域个数 [0 ~ 15]"]
    pub awb_stat_nodeh: libc::c_uchar,
    #[doc = "< 垂直方向有效统计区域个数 [0 ~ 15]"]
    pub awb_stat_nodev: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBHist"][::core::mem::size_of::<IMPISPAWBHist>() - 28usize];
    ["Alignment of IMPISPAWBHist"][::core::mem::align_of::<IMPISPAWBHist>() - 4usize];
    ["Offset of field: IMPISPAWBHist::awb_stat"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stat) - 0usize];
    ["Offset of field: IMPISPAWBHist::awb_stats_mode"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stats_mode) - 8usize];
    ["Offset of field: IMPISPAWBHist::awb_whitelevel"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_whitelevel) - 12usize];
    ["Offset of field: IMPISPAWBHist::awb_blacklevel"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_blacklevel) - 14usize];
    ["Offset of field: IMPISPAWBHist::cr_ref_max"]
        [::core::mem::offset_of!(IMPISPAWBHist, cr_ref_max) - 16usize];
    ["Offset of field: IMPISPAWBHist::cr_ref_min"]
        [::core::mem::offset_of!(IMPISPAWBHist, cr_ref_min) - 18usize];
    ["Offset of field: IMPISPAWBHist::cb_ref_max"]
        [::core::mem::offset_of!(IMPISPAWBHist, cb_ref_max) - 20usize];
    ["Offset of field: IMPISPAWBHist::cb_ref_min"]
        [::core::mem::offset_of!(IMPISPAWBHist, cb_ref_min) - 22usize];
    ["Offset of field: IMPISPAWBHist::awb_stat_nodeh"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stat_nodeh) - 24usize];
    ["Offset of field: IMPISPAWBHist::awb_stat_nodev"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stat_nodev) - 25usize];
};
impl Default for IMPISPAWBHist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbHist(IMPISPAWBHist *awb_hist)\n\n 获取AWB统计值。\n\n @param[out] awb_hist AWB统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbHist(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbHist(IMPISPAWBHist *awb_hist)\n\n 设置AWB统计相关参数。\n\n @param[in] awb_hist AWB统计相关参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbHist(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_af_sta_info {
    #[doc = "< AF主统计值"]
    pub af_metrics: libc::c_uint,
    #[doc = "< AF次统计值"]
    pub af_metrics_alt: libc::c_uint,
    pub af_wl: libc::c_uint,
    pub af_wh: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_af_sta_info"][::core::mem::size_of::<isp_core_af_sta_info>() - 16usize];
    ["Alignment of isp_core_af_sta_info"][::core::mem::align_of::<isp_core_af_sta_info>() - 4usize];
    ["Offset of field: isp_core_af_sta_info::af_metrics"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_metrics) - 0usize];
    ["Offset of field: isp_core_af_sta_info::af_metrics_alt"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_metrics_alt) - 4usize];
    ["Offset of field: isp_core_af_sta_info::af_wl"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_wl) - 8usize];
    ["Offset of field: isp_core_af_sta_info::af_wh"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_wh) - 12usize];
};
#[doc = " 滤波器的使能位"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_af_ldg_en_info {
    pub fir0_en: libc::c_uchar,
    pub fir1_en: libc::c_uchar,
    pub iir0_en: libc::c_uchar,
    pub iir1_en: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_af_ldg_en_info"][::core::mem::size_of::<isp_af_ldg_en_info>() - 4usize];
    ["Alignment of isp_af_ldg_en_info"][::core::mem::align_of::<isp_af_ldg_en_info>() - 1usize];
    ["Offset of field: isp_af_ldg_en_info::fir0_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, fir0_en) - 0usize];
    ["Offset of field: isp_af_ldg_en_info::fir1_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, fir1_en) - 1usize];
    ["Offset of field: isp_af_ldg_en_info::iir0_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, iir0_en) - 2usize];
    ["Offset of field: isp_af_ldg_en_info::iir1_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, iir1_en) - 3usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_ldg_info {
    pub thlow1: libc::c_uchar,
    pub thlow2: libc::c_uchar,
    pub slplow: libc::c_ushort,
    pub gainlow: libc::c_uchar,
    pub thhigh1: libc::c_uchar,
    pub thhigh2: libc::c_uchar,
    pub slphigh: libc::c_ushort,
    pub gainhigh: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_ldg_info"][::core::mem::size_of::<isp_ldg_info>() - 12usize];
    ["Alignment of isp_ldg_info"][::core::mem::align_of::<isp_ldg_info>() - 2usize];
    ["Offset of field: isp_ldg_info::thlow1"]
        [::core::mem::offset_of!(isp_ldg_info, thlow1) - 0usize];
    ["Offset of field: isp_ldg_info::thlow2"]
        [::core::mem::offset_of!(isp_ldg_info, thlow2) - 1usize];
    ["Offset of field: isp_ldg_info::slplow"]
        [::core::mem::offset_of!(isp_ldg_info, slplow) - 2usize];
    ["Offset of field: isp_ldg_info::gainlow"]
        [::core::mem::offset_of!(isp_ldg_info, gainlow) - 4usize];
    ["Offset of field: isp_ldg_info::thhigh1"]
        [::core::mem::offset_of!(isp_ldg_info, thhigh1) - 5usize];
    ["Offset of field: isp_ldg_info::thhigh2"]
        [::core::mem::offset_of!(isp_ldg_info, thhigh2) - 6usize];
    ["Offset of field: isp_ldg_info::slphigh"]
        [::core::mem::offset_of!(isp_ldg_info, slphigh) - 8usize];
    ["Offset of field: isp_ldg_info::gainhigh"]
        [::core::mem::offset_of!(isp_ldg_info, gainhigh) - 10usize];
};
#[doc = " AF统计值参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAFHist {
    pub af_stat: isp_core_af_sta_info,
    #[doc = "< AF功能开关"]
    pub af_enable: libc::c_uchar,
    #[doc = "< AF统计值缩小参数 默认是0，1代表缩小2倍"]
    pub af_metrics_shift: libc::c_uchar,
    #[doc = "< AF统计低通滤波器的权重 [0 ~ 64]"]
    pub af_delta: libc::c_ushort,
    #[doc = "< AF统计高通滤波器的权重 [0 ~ 64]"]
    pub af_theta: libc::c_ushort,
    #[doc = "< AF高亮点统计阈值 [0 ~ 255]"]
    pub af_hilight_th: libc::c_ushort,
    #[doc = "< AF统计低通滤波器的水平与垂直方向的权重 [0 ~ 64]"]
    pub af_alpha_alt: libc::c_ushort,
    #[doc = "< AF统计高通滤波器的水平与垂直方向的权重 [0 ~ 64]"]
    pub af_belta_alt: libc::c_ushort,
    #[doc = "< AF统计值横向起始点：[1-width]，且取奇数"]
    pub af_hstart: libc::c_uchar,
    #[doc = "< AF统计值垂直起始点 ：[3-height]，且取奇数"]
    pub af_vstart: libc::c_uchar,
    #[doc = "< 水平方向统计区域个数 [默认值15]，整个画幅的统计窗口H数目"]
    pub af_stat_nodeh: libc::c_uchar,
    #[doc = "< 垂直方向统计区域个数 [默认值15]，整个画幅的统计窗口V数目"]
    pub af_stat_nodev: libc::c_uchar,
    pub af_frame_num: libc::c_uchar,
    #[doc = "< LDG模块使能"]
    pub ldg_en: isp_af_ldg_en_info,
    pub af_fir0: isp_ldg_info,
    pub af_fir1: isp_ldg_info,
    pub af_iir0: isp_ldg_info,
    pub af_iir1: isp_ldg_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAFHist"][::core::mem::size_of::<IMPISPAFHist>() - 88usize];
    ["Alignment of IMPISPAFHist"][::core::mem::align_of::<IMPISPAFHist>() - 4usize];
    ["Offset of field: IMPISPAFHist::af_stat"]
        [::core::mem::offset_of!(IMPISPAFHist, af_stat) - 0usize];
    ["Offset of field: IMPISPAFHist::af_enable"]
        [::core::mem::offset_of!(IMPISPAFHist, af_enable) - 16usize];
    ["Offset of field: IMPISPAFHist::af_metrics_shift"]
        [::core::mem::offset_of!(IMPISPAFHist, af_metrics_shift) - 17usize];
    ["Offset of field: IMPISPAFHist::af_delta"]
        [::core::mem::offset_of!(IMPISPAFHist, af_delta) - 18usize];
    ["Offset of field: IMPISPAFHist::af_theta"]
        [::core::mem::offset_of!(IMPISPAFHist, af_theta) - 20usize];
    ["Offset of field: IMPISPAFHist::af_hilight_th"]
        [::core::mem::offset_of!(IMPISPAFHist, af_hilight_th) - 22usize];
    ["Offset of field: IMPISPAFHist::af_alpha_alt"]
        [::core::mem::offset_of!(IMPISPAFHist, af_alpha_alt) - 24usize];
    ["Offset of field: IMPISPAFHist::af_belta_alt"]
        [::core::mem::offset_of!(IMPISPAFHist, af_belta_alt) - 26usize];
    ["Offset of field: IMPISPAFHist::af_hstart"]
        [::core::mem::offset_of!(IMPISPAFHist, af_hstart) - 28usize];
    ["Offset of field: IMPISPAFHist::af_vstart"]
        [::core::mem::offset_of!(IMPISPAFHist, af_vstart) - 29usize];
    ["Offset of field: IMPISPAFHist::af_stat_nodeh"]
        [::core::mem::offset_of!(IMPISPAFHist, af_stat_nodeh) - 30usize];
    ["Offset of field: IMPISPAFHist::af_stat_nodev"]
        [::core::mem::offset_of!(IMPISPAFHist, af_stat_nodev) - 31usize];
    ["Offset of field: IMPISPAFHist::af_frame_num"]
        [::core::mem::offset_of!(IMPISPAFHist, af_frame_num) - 32usize];
    ["Offset of field: IMPISPAFHist::ldg_en"]
        [::core::mem::offset_of!(IMPISPAFHist, ldg_en) - 33usize];
    ["Offset of field: IMPISPAFHist::af_fir0"]
        [::core::mem::offset_of!(IMPISPAFHist, af_fir0) - 38usize];
    ["Offset of field: IMPISPAFHist::af_fir1"]
        [::core::mem::offset_of!(IMPISPAFHist, af_fir1) - 50usize];
    ["Offset of field: IMPISPAFHist::af_iir0"]
        [::core::mem::offset_of!(IMPISPAFHist, af_iir0) - 62usize];
    ["Offset of field: IMPISPAFHist::af_iir1"]
        [::core::mem::offset_of!(IMPISPAFHist, af_iir1) - 74usize];
};
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetAFMetrices(unsigned int *metric);\n\n 获取AF统计值。\n\n @param[out] metric AF统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAFMetrices(metric: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfHist(IMPISPAFHist *af_hist);\n\n 获取AF统计值。\n\n @param[out] af_hist AF统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAfHist(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfHist(IMPISPAFHist *af_hist)\n\n 设置AF统计相关参数。\n\n @param[in] af_hist AF统计相关参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAfHist(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfWeight(IMPISPWeight *af_weight)\n\n 设置AF统计区域的权重。\n\n @param[in] af_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAfWeight(af_weigh: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfWeight(IMPISPWeight *af_weight)\n\n 获取AF统计区域的权重。\n\n @param[out] af_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAfWeight(af_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfZone(IMPISPZone *af_zone)\n\n 获取AF各个zone的统计值。\n\n @param[out] af_zone AF各个区域的统计值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAfZone(af_zone: *mut IMPISPZone) -> libc::c_int;
}
#[doc = " ISP Wait Frame 参数。"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPWaitFrameAttr {
    #[doc = "< 超时时间，单位ms"]
    pub timeout: u32,
    #[doc = "< Frame统计"]
    pub cnt: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPWaitFrameAttr"][::core::mem::size_of::<IMPISPWaitFrameAttr>() - 16usize];
    ["Alignment of IMPISPWaitFrameAttr"][::core::mem::align_of::<IMPISPWaitFrameAttr>() - 8usize];
    ["Offset of field: IMPISPWaitFrameAttr::timeout"]
        [::core::mem::offset_of!(IMPISPWaitFrameAttr, timeout) - 0usize];
    ["Offset of field: IMPISPWaitFrameAttr::cnt"]
        [::core::mem::offset_of!(IMPISPWaitFrameAttr, cnt) - 8usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_WaitFrame(IMPISPWaitFrameAttr *attr)\n 等待帧结束\n\n @param[out] attr 等待帧结束属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_WaitFrame(attr: *mut IMPISPWaitFrameAttr) -> libc::c_int;
}
#[doc = " AE Min"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAEMin {
    #[doc = "< AE最小曝光"]
    pub min_it: libc::c_uint,
    #[doc = "< AE 最小模拟增益"]
    pub min_again: libc::c_uint,
    #[doc = "< AE短帧的最小曝光"]
    pub min_it_short: libc::c_uint,
    #[doc = "< AE 短帧的最小模拟增益"]
    pub min_again_short: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEMin"][::core::mem::size_of::<IMPISPAEMin>() - 16usize];
    ["Alignment of IMPISPAEMin"][::core::mem::align_of::<IMPISPAEMin>() - 4usize];
    ["Offset of field: IMPISPAEMin::min_it"][::core::mem::offset_of!(IMPISPAEMin, min_it) - 0usize];
    ["Offset of field: IMPISPAEMin::min_again"]
        [::core::mem::offset_of!(IMPISPAEMin, min_again) - 4usize];
    ["Offset of field: IMPISPAEMin::min_it_short"]
        [::core::mem::offset_of!(IMPISPAEMin, min_it_short) - 8usize];
    ["Offset of field: IMPISPAEMin::min_again_short"]
        [::core::mem::offset_of!(IMPISPAEMin, min_again_short) - 12usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeMin(IMPISPAEMin *ae_min)\n\n 设置AE最小值参数。\n\n @param[in] ae_min AE最小值参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeMin(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeMin(IMPISPAEMin *ae_min)\n\n 获取AE最小值参数。\n\n @param[out] ae_min AE最小值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeMin(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAe_IT_MAX(unsigned int it_max)\n\n 设置AE最大值参数。\n\n @param[in] it_max AE最大值参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAe_IT_MAX(it_max: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAE_IT_MAX(unsigned int *it_max)\n\n 获取AE最大值参数。\n\n @param[out] it_max AE最大值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAE_IT_MAX(it_max: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeZone(IMPISPZone *ae_zone)\n\n 获取AE各个zone的Y值。\n\n @param[out] ae_zone AE各个区域的Y值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeZone(ae_zone: *mut IMPISPZone) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAETargetList {
    pub at_list: [libc::c_uint; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAETargetList"][::core::mem::size_of::<IMPISPAETargetList>() - 40usize];
    ["Alignment of IMPISPAETargetList"][::core::mem::align_of::<IMPISPAETargetList>() - 4usize];
    ["Offset of field: IMPISPAETargetList::at_list"]
        [::core::mem::offset_of!(IMPISPAETargetList, at_list) - 0usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList(IMPISPAETargetList *target_list)\n\n 设置AE的目标亮度表\n\n @param[in] target_list  目标亮度表\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeTargetList(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList(IMPISPAETargetList *target_list)\n\n 获取AE当前的目标亮度表\n\n @param[out] target_list  目标亮度表\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeTargetList(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
#[doc = " ISP Module Control"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPISPModuleCtl {
    pub key: libc::c_uint,
    pub __anon1: IMPISPModuleCtl__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPModuleCtl__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPModuleCtl__bindgen_ty_1"]
        [::core::mem::size_of::<IMPISPModuleCtl__bindgen_ty_1>() - 4usize];
    ["Alignment of IMPISPModuleCtl__bindgen_ty_1"]
        [::core::mem::align_of::<IMPISPModuleCtl__bindgen_ty_1>() - 4usize];
};
impl IMPISPModuleCtl__bindgen_ty_1 {
    #[inline]
    pub fn bitBypassBLC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassBLC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassGIB(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassGIB(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassAG(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassAG(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDPC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDPC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassRDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassRDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassLSC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassLSC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassADR(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassADR(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDMSC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDMSC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCCM(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCCM(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassGAMMA(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassGAMMA(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDEFOG(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDEFOG(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCSC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCSC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCLM(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCLM(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassSP(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassSP(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassYDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassYDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassBCSH(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassBCSH(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassSDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassSDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassHLDC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassHLDC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitRsv(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_bitRsv(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassMDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassMDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bitBypassBLC: libc::c_uint,
        bitBypassGIB: libc::c_uint,
        bitBypassAG: libc::c_uint,
        bitBypassDPC: libc::c_uint,
        bitBypassRDNS: libc::c_uint,
        bitBypassLSC: libc::c_uint,
        bitBypassADR: libc::c_uint,
        bitBypassDMSC: libc::c_uint,
        bitBypassCCM: libc::c_uint,
        bitBypassGAMMA: libc::c_uint,
        bitBypassDEFOG: libc::c_uint,
        bitBypassCSC: libc::c_uint,
        bitBypassCLM: libc::c_uint,
        bitBypassSP: libc::c_uint,
        bitBypassYDNS: libc::c_uint,
        bitBypassBCSH: libc::c_uint,
        bitBypassSDNS: libc::c_uint,
        bitBypassHLDC: libc::c_uint,
        bitRsv: libc::c_uint,
        bitBypassMDNS: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bitBypassBLC: u32 = unsafe { ::core::mem::transmute(bitBypassBLC) };
            bitBypassBLC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bitBypassGIB: u32 = unsafe { ::core::mem::transmute(bitBypassGIB) };
            bitBypassGIB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bitBypassAG: u32 = unsafe { ::core::mem::transmute(bitBypassAG) };
            bitBypassAG as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bitBypassDPC: u32 = unsafe { ::core::mem::transmute(bitBypassDPC) };
            bitBypassDPC as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bitBypassRDNS: u32 = unsafe { ::core::mem::transmute(bitBypassRDNS) };
            bitBypassRDNS as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bitBypassLSC: u32 = unsafe { ::core::mem::transmute(bitBypassLSC) };
            bitBypassLSC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bitBypassADR: u32 = unsafe { ::core::mem::transmute(bitBypassADR) };
            bitBypassADR as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bitBypassDMSC: u32 = unsafe { ::core::mem::transmute(bitBypassDMSC) };
            bitBypassDMSC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bitBypassCCM: u32 = unsafe { ::core::mem::transmute(bitBypassCCM) };
            bitBypassCCM as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bitBypassGAMMA: u32 = unsafe { ::core::mem::transmute(bitBypassGAMMA) };
            bitBypassGAMMA as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bitBypassDEFOG: u32 = unsafe { ::core::mem::transmute(bitBypassDEFOG) };
            bitBypassDEFOG as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bitBypassCSC: u32 = unsafe { ::core::mem::transmute(bitBypassCSC) };
            bitBypassCSC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let bitBypassCLM: u32 = unsafe { ::core::mem::transmute(bitBypassCLM) };
            bitBypassCLM as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let bitBypassSP: u32 = unsafe { ::core::mem::transmute(bitBypassSP) };
            bitBypassSP as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let bitBypassYDNS: u32 = unsafe { ::core::mem::transmute(bitBypassYDNS) };
            bitBypassYDNS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let bitBypassBCSH: u32 = unsafe { ::core::mem::transmute(bitBypassBCSH) };
            bitBypassBCSH as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bitBypassSDNS: u32 = unsafe { ::core::mem::transmute(bitBypassSDNS) };
            bitBypassSDNS as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let bitBypassHLDC: u32 = unsafe { ::core::mem::transmute(bitBypassHLDC) };
            bitBypassHLDC as u64
        });
        __bindgen_bitfield_unit.set(18usize, 12u8, {
            let bitRsv: u32 = unsafe { ::core::mem::transmute(bitRsv) };
            bitRsv as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bitBypassMDNS: u32 = unsafe { ::core::mem::transmute(bitBypassMDNS) };
            bitBypassMDNS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPModuleCtl"][::core::mem::size_of::<IMPISPModuleCtl>() - 4usize];
    ["Alignment of IMPISPModuleCtl"][::core::mem::align_of::<IMPISPModuleCtl>() - 4usize];
    ["Offset of field: IMPISPModuleCtl::key"]
        [::core::mem::offset_of!(IMPISPModuleCtl, key) - 0usize];
};
impl Default for IMPISPModuleCtl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetModuleControl(IMPISPModuleCtl *ispmodule)\n\n 设置ISP各个模块bypass功能\n\n @param[in] ispmodule ISP各个模块bypass功能.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetModuleControl(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetModuleControl(IMPISPModuleCtl *ispmodule)\n\n 获取ISP各个模块bypass功能.\n\n @param[out] ispmodule ISP各个模块bypass功能\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetModuleControl(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
#[doc = " ISP Front Crop Attribution"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPFrontCrop {
    pub fcrop_enable: bool,
    pub fcrop_top: libc::c_uint,
    pub fcrop_left: libc::c_uint,
    pub fcrop_width: libc::c_uint,
    pub fcrop_height: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFrontCrop"][::core::mem::size_of::<IMPISPFrontCrop>() - 20usize];
    ["Alignment of IMPISPFrontCrop"][::core::mem::align_of::<IMPISPFrontCrop>() - 4usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_enable"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_enable) - 0usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_top"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_top) - 4usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_left"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_left) - 8usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_width"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_width) - 12usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_height"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_height) - 16usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetFrontCrop(IMPISPFrontCrop *ispfrontcrop)\n\n 设置ISP前Crop的位置\n\n @param[in] ispfrontcrop 前Crop参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetFrontCrop(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetFrontCrop(IMPISPFrontCrop *ispfrontcrop)\n\n 获取前Crop参数.\n\n @param[out] ispfrontcrop 前Crop参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetFrontCrop(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDPC_Strength(unsigned int strength)\n\n 设置DPC强度.\n\n @param[in] strength 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDPC_Strength(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDPC_Strength(unsigned int *strength)\n\n 获取DPC强度.\n\n @param[out] strength 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDPC_Strength(ratio: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDRC_Strength(unsigned int ratio)\n\n 设置DRC强度值.\n\n @param[in] strength 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDRC_Strength(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDRC_Strength(unsigned int *ratio)\n\n 获取DRC强度值.\n\n @param[out] ratio 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDRC_Strength(ratio: *mut libc::c_uint) -> libc::c_int;
}
#[repr(u32)]
#[doc = " HV Flip 模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPHVFLIP {
    #[doc = "< 正常模式"]
    IMPISP_FLIP_NORMAL_MODE = 0,
    #[doc = "< 镜像模式"]
    IMPISP_FLIP_H_MODE = 1,
    #[doc = "< 翻转模式"]
    IMPISP_FLIP_V_MODE = 2,
    #[doc = "< 镜像并翻转模式"]
    IMPISP_FLIP_HV_MODE = 3,
    IMPISP_FLIP_MODE_BUTT = 4,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHVFLIP(IMPISPHVFLIP hvflip)\n\n 设置HV Flip的模式.\n\n @param[in] hvflip HV Flip模式.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetHVFLIP(hvflip: IMPISPHVFLIP) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHVFlip(IMPISPHVFLIP *hvflip)\n\n 获取HV Flip的模式.\n\n @param[out] hvflip HV Flip模式.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetHVFlip(hvflip: *mut IMPISPHVFLIP) -> libc::c_int;
}
#[repr(u32)]
#[doc = " 填充数据类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISP_MASK_TYPE {
    #[doc = "< RGB"]
    IMPISP_MASK_TYPE_RGB = 0,
    #[doc = "< YUV"]
    IMPISP_MASK_TYPE_YUV = 1,
}
#[doc = " 填充数据"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union mask_value {
    #[doc = "< RGB"]
    pub mask_rgb: mask_value__bindgen_ty_1,
    #[doc = "< YUV"]
    pub mask_ayuv: mask_value__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mask_value__bindgen_ty_1 {
    #[doc = "< R 值"]
    pub Red: libc::c_uchar,
    #[doc = "< G 值"]
    pub Green: libc::c_uchar,
    #[doc = "< B 值"]
    pub Blue: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask_value__bindgen_ty_1"]
        [::core::mem::size_of::<mask_value__bindgen_ty_1>() - 3usize];
    ["Alignment of mask_value__bindgen_ty_1"]
        [::core::mem::align_of::<mask_value__bindgen_ty_1>() - 1usize];
    ["Offset of field: mask_value__bindgen_ty_1::Red"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_1, Red) - 0usize];
    ["Offset of field: mask_value__bindgen_ty_1::Green"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_1, Green) - 1usize];
    ["Offset of field: mask_value__bindgen_ty_1::Blue"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_1, Blue) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mask_value__bindgen_ty_2 {
    #[doc = "< Y 值"]
    pub y_value: libc::c_uchar,
    #[doc = "< U 值"]
    pub u_value: libc::c_uchar,
    #[doc = "< V 值"]
    pub v_value: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask_value__bindgen_ty_2"]
        [::core::mem::size_of::<mask_value__bindgen_ty_2>() - 3usize];
    ["Alignment of mask_value__bindgen_ty_2"]
        [::core::mem::align_of::<mask_value__bindgen_ty_2>() - 1usize];
    ["Offset of field: mask_value__bindgen_ty_2::y_value"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_2, y_value) - 0usize];
    ["Offset of field: mask_value__bindgen_ty_2::u_value"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_2, u_value) - 1usize];
    ["Offset of field: mask_value__bindgen_ty_2::v_value"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_2, v_value) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask_value"][::core::mem::size_of::<mask_value>() - 3usize];
    ["Alignment of mask_value"][::core::mem::align_of::<mask_value>() - 1usize];
    ["Offset of field: mask_value::mask_rgb"]
        [::core::mem::offset_of!(mask_value, mask_rgb) - 0usize];
    ["Offset of field: mask_value::mask_ayuv"]
        [::core::mem::offset_of!(mask_value, mask_ayuv) - 0usize];
};
impl Default for mask_value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 填充数据"]
pub type IMP_ISP_MASK_VALUE = mask_value;
#[doc = " 每个通道的填充属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISP_MASK_BLOCK_PAR {
    #[doc = "< 填充使能"]
    pub mask_en: libc::c_uchar,
    #[doc = "< 填充位置y坐标"]
    pub mask_pos_top: libc::c_ushort,
    #[doc = "< 填充位置x坐标"]
    pub mask_pos_left: libc::c_ushort,
    #[doc = "< 填充数据宽度"]
    pub mask_width: libc::c_ushort,
    #[doc = "< 填充数据高度"]
    pub mask_height: libc::c_ushort,
    #[doc = "< 填充数据值"]
    pub mask_value: IMP_ISP_MASK_VALUE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISP_MASK_BLOCK_PAR"][::core::mem::size_of::<IMPISP_MASK_BLOCK_PAR>() - 14usize];
    ["Alignment of IMPISP_MASK_BLOCK_PAR"]
        [::core::mem::align_of::<IMPISP_MASK_BLOCK_PAR>() - 2usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_en"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_en) - 0usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_pos_top"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_pos_top) - 2usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_pos_left"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_pos_left) - 4usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_width"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_width) - 6usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_height"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_height) - 8usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_value"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_value) - 10usize];
};
impl Default for IMPISP_MASK_BLOCK_PAR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 填充参数"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPMASKAttr {
    #[doc = "< 通道0填充参数"]
    pub chn0: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< 通道1填充参数"]
    pub chn1: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< 通道3填充参数"]
    pub chn2: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< 填充数据类型"]
    pub mask_type: IMPISP_MASK_TYPE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPMASKAttr"][::core::mem::size_of::<IMPISPMASKAttr>() - 172usize];
    ["Alignment of IMPISPMASKAttr"][::core::mem::align_of::<IMPISPMASKAttr>() - 4usize];
    ["Offset of field: IMPISPMASKAttr::chn0"]
        [::core::mem::offset_of!(IMPISPMASKAttr, chn0) - 0usize];
    ["Offset of field: IMPISPMASKAttr::chn1"]
        [::core::mem::offset_of!(IMPISPMASKAttr, chn1) - 56usize];
    ["Offset of field: IMPISPMASKAttr::chn2"]
        [::core::mem::offset_of!(IMPISPMASKAttr, chn2) - 112usize];
    ["Offset of field: IMPISPMASKAttr::mask_type"]
        [::core::mem::offset_of!(IMPISPMASKAttr, mask_type) - 168usize];
};
impl Default for IMPISPMASKAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMask(IMPISPMASKAttr *mask)\n\n 设置填充参数.\n\n @param[in] mask 填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMask(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMask(IMPISPMASKAttr *mask)\n\n 获取填充参数.\n\n @param[out] mask 填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMask(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
#[doc = " Sensor属性参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPSENSORAttr {
    #[doc = "< sensor hts"]
    pub hts: libc::c_uint,
    #[doc = "< sensor vts"]
    pub vts: libc::c_uint,
    #[doc = "< sensor 帧率"]
    pub fps: libc::c_uint,
    #[doc = "< sensor输出宽度"]
    pub width: libc::c_uint,
    #[doc = "< sensor输出的高度"]
    pub height: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPSENSORAttr"][::core::mem::size_of::<IMPISPSENSORAttr>() - 20usize];
    ["Alignment of IMPISPSENSORAttr"][::core::mem::align_of::<IMPISPSENSORAttr>() - 4usize];
    ["Offset of field: IMPISPSENSORAttr::hts"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, hts) - 0usize];
    ["Offset of field: IMPISPSENSORAttr::vts"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, vts) - 4usize];
    ["Offset of field: IMPISPSENSORAttr::fps"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, fps) - 8usize];
    ["Offset of field: IMPISPSENSORAttr::width"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, width) - 12usize];
    ["Offset of field: IMPISPSENSORAttr::height"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, height) - 16usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorAttr(IMPISPSENSORAttr *attr)\n\n 获取填充参数.\n\n @param[out] attr sensor属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetSensorAttr(attr: *mut IMPISPSENSORAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDRC(IMPISPTuningOpsMode mode)\n\n 使能DRC功能.\n\n @param[out] mode DRC功能使能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_EnableDRC(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDefog(IMPISPTuningOpsMode mode)\n\n 使能Defog功能.\n\n @param[out] mode Defog功能使能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_EnableDefog(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbCt(unsigned int *ct)\n\n 设置AWB色温值.\n\n @param[in] ct AWB色温值.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbCt(ct: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAWBCt(unsigned int *ct)\n\n 获取AWB色温值.\n\n @param[out] ct AWB色温值.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAWBCt(ct: *mut libc::c_uint) -> libc::c_int;
}
#[doc = " ISP 颜色矩阵属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCCMAttr {
    pub ManualEn: IMPISPTuningOpsMode,
    pub SatEn: IMPISPTuningOpsMode,
    pub ColorMatrix: [f32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPCCMAttr"][::core::mem::size_of::<IMPISPCCMAttr>() - 44usize];
    ["Alignment of IMPISPCCMAttr"][::core::mem::align_of::<IMPISPCCMAttr>() - 4usize];
    ["Offset of field: IMPISPCCMAttr::ManualEn"]
        [::core::mem::offset_of!(IMPISPCCMAttr, ManualEn) - 0usize];
    ["Offset of field: IMPISPCCMAttr::SatEn"]
        [::core::mem::offset_of!(IMPISPCCMAttr, SatEn) - 4usize];
    ["Offset of field: IMPISPCCMAttr::ColorMatrix"]
        [::core::mem::offset_of!(IMPISPCCMAttr, ColorMatrix) - 8usize];
};
impl Default for IMPISPCCMAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetCCMAttr(IMPISPCCMAttr *ccm)\n\n 设置CCM属性.\n\n @param[in] ccm CCM属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetCCMAttr(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetCCMAttr(IMPISPCCMAttr *ccm)\n\n 获取CCM属性.\n\n @param[out] ccm CCM属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetCCMAttr(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
#[doc = " ISP AE 手动模式属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEAttr {
    pub AeFreezenEn: IMPISPTuningOpsMode,
    pub AeItManualEn: IMPISPTuningOpsMode,
    pub AeIt: libc::c_uint,
    pub AeAGainManualEn: IMPISPTuningOpsMode,
    pub AeAGain: libc::c_uint,
    pub AeDGainManualEn: IMPISPTuningOpsMode,
    pub AeDGain: libc::c_uint,
    pub AeIspDGainManualEn: IMPISPTuningOpsMode,
    pub AeIspDGain: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEAttr"][::core::mem::size_of::<IMPISPAEAttr>() - 36usize];
    ["Alignment of IMPISPAEAttr"][::core::mem::align_of::<IMPISPAEAttr>() - 4usize];
    ["Offset of field: IMPISPAEAttr::AeFreezenEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeFreezenEn) - 0usize];
    ["Offset of field: IMPISPAEAttr::AeItManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeItManualEn) - 4usize];
    ["Offset of field: IMPISPAEAttr::AeIt"][::core::mem::offset_of!(IMPISPAEAttr, AeIt) - 8usize];
    ["Offset of field: IMPISPAEAttr::AeAGainManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeAGainManualEn) - 12usize];
    ["Offset of field: IMPISPAEAttr::AeAGain"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeAGain) - 16usize];
    ["Offset of field: IMPISPAEAttr::AeDGainManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeDGainManualEn) - 20usize];
    ["Offset of field: IMPISPAEAttr::AeDGain"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeDGain) - 24usize];
    ["Offset of field: IMPISPAEAttr::AeIspDGainManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeIspDGainManualEn) - 28usize];
    ["Offset of field: IMPISPAEAttr::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeIspDGain) - 32usize];
};
impl Default for IMPISPAEAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeAttr(IMPISPAEAttr *ae)\n\n 设置AE手动模式属性.\n\n @param[in] ae AE手动模式属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeAttr(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeAttr(IMPISPAEAttr *ae)\n\n 获取AE手动模式属性.\n\n @param[out] ae AE手动模式属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。\n @attention 在使用这个函数之前，需要先将IMPISPAEAttr结构体初始化为0，然后配置相应的属性。"]
    pub fn IMP_ISP_Tuning_GetAeAttr(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAEState {
    pub stable: bool,
    pub target: libc::c_uint,
    pub ae_mean: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEState"][::core::mem::size_of::<IMPISPAEState>() - 12usize];
    ["Alignment of IMPISPAEState"][::core::mem::align_of::<IMPISPAEState>() - 4usize];
    ["Offset of field: IMPISPAEState::stable"]
        [::core::mem::offset_of!(IMPISPAEState, stable) - 0usize];
    ["Offset of field: IMPISPAEState::target"]
        [::core::mem::offset_of!(IMPISPAEState, target) - 4usize];
    ["Offset of field: IMPISPAEState::ae_mean"]
        [::core::mem::offset_of!(IMPISPAEState, ae_mean) - 8usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeState(IMPISPAEState *ae_state)\n\n 获取AE收敛相关的状态参数.\n\n @param[out] ae AE的收敛状态.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeState(ae_state: *mut IMPISPAEState) -> libc::c_int;
}
#[repr(u32)]
#[doc = " 缩放模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPScalerMethod {
    IMP_ISP_SCALER_METHOD_FITTING_CURVE = 0,
    IMP_ISP_SCALER_METHOD_FIXED_WEIGHT = 1,
    IMP_ISP_SCALER_METHOD_BUTT = 2,
}
#[doc = " 缩放效果参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPScalerLv {
    pub channel: libc::c_uchar,
    pub method: IMPISPScalerMethod,
    pub level: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPScalerLv"][::core::mem::size_of::<IMPISPScalerLv>() - 12usize];
    ["Alignment of IMPISPScalerLv"][::core::mem::align_of::<IMPISPScalerLv>() - 4usize];
    ["Offset of field: IMPISPScalerLv::channel"]
        [::core::mem::offset_of!(IMPISPScalerLv, channel) - 0usize];
    ["Offset of field: IMPISPScalerLv::method"]
        [::core::mem::offset_of!(IMPISPScalerLv, method) - 4usize];
    ["Offset of field: IMPISPScalerLv::level"]
        [::core::mem::offset_of!(IMPISPScalerLv, level) - 8usize];
};
impl Default for IMPISPScalerLv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetScalerLv(IMPISPScalerLv *scaler_level)\n\n Set Scaler 缩放的方法及等级.\n\n @param[in] mscaler 参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetScalerLv(scaler_level: *mut IMPISPScalerLv) -> libc::c_int;
}
#[doc = " 客户自定义自动曝光库的AE初始属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeInitAttr {
    #[doc = "< AE曝光时间单位"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE的曝光值"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE Sensor模拟增益值，单位是倍数 x 1024"]
    pub AeAGain: u32,
    #[doc = "< AE Sensor数字增益值，单位是倍数 x 1024"]
    pub AeDGain: u32,
    #[doc = "< AE ISP 数字增益值，单位倍数 x 1024"]
    pub AeIspDGain: u32,
    #[doc = "< AE最小曝光时间"]
    pub AeMinIntegrationTime: u32,
    #[doc = "< AE最小sensor模拟增益"]
    pub AeMinAGain: u32,
    #[doc = "< AE最小sensor数字增益"]
    pub AeMinDgain: u32,
    #[doc = "< AE最小ISP数字增益"]
    pub AeMinIspDGain: u32,
    #[doc = "< AE最大曝光时间"]
    pub AeMaxIntegrationTime: u32,
    #[doc = "< AE最大sensor模拟增益"]
    pub AeMaxAGain: u32,
    #[doc = "< AE最大sensor数字增益"]
    pub AeMaxDgain: u32,
    #[doc = "< AE最大ISP数字增益"]
    pub AeMaxIspDGain: u32,
    #[doc = "< AE的曝光值"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE Sensor模拟增益值，单位是倍数 x 1024"]
    pub AeShortAGain: u32,
    #[doc = "< AE Sensor数字增益值，单位是倍数 x 1024"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP 数字增益值，单位倍数 x 1024"]
    pub AeShortIspDGain: u32,
    #[doc = "< AE最小曝光时间"]
    pub AeShortMinIntegrationTime: u32,
    #[doc = "< AE最小sensor模拟增益"]
    pub AeShortMinAGain: u32,
    #[doc = "< AE最小sensor数字增益"]
    pub AeShortMinDgain: u32,
    #[doc = "< AE最小ISP数字增益"]
    pub AeShortMinIspDGain: u32,
    #[doc = "< AE最大曝光时间"]
    pub AeShortMaxIntegrationTime: u32,
    #[doc = "< AE最大sensor模拟增益"]
    pub AeShortMaxAGain: u32,
    #[doc = "< AE最大sensor数字增益"]
    pub AeShortMaxDgain: u32,
    #[doc = "< AE最大ISP数字增益"]
    pub AeShortMaxIspDGain: u32,
    #[doc = "< sensor 帧率"]
    pub fps: u32,
    #[doc = "< AE统计属性"]
    pub AeStatis: IMPISPAEHist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeInitAttr"][::core::mem::size_of::<IMPISPAeInitAttr>() - 120usize];
    ["Alignment of IMPISPAeInitAttr"][::core::mem::align_of::<IMPISPAeInitAttr>() - 4usize];
    ["Offset of field: IMPISPAeInitAttr::AeIntegrationTimeUnit"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeIntegrationTimeUnit) - 0usize];
    ["Offset of field: IMPISPAeInitAttr::AeIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeIntegrationTime) - 4usize];
    ["Offset of field: IMPISPAeInitAttr::AeAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeAGain) - 8usize];
    ["Offset of field: IMPISPAeInitAttr::AeDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeDGain) - 12usize];
    ["Offset of field: IMPISPAeInitAttr::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeIspDGain) - 16usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinIntegrationTime) - 20usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinAGain) - 24usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinDgain) - 28usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinIspDGain) - 32usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxIntegrationTime) - 36usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxAGain) - 40usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxDgain) - 44usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxIspDGain) - 48usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortIntegrationTime) - 52usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortAGain) - 56usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortDGain) - 60usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortIspDGain) - 64usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinIntegrationTime) - 68usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinAGain) - 72usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinDgain) - 76usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinIspDGain) - 80usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxIntegrationTime) - 84usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxAGain) - 88usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxDgain) - 92usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxIspDGain) - 96usize];
    ["Offset of field: IMPISPAeInitAttr::fps"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, fps) - 100usize];
    ["Offset of field: IMPISPAeInitAttr::AeStatis"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeStatis) - 104usize];
};
impl Default for IMPISPAeInitAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 客户自定义自动曝光库的AE信息"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeInfo {
    #[doc = "< AE各个区域统计值"]
    pub ae_zone: IMPISPZone,
    #[doc = "< AE的256bin统计直方图"]
    pub ae_hist_256bin: IMPISPAEHistOrigin,
    #[doc = "< AE的5bin统计直方图"]
    pub ae_hist: IMPISPAEHist,
    #[doc = "< AE曝光时间单位"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE的曝光值"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE Sensor 模拟增益值，单位是倍数 x 1024"]
    pub AeAGain: u32,
    #[doc = "< AE Sensor数字增益值，单位是倍数 x 1024"]
    pub AeDGain: u32,
    #[doc = "< AE ISP 数字增益值，单位倍数 x 1024"]
    pub AeIspDGain: u32,
    #[doc = "< AE的曝光值"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE Sensor 模拟增益值，单位是倍数 x 1024"]
    pub AeShortAGain: u32,
    #[doc = "< AE Sensor数字增益值，单位是倍数 x 1024"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP 数字增益值，单位倍数 x 1024"]
    pub AeShortIspDGain: u32,
    #[doc = "< 当前是否WDR模式"]
    pub Wdr_mode: u32,
    #[doc = "< Sensor基本属性"]
    pub sensor_attr: IMPISPSENSORAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeInfo"][::core::mem::size_of::<IMPISPAeInfo>() - 2000usize];
    ["Alignment of IMPISPAeInfo"][::core::mem::align_of::<IMPISPAeInfo>() - 1usize];
    ["Offset of field: IMPISPAeInfo::ae_zone"]
        [::core::mem::offset_of!(IMPISPAeInfo, ae_zone) - 0usize];
    ["Offset of field: IMPISPAeInfo::ae_hist_256bin"]
        [::core::mem::offset_of!(IMPISPAeInfo, ae_hist_256bin) - 900usize];
    ["Offset of field: IMPISPAeInfo::ae_hist"]
        [::core::mem::offset_of!(IMPISPAeInfo, ae_hist) - 1924usize];
    ["Offset of field: IMPISPAeInfo::AeIntegrationTimeUnit"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeIntegrationTimeUnit) - 1940usize];
    ["Offset of field: IMPISPAeInfo::AeIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeIntegrationTime) - 1944usize];
    ["Offset of field: IMPISPAeInfo::AeAGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeAGain) - 1948usize];
    ["Offset of field: IMPISPAeInfo::AeDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeDGain) - 1952usize];
    ["Offset of field: IMPISPAeInfo::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeIspDGain) - 1956usize];
    ["Offset of field: IMPISPAeInfo::AeShortIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortIntegrationTime) - 1960usize];
    ["Offset of field: IMPISPAeInfo::AeShortAGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortAGain) - 1964usize];
    ["Offset of field: IMPISPAeInfo::AeShortDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortDGain) - 1968usize];
    ["Offset of field: IMPISPAeInfo::AeShortIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortIspDGain) - 1972usize];
    ["Offset of field: IMPISPAeInfo::Wdr_mode"]
        [::core::mem::offset_of!(IMPISPAeInfo, Wdr_mode) - 1976usize];
    ["Offset of field: IMPISPAeInfo::sensor_attr"]
        [::core::mem::offset_of!(IMPISPAeInfo, sensor_attr) - 1980usize];
};
impl Default for IMPISPAeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 客户自定义自动曝光库的AE属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeAttr {
    #[doc = "< 是否更新AE参数"]
    pub change: u32,
    #[doc = "< AE曝光时间单位"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE的曝光值"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE Sensor 模拟增益值，单位是倍数 x 1024"]
    pub AeAGain: u32,
    #[doc = "< AE Sensor数字增益值，单位是倍数 x 1024"]
    pub AeDGain: u32,
    #[doc = "< AE ISP 数字增益值，单位倍数 x 1024"]
    pub AeIspDGain: u32,
    #[doc = "< AE手动模式下的曝光值"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE Sensor 模拟增益值，单位是倍数 x 1024"]
    pub AeShortAGain: u32,
    #[doc = "< AE Sensor数字增益值，单位是倍数 x 1024"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP 数字增益值，单位倍数 x 1024"]
    pub AeShortIspDGain: u32,
    #[doc = "< AE Luma值"]
    pub luma: u32,
    #[doc = "< AE 场景Luma值"]
    pub luma_scence: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeAttr"][::core::mem::size_of::<IMPISPAeAttr>() - 48usize];
    ["Alignment of IMPISPAeAttr"][::core::mem::align_of::<IMPISPAeAttr>() - 4usize];
    ["Offset of field: IMPISPAeAttr::change"]
        [::core::mem::offset_of!(IMPISPAeAttr, change) - 0usize];
    ["Offset of field: IMPISPAeAttr::AeIntegrationTimeUnit"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeIntegrationTimeUnit) - 4usize];
    ["Offset of field: IMPISPAeAttr::AeIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeIntegrationTime) - 8usize];
    ["Offset of field: IMPISPAeAttr::AeAGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeAGain) - 12usize];
    ["Offset of field: IMPISPAeAttr::AeDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeDGain) - 16usize];
    ["Offset of field: IMPISPAeAttr::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeIspDGain) - 20usize];
    ["Offset of field: IMPISPAeAttr::AeShortIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortIntegrationTime) - 24usize];
    ["Offset of field: IMPISPAeAttr::AeShortAGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortAGain) - 28usize];
    ["Offset of field: IMPISPAeAttr::AeShortDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortDGain) - 32usize];
    ["Offset of field: IMPISPAeAttr::AeShortIspDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortIspDGain) - 36usize];
    ["Offset of field: IMPISPAeAttr::luma"][::core::mem::offset_of!(IMPISPAeAttr, luma) - 40usize];
    ["Offset of field: IMPISPAeAttr::luma_scence"]
        [::core::mem::offset_of!(IMPISPAeAttr, luma_scence) - 44usize];
};
impl Default for IMPISPAeAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " 客户自定义自动曝光库的AE通知属性"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAeNotify {
    #[doc = "< 帧率变更"]
    IMPISP_AE_NOTIFY_FPS_CHANGE = 0,
}
#[doc = " 客户自定义自动曝光库的AE回调函数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeAlgoFunc {
    #[doc = "< 私有数据地址"]
    pub priv_data: *mut libc::c_void,
    #[doc = "< 自定义AE库开始接口"]
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            AeInitAttr: *mut IMPISPAeInitAttr,
        ) -> libc::c_int,
    >,
    #[doc = "< 自定义AE库关闭接口"]
    pub close: ::core::option::Option<unsafe extern "C" fn(priv_data: *mut libc::c_void)>,
    #[doc = "< 自定义AE库的处理接口"]
    pub handle: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            AeInfo: *const IMPISPAeInfo,
            AeAttr: *mut IMPISPAeAttr,
        ),
    >,
    #[doc = "< 自定义AE库的通知接口"]
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            notify: IMPISPAeNotify,
            data: *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeAlgoFunc"][::core::mem::size_of::<IMPISPAeAlgoFunc>() - 20usize];
    ["Alignment of IMPISPAeAlgoFunc"][::core::mem::align_of::<IMPISPAeAlgoFunc>() - 4usize];
    ["Offset of field: IMPISPAeAlgoFunc::priv_data"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, priv_data) - 0usize];
    ["Offset of field: IMPISPAeAlgoFunc::open"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, open) - 4usize];
    ["Offset of field: IMPISPAeAlgoFunc::close"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, close) - 8usize];
    ["Offset of field: IMPISPAeAlgoFunc::handle"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, handle) - 12usize];
    ["Offset of field: IMPISPAeAlgoFunc::notify"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, notify) - 16usize];
};
impl Default for IMPISPAeAlgoFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " 客户自定义自动曝光库的注册接口"]
    pub fn IMP_ISP_SetAeAlgoFunc(ae_func: *mut IMPISPAeAlgoFunc) -> i32;
}
#[doc = " 客户自定义自动白平衡库的AWB信息"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbInfo {
    #[doc = "< 白平衡R通道增益"]
    pub cur_r_gain: u32,
    #[doc = "< 白平衡B通道增益"]
    pub cur_b_gain: u32,
    #[doc = "< 白平衡全局统计值r_gain"]
    pub r_gain_statis: u32,
    #[doc = "< 白平衡全局加权统计值b_gain"]
    pub b_gain_statis: u32,
    #[doc = "< 白平衡全局加权统计值r_gain"]
    pub r_gain_wei_statis: u32,
    #[doc = "< 白平衡全局加权统计值b_gain"]
    pub b_gain_wei_statis: u32,
    #[doc = "< 白平衡区域统计值"]
    pub awb_statis: IMPISPAWBZone,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAwbInfo"][::core::mem::size_of::<IMPISPAwbInfo>() - 699usize];
    ["Alignment of IMPISPAwbInfo"][::core::mem::align_of::<IMPISPAwbInfo>() - 1usize];
    ["Offset of field: IMPISPAwbInfo::cur_r_gain"]
        [::core::mem::offset_of!(IMPISPAwbInfo, cur_r_gain) - 0usize];
    ["Offset of field: IMPISPAwbInfo::cur_b_gain"]
        [::core::mem::offset_of!(IMPISPAwbInfo, cur_b_gain) - 4usize];
    ["Offset of field: IMPISPAwbInfo::r_gain_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, r_gain_statis) - 8usize];
    ["Offset of field: IMPISPAwbInfo::b_gain_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, b_gain_statis) - 12usize];
    ["Offset of field: IMPISPAwbInfo::r_gain_wei_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, r_gain_wei_statis) - 16usize];
    ["Offset of field: IMPISPAwbInfo::b_gain_wei_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, b_gain_wei_statis) - 20usize];
    ["Offset of field: IMPISPAwbInfo::awb_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, awb_statis) - 24usize];
};
impl Default for IMPISPAwbInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 客户自定义自动白平衡库的AWB属性"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAwbAttr {
    #[doc = "< 是否更新AWB参数"]
    pub change: u32,
    #[doc = "< AWB参数 r_gain"]
    pub r_gain: u32,
    #[doc = "< AWB参数 b_gain"]
    pub b_gain: u32,
    #[doc = "< 当前色温"]
    pub ct: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAwbAttr"][::core::mem::size_of::<IMPISPAwbAttr>() - 16usize];
    ["Alignment of IMPISPAwbAttr"][::core::mem::align_of::<IMPISPAwbAttr>() - 4usize];
    ["Offset of field: IMPISPAwbAttr::change"]
        [::core::mem::offset_of!(IMPISPAwbAttr, change) - 0usize];
    ["Offset of field: IMPISPAwbAttr::r_gain"]
        [::core::mem::offset_of!(IMPISPAwbAttr, r_gain) - 4usize];
    ["Offset of field: IMPISPAwbAttr::b_gain"]
        [::core::mem::offset_of!(IMPISPAwbAttr, b_gain) - 8usize];
    ["Offset of field: IMPISPAwbAttr::ct"][::core::mem::offset_of!(IMPISPAwbAttr, ct) - 12usize];
};
#[repr(u32)]
#[doc = " 客户自定义自动白平衡库的AWB通知属性"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAwbNotify {
    #[doc = "< 当前AWB模式变化"]
    IMPISP_AWB_NOTIFY_MODE_CHANGE = 0,
}
#[doc = " 客户自定义自动白平衡库的AWB回调函数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbAlgoFunc {
    #[doc = "< 私有数据地址"]
    pub priv_data: *mut libc::c_void,
    #[doc = "< 自定义AWB库开始接口"]
    pub open:
        ::core::option::Option<unsafe extern "C" fn(priv_data: *mut libc::c_void) -> libc::c_int>,
    #[doc = "< 自定义AWB库关闭接口"]
    pub close: ::core::option::Option<unsafe extern "C" fn(priv_data: *mut libc::c_void)>,
    #[doc = "< 自定义AWB库的处理接口"]
    pub handle: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            AwbInfo: *const IMPISPAwbInfo,
            AwbAttr: *mut IMPISPAwbAttr,
        ),
    >,
    #[doc = "< 自定义AWB库的通知接口"]
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            notify: IMPISPAwbNotify,
            data: *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAwbAlgoFunc"][::core::mem::size_of::<IMPISPAwbAlgoFunc>() - 20usize];
    ["Alignment of IMPISPAwbAlgoFunc"][::core::mem::align_of::<IMPISPAwbAlgoFunc>() - 4usize];
    ["Offset of field: IMPISPAwbAlgoFunc::priv_data"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, priv_data) - 0usize];
    ["Offset of field: IMPISPAwbAlgoFunc::open"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, open) - 4usize];
    ["Offset of field: IMPISPAwbAlgoFunc::close"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, close) - 8usize];
    ["Offset of field: IMPISPAwbAlgoFunc::handle"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, handle) - 12usize];
    ["Offset of field: IMPISPAwbAlgoFunc::notify"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, notify) - 16usize];
};
impl Default for IMPISPAwbAlgoFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " 客户自定义自动白平衡库的注册接口"]
    pub fn IMP_ISP_SetAwbAlgoFunc(awb_func: *mut IMPISPAwbAlgoFunc) -> i32;
}
#[doc = "\t黑电平校正功能属性"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPBlcAttr {
    #[doc = "< R通道"]
    pub black_level_r: libc::c_uint,
    #[doc = "< GR通道"]
    pub black_level_gr: libc::c_uint,
    #[doc = "< GB通道"]
    pub black_level_gb: libc::c_uint,
    #[doc = "< B通道"]
    pub black_level_b: libc::c_uint,
    #[doc = "< IR通道"]
    pub black_level_ir: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPBlcAttr"][::core::mem::size_of::<IMPISPBlcAttr>() - 20usize];
    ["Alignment of IMPISPBlcAttr"][::core::mem::align_of::<IMPISPBlcAttr>() - 4usize];
    ["Offset of field: IMPISPBlcAttr::black_level_r"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_r) - 0usize];
    ["Offset of field: IMPISPBlcAttr::black_level_gr"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_gr) - 4usize];
    ["Offset of field: IMPISPBlcAttr::black_level_gb"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_gb) - 8usize];
    ["Offset of field: IMPISPBlcAttr::black_level_b"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_b) - 12usize];
    ["Offset of field: IMPISPBlcAttr::black_level_ir"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_ir) - 16usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBlcAttr(IMPISPBlcAttr *blc)\n\n 获取BLC的相关属性.\n\n @param[out] blc blc功能属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。\n @attention 在使用这个函数之前，需要先将IMPISPAEAttr结构体初始化为0。"]
    pub fn IMP_ISP_Tuning_GetBlcAttr(blc: *mut IMPISPBlcAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDefog_Strength(uint8_t *ratio)\n\n 设置Defog模块的强度。\n\n @param[in] ratio  Defog强度.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDefog_Strength(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDefog_Strength(uint8_t *ratio)\n\n 获取Defog模块的强度。\n\n @param[in] ratio  Defog强度.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDefog_Strength(ratio: *mut u8) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPCscCgMode {
    #[doc = "< BT601 full range"]
    ISP_CSC_CG_BT601_FULL = 0,
    #[doc = "< BT601 非full range"]
    ISP_CSC_CG_BT601_CLIP = 1,
    #[doc = "< BT709 full range"]
    ISP_CSC_CG_BT709_FULL = 2,
    #[doc = "< BT709 非full range"]
    ISP_CSC_CG_BT709_CLIP = 3,
    #[doc = "< 用户自定义模式"]
    ISP_CSC_CG_USER = 4,
    #[doc = "< 用于判断参数的有效性，参数大小必须小于这个值"]
    IMP_CSC_CG_BUTT = 5,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPCscParam {
    #[doc = "< 3x3矩阵"]
    pub csc_coef: [libc::c_int; 9usize],
    #[doc = "< [0] UV偏移值 [1] Y偏移值"]
    pub csc_offset: [libc::c_int; 2usize],
    #[doc = "< Y最大值，Y最大值"]
    pub csc_y_clip: [libc::c_int; 2usize],
    #[doc = "< UV最大值，UV最小值"]
    pub csc_c_clip: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPCscParam"][::core::mem::size_of::<IMPISPCscParam>() - 60usize];
    ["Alignment of IMPISPCscParam"][::core::mem::align_of::<IMPISPCscParam>() - 4usize];
    ["Offset of field: IMPISPCscParam::csc_coef"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_coef) - 0usize];
    ["Offset of field: IMPISPCscParam::csc_offset"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_offset) - 36usize];
    ["Offset of field: IMPISPCscParam::csc_y_clip"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_y_clip) - 44usize];
    ["Offset of field: IMPISPCscParam::csc_c_clip"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_c_clip) - 52usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCscAttr {
    #[doc = "< 模式"]
    pub mode: IMPISPCscCgMode,
    #[doc = "< 自定义转换矩阵"]
    pub csc_par: IMPISPCscParam,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPCscAttr"][::core::mem::size_of::<IMPISPCscAttr>() - 64usize];
    ["Alignment of IMPISPCscAttr"][::core::mem::align_of::<IMPISPCscAttr>() - 4usize];
    ["Offset of field: IMPISPCscAttr::mode"][::core::mem::offset_of!(IMPISPCscAttr, mode) - 0usize];
    ["Offset of field: IMPISPCscAttr::csc_par"]
        [::core::mem::offset_of!(IMPISPCscAttr, csc_par) - 4usize];
};
impl Default for IMPISPCscAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetCsc_Attr(IMPISPCscAttr *attr)\n\n 设置CSC模块功能属性。\n\n @param[in] attr CSC模块属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetCsc_Attr(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetCsc_Attr(IMPISPCscAttr *attr)\n\n 获取CSC模块功能属性。\n\n @param[in] attr CSC模块属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetCsc_Attr(attr: *mut IMPISPCscAttr) -> i32;
}
#[doc = " 丢帧参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrameDrop {
    #[doc = "< 使能标志"]
    pub enable: IMPISPTuningOpsMode,
    #[doc = "< 总数量(范围:0~31)"]
    pub lsize: u8,
    #[doc = "< 位标志(1输出，0丢失)"]
    pub fmark: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFrameDrop"][::core::mem::size_of::<IMPISPFrameDrop>() - 12usize];
    ["Alignment of IMPISPFrameDrop"][::core::mem::align_of::<IMPISPFrameDrop>() - 4usize];
    ["Offset of field: IMPISPFrameDrop::enable"]
        [::core::mem::offset_of!(IMPISPFrameDrop, enable) - 0usize];
    ["Offset of field: IMPISPFrameDrop::lsize"]
        [::core::mem::offset_of!(IMPISPFrameDrop, lsize) - 4usize];
    ["Offset of field: IMPISPFrameDrop::fmark"]
        [::core::mem::offset_of!(IMPISPFrameDrop, fmark) - 8usize];
};
impl Default for IMPISPFrameDrop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 丢帧属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrameDropAttr {
    #[doc = "< 各个通道的丢帧参数"]
    pub fdrop: [IMPISPFrameDrop; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFrameDropAttr"][::core::mem::size_of::<IMPISPFrameDropAttr>() - 36usize];
    ["Alignment of IMPISPFrameDropAttr"][::core::mem::align_of::<IMPISPFrameDropAttr>() - 4usize];
    ["Offset of field: IMPISPFrameDropAttr::fdrop"]
        [::core::mem::offset_of!(IMPISPFrameDropAttr, fdrop) - 0usize];
};
impl Default for IMPISPFrameDropAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFrameDrop(IMPISPFrameDropAttr *attr)\n\n 设置丢帧属性。\n\n @param[in] attr      丢帧属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 每接收(lsize+1)帧就会丢(fmark无效位数)帧。\n @remark 例如：lsize=3,fmark=0x5(每4帧丢第2和第4帧)\n\n @attention 在使用这个函数之前，IMP_ISP_Open已被调用。"]
    pub fn IMP_ISP_SetFrameDrop(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetFrameDrop(IMPISPFrameDropAttr *attr)\n\n 获取丢帧属性。\n\n @param[out] attr     丢帧属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 每接收(lsize+1)帧就会丢(fmark无效位数)帧。\n @remark 例如：lsize=3,fmark=0x5(每4帧丢第2和第4帧)\n\n @attention 在使用这个函数之前，IMP_ISP_Open已被调用。"]
    pub fn IMP_ISP_GetFrameDrop(attr: *mut IMPISPFrameDropAttr) -> i32;
}
#[doc = " mjpeg固定对比度"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPFixedContrastAttr {
    pub mode: u8,
    pub range_low: u8,
    pub range_high: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFixedContrastAttr"][::core::mem::size_of::<IMPISPFixedContrastAttr>() - 3usize];
    ["Alignment of IMPISPFixedContrastAttr"]
        [::core::mem::align_of::<IMPISPFixedContrastAttr>() - 1usize];
    ["Offset of field: IMPISPFixedContrastAttr::mode"]
        [::core::mem::offset_of!(IMPISPFixedContrastAttr, mode) - 0usize];
    ["Offset of field: IMPISPFixedContrastAttr::range_low"]
        [::core::mem::offset_of!(IMPISPFixedContrastAttr, range_low) - 1usize];
    ["Offset of field: IMPISPFixedContrastAttr::range_high"]
        [::core::mem::offset_of!(IMPISPFixedContrastAttr, range_high) - 2usize];
};
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFixedContraster(IMPISPFixedContrastAttr *attr)\n\n mjpeg设置固定对比度。\n\n @param[out] attr\t属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_SetFixedContraster(attr: *mut IMPISPFixedContrastAttr) -> i32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPGPIO {
    pub gpio_num: [u16; 10usize],
    #[doc = " gpio端口"]
    pub gpio_sta: [u16; 10usize],
    #[doc = " gpio状态"]
    pub free: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPGPIO"][::core::mem::size_of::<IMPISPGPIO>() - 42usize];
    ["Alignment of IMPISPGPIO"][::core::mem::align_of::<IMPISPGPIO>() - 2usize];
    ["Offset of field: IMPISPGPIO::gpio_num"]
        [::core::mem::offset_of!(IMPISPGPIO, gpio_num) - 0usize];
    ["Offset of field: IMPISPGPIO::gpio_sta"]
        [::core::mem::offset_of!(IMPISPGPIO, gpio_sta) - 20usize];
    ["Offset of field: IMPISPGPIO::free"][::core::mem::offset_of!(IMPISPGPIO, free) - 40usize];
};
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SET_GPIO_INIT_OR_FREE(IMPISPGPIO *attr);\n\n 申请或者释放GPIO资源\n @param[in] gpio_num 需要申请或释放的GPIO端口，以0xFF结束\n @param[in] gpio_sta 申请GPIO的初始化状态，0：低 1：高\n @param[in] free 0：申请 1：释放\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark gpio_num[10]={20,21,0xff},gpio_sta[10]= {1,0} 初始化PA20输出高PA21输出低\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_SET_GPIO_INIT_OR_FREE(attr: *mut IMPISPGPIO) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SET_GPIO_STA(IMPISPGPIO *attr)\n\n 下一个VIC DONE设置GPIO状态.\n\n @param[in] gpio_num 需要设置的GPIO端口，以0xFF结束\n @param[in] gpio_sta GPIO状态，0：低 1：高\n\n @remark gpio_num[10]={20,21,0xff},gpio_sta[10]= {1,0} PA20设置高，PA21设置低\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_SET_GPIO_STA(attr: *mut IMPISPGPIO) -> i32;
}
#[doc = " ISP AutoZoom Attribution"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAutoZoom {
    pub chan: libc::c_int,
    #[doc = " <通道号>"]
    pub scaler_enable: libc::c_int,
    #[doc = " <使能缩放功能>"]
    pub scaler_outwidth: libc::c_int,
    #[doc = " <缩放后输出的宽度>"]
    pub scaler_outheight: libc::c_int,
    #[doc = " <缩放后输出的高度>"]
    pub crop_enable: libc::c_int,
    #[doc = " <使能裁剪功能>"]
    pub crop_left: libc::c_int,
    #[doc = " <裁剪起始地址横坐标>"]
    pub crop_top: libc::c_int,
    #[doc = " <裁剪起始地址纵坐标>"]
    pub crop_width: libc::c_int,
    #[doc = " <缩放后输出的宽度>"]
    pub crop_height: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAutoZoom"][::core::mem::size_of::<IMPISPAutoZoom>() - 36usize];
    ["Alignment of IMPISPAutoZoom"][::core::mem::align_of::<IMPISPAutoZoom>() - 4usize];
    ["Offset of field: IMPISPAutoZoom::chan"]
        [::core::mem::offset_of!(IMPISPAutoZoom, chan) - 0usize];
    ["Offset of field: IMPISPAutoZoom::scaler_enable"]
        [::core::mem::offset_of!(IMPISPAutoZoom, scaler_enable) - 4usize];
    ["Offset of field: IMPISPAutoZoom::scaler_outwidth"]
        [::core::mem::offset_of!(IMPISPAutoZoom, scaler_outwidth) - 8usize];
    ["Offset of field: IMPISPAutoZoom::scaler_outheight"]
        [::core::mem::offset_of!(IMPISPAutoZoom, scaler_outheight) - 12usize];
    ["Offset of field: IMPISPAutoZoom::crop_enable"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_enable) - 16usize];
    ["Offset of field: IMPISPAutoZoom::crop_left"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_left) - 20usize];
    ["Offset of field: IMPISPAutoZoom::crop_top"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_top) - 24usize];
    ["Offset of field: IMPISPAutoZoom::crop_width"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_width) - 28usize];
    ["Offset of field: IMPISPAutoZoom::crop_height"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_height) - 32usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAutoZoom(IMPISPAutoZoom *ispautozoom)\n\n 设置自动聚焦的参数\n\n @param[in] 自动聚焦配置参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor被执行且返回成功."]
    pub fn IMP_ISP_Tuning_SetAutoZoom(ispautozoom: *mut IMPISPAutoZoom) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAutoZoom(IMPISPAutoZoom *ispautozoom)\n\n 获取自动聚焦的参数\n\n @param[in] ispautozoom 自动聚焦配置参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_Tuning_SetAutoZoom被执行且返回成功.\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor被执行且返回成功."]
    pub fn IMP_ISP_Tuning_GetAutoZoom(ispautozoom: *mut IMPISPAutoZoom) -> libc::c_int;
}
#[doc = " 填充数据"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union color_value {
    #[doc = "< RGB"]
    pub argb: color_value__bindgen_ty_1,
    #[doc = "< YUV"]
    pub ayuv: color_value__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct color_value__bindgen_ty_1 {
    #[doc = "< R 值"]
    pub r_value: libc::c_uchar,
    #[doc = "< G 值"]
    pub g_value: libc::c_uchar,
    #[doc = "< B 值"]
    pub b_value: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of color_value__bindgen_ty_1"]
        [::core::mem::size_of::<color_value__bindgen_ty_1>() - 3usize];
    ["Alignment of color_value__bindgen_ty_1"]
        [::core::mem::align_of::<color_value__bindgen_ty_1>() - 1usize];
    ["Offset of field: color_value__bindgen_ty_1::r_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_1, r_value) - 0usize];
    ["Offset of field: color_value__bindgen_ty_1::g_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_1, g_value) - 1usize];
    ["Offset of field: color_value__bindgen_ty_1::b_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_1, b_value) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct color_value__bindgen_ty_2 {
    #[doc = "< Y 值"]
    pub y_value: libc::c_uchar,
    #[doc = "< U 值"]
    pub u_value: libc::c_uchar,
    #[doc = "< V 值"]
    pub v_value: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of color_value__bindgen_ty_2"]
        [::core::mem::size_of::<color_value__bindgen_ty_2>() - 3usize];
    ["Alignment of color_value__bindgen_ty_2"]
        [::core::mem::align_of::<color_value__bindgen_ty_2>() - 1usize];
    ["Offset of field: color_value__bindgen_ty_2::y_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_2, y_value) - 0usize];
    ["Offset of field: color_value__bindgen_ty_2::u_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_2, u_value) - 1usize];
    ["Offset of field: color_value__bindgen_ty_2::v_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_2, v_value) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of color_value"][::core::mem::size_of::<color_value>() - 3usize];
    ["Alignment of color_value"][::core::mem::align_of::<color_value>() - 1usize];
    ["Offset of field: color_value::argb"][::core::mem::offset_of!(color_value, argb) - 0usize];
    ["Offset of field: color_value::ayuv"][::core::mem::offset_of!(color_value, ayuv) - 0usize];
};
impl Default for color_value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 填充数据"]
pub type IMP_ISP_COLOR_VALUE = color_value;
#[doc = " 每个通道的填充属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct isp_mask_block_par {
    #[doc = "< 通道号(范围: 0~2)"]
    pub chx: u8,
    #[doc = "< 块号(范围: 0~3)"]
    pub pinum: u8,
    #[doc = "< 填充使能"]
    pub mask_en: u8,
    #[doc = "< 填充位置y坐标"]
    pub mask_pos_top: u16,
    #[doc = "< 填充位置x坐标"]
    pub mask_pos_left: u16,
    #[doc = "< 填充数据宽度"]
    pub mask_width: u16,
    #[doc = "< 填充数据高度"]
    pub mask_height: u16,
    #[doc = "< 填充数据类型"]
    pub mask_type: IMPISP_MASK_TYPE,
    #[doc = "< 填充数据值"]
    pub mask_value: IMP_ISP_COLOR_VALUE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_mask_block_par"][::core::mem::size_of::<isp_mask_block_par>() - 20usize];
    ["Alignment of isp_mask_block_par"][::core::mem::align_of::<isp_mask_block_par>() - 4usize];
    ["Offset of field: isp_mask_block_par::chx"]
        [::core::mem::offset_of!(isp_mask_block_par, chx) - 0usize];
    ["Offset of field: isp_mask_block_par::pinum"]
        [::core::mem::offset_of!(isp_mask_block_par, pinum) - 1usize];
    ["Offset of field: isp_mask_block_par::mask_en"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_en) - 2usize];
    ["Offset of field: isp_mask_block_par::mask_pos_top"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_pos_top) - 4usize];
    ["Offset of field: isp_mask_block_par::mask_pos_left"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_pos_left) - 6usize];
    ["Offset of field: isp_mask_block_par::mask_width"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_width) - 8usize];
    ["Offset of field: isp_mask_block_par::mask_height"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_height) - 10usize];
    ["Offset of field: isp_mask_block_par::mask_type"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_type) - 12usize];
    ["Offset of field: isp_mask_block_par::mask_value"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_value) - 16usize];
};
impl Default for isp_mask_block_par {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 每个通道的填充属性"]
pub type IMPISPMaskBlockAttr = isp_mask_block_par;
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetMaskBlock(IMPISPMaskBlockAttr *mask)\n\n 设置填充参数.\n\n @param[in] num   对应sensor的标号\n @param[in] mask  填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr block;\n\n if (en) {\n      block.chx = 0;\n      block.pinum = 0;\n      block.mask_en = 1;\n      block.mask_pos_top = 10;\n      block.mask_pos_left = 100;\n      block.mask_width = 200;\n      block.mask_height = 200;\n      block.mask_type = IMPISP_MASK_TYPE_YUV;\n      block.mask_value.ayuv.y_value = 100;\n      block.mask_value.ayuv.u_value = 100;\n      block.mask_value.ayuv.v_value = 100;\n } else {\n      block.mask_en = 0;\n }\n\n ret = IMP_ISP_Tuning_SetMaskBlock(&block);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetMaskBlock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMaskBlock(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetMaskBlock(IMPISPMaskBlockAttr *mask)\n\n 获取填充参数.\n\n @param[in] num   对应sensor的标号\n @param[out] mask 填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr attr;\n\n attr.chx = 0;\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetMaskBlock(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetMaskBlock error !\\n\");\n \treturn -1;\n }\n printf(\"chx:%d, pinum:%d, en:%d\\n\", attr.chx, attr.pinum, attr.mask_en);\n if (attr.mask_en) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMaskBlock(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
#[repr(u32)]
#[doc = " 填充图片格式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPPICTYPE {
    #[doc = "< ARGB8888"]
    IMP_ISP_PIC_ARGB_8888 = 0,
    #[doc = "< ARBG1555"]
    IMP_ISP_PIC_ARGB_1555 = 1,
    #[doc = "< AC 2bit"]
    IMP_ISP_PIC_ARGB_1100 = 2,
}
#[repr(u32)]
#[doc = " 填充格式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPARGBType {
    IMP_ISP_ARGB_TYPE_BGRA = 0,
    IMP_ISP_ARGB_TYPE_GBRA = 1,
    IMP_ISP_ARGB_TYPE_BRGA = 2,
    IMP_ISP_ARGB_TYPE_RBGA = 3,
    IMP_ISP_ARGB_TYPE_GRBA = 4,
    IMP_ISP_ARGB_TYPE_RGBA = 5,
    IMP_ISP_ARGB_TYPE_ABGR = 8,
    IMP_ISP_ARGB_TYPE_AGBR = 9,
    IMP_ISP_ARGB_TYPE_ABRG = 10,
    IMP_ISP_ARGB_TYPE_AGRB = 11,
    IMP_ISP_ARGB_TYPE_ARBG = 12,
    IMP_ISP_ARGB_TYPE_ARGB = 13,
}
#[doc = " 填充图片参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDBlockAttr {
    #[doc = "< 块号(范围: 0~7)"]
    pub pinum: u8,
    #[doc = "< 填充功能使能"]
    pub osd_enable: u8,
    #[doc = "< 填充横向起始点"]
    pub osd_left: u16,
    #[doc = "< 填充纵向起始点"]
    pub osd_top: u16,
    #[doc = "< 填充宽度"]
    pub osd_width: u16,
    #[doc = "< 填充高度"]
    pub osd_height: u16,
    #[doc = "< 填充图片首地址"]
    pub osd_image: *mut libc::c_char,
    #[doc = "< 填充图片的对其宽度, 以字节为单位，例如320x240的RGBA8888图片osd_stride=320*4"]
    pub osd_stride: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPOSDBlockAttr"][::core::mem::size_of::<IMPISPOSDBlockAttr>() - 20usize];
    ["Alignment of IMPISPOSDBlockAttr"][::core::mem::align_of::<IMPISPOSDBlockAttr>() - 4usize];
    ["Offset of field: IMPISPOSDBlockAttr::pinum"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, pinum) - 0usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_enable"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_enable) - 1usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_left"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_left) - 2usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_top"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_top) - 4usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_width"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_width) - 6usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_height"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_height) - 8usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_image"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_image) - 12usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_stride"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_stride) - 16usize];
};
impl Default for IMPISPOSDBlockAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 填充功能通道属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDAttr {
    #[doc = "< 填充图片类型"]
    pub osd_type: IMPISPPICTYPE,
    #[doc = "< 填充格式"]
    pub osd_argb_type: IMPISPARGBType,
    #[doc = "< 填充像素Alpha禁用功能使能"]
    pub osd_pixel_alpha_disable: IMPISPTuningOpsMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPOSDAttr"][::core::mem::size_of::<IMPISPOSDAttr>() - 12usize];
    ["Alignment of IMPISPOSDAttr"][::core::mem::align_of::<IMPISPOSDAttr>() - 4usize];
    ["Offset of field: IMPISPOSDAttr::osd_type"]
        [::core::mem::offset_of!(IMPISPOSDAttr, osd_type) - 0usize];
    ["Offset of field: IMPISPOSDAttr::osd_argb_type"]
        [::core::mem::offset_of!(IMPISPOSDAttr, osd_argb_type) - 4usize];
    ["Offset of field: IMPISPOSDAttr::osd_pixel_alpha_disable"]
        [::core::mem::offset_of!(IMPISPOSDAttr, osd_pixel_alpha_disable) - 8usize];
};
impl Default for IMPISPOSDAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDAttr(IMPISPOSDAttr *attr)\n\n 设置填充参数.\n\n @param[in] num   对应sensor的标号\n @param[in] attr  填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n attr.osd_type = IMP_ISP_PIC_ARGB_8888;\n attr.osd_argb_type = IMP_ISP_ARGB_TYPE_BGRA;\n attr.osd_pixel_alpha_disable = IMPISP_TUNING_OPS_MODE_ENABLE;\n\n if(ret){\n \tIMP_LOG_ERR(TAG, \" error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetOSDAttr(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDAttr(IMPISPOSDAttr *attr)\n\n 获取填充参数.\n\n @param[in] num   对应sensor的标号\n @param[out] attr  填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n ret = IMP_ISP_Tuning_GetOSDAttr(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDAttr error !\\n\");\n \treturn -1;\n }\n printf(\"type:%d, argb_type:%d, mode:%d\\n\", attr.osd_type,\n attr.osd_argb_type, attr.osd_pixel_alpha_disable);\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetOSDAttr(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDBlock(IMPISPOSDBlockAttr *attr)\n\n 设置OSD参数.\n\n @param[in] num   对应sensor的标号\n @param[in] attr  OSD参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr block;\n\n block.pinum = pinum;\n block.osd_enable = enable;\n block.osd_left = left / 2 * 2;\n block.osd_top = top / 2 * 2;\n block.osd_width = width;\n block.osd_height = height;\n block.osd_image = image;\n block.osd_stride = stride;\n\n ret = IMP_ISP_Tuning_SetOSDBlock(&block);\n if(ret){\n \timp_log_err(tag, \"imp_isp_tuning_setosdblock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetOSDBlock(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDBlock(IMPISPOSDBlockAttr *attr)\n\n 获取OSD参数.\n\n @param[in] num   对应sensor的标号\n @param[out] attr OSD参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetOSDBlock(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, en:%d\\n\", attr.pinum, attr.osd_enable);\n if (attr.osd_enable) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetOSDBlock(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
#[doc = " 画窗功能属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawWindAttr {
    #[doc = "< 画窗功能使能"]
    pub enable: u8,
    #[doc = "< 画窗功能横向起始点"]
    pub left: u16,
    #[doc = "< 画窗功能纵向起始点"]
    pub top: u16,
    #[doc = "< 画窗宽度"]
    pub width: u16,
    #[doc = "< 画窗高度"]
    pub height: u16,
    #[doc = "< 画窗颜色"]
    pub color: IMP_ISP_COLOR_VALUE,
    #[doc = "< 窗口边框宽度"]
    pub line_width: u8,
    #[doc = "< 宽口边框alpha（3bit）"]
    pub alpha: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawWindAttr"][::core::mem::size_of::<IMPISPDrawWindAttr>() - 16usize];
    ["Alignment of IMPISPDrawWindAttr"][::core::mem::align_of::<IMPISPDrawWindAttr>() - 2usize];
    ["Offset of field: IMPISPDrawWindAttr::enable"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, enable) - 0usize];
    ["Offset of field: IMPISPDrawWindAttr::left"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, left) - 2usize];
    ["Offset of field: IMPISPDrawWindAttr::top"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, top) - 4usize];
    ["Offset of field: IMPISPDrawWindAttr::width"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, width) - 6usize];
    ["Offset of field: IMPISPDrawWindAttr::height"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, height) - 8usize];
    ["Offset of field: IMPISPDrawWindAttr::color"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, color) - 10usize];
    ["Offset of field: IMPISPDrawWindAttr::line_width"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, line_width) - 13usize];
    ["Offset of field: IMPISPDrawWindAttr::alpha"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, alpha) - 14usize];
};
impl Default for IMPISPDrawWindAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 画四角窗功能属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawRangAttr {
    #[doc = "< 画四角窗功能使能"]
    pub enable: u8,
    #[doc = "< 画四角窗功能横向起始点"]
    pub left: u16,
    #[doc = "< 画四角窗功能纵向起始点"]
    pub top: u16,
    #[doc = "< 画四角窗宽度"]
    pub width: u16,
    #[doc = "< 画四角窗高度"]
    pub height: u16,
    #[doc = "< 画四角窗颜色"]
    pub color: IMP_ISP_COLOR_VALUE,
    #[doc = "< 画四角窗边框宽度"]
    pub line_width: u8,
    #[doc = "< 四角窗边框alpha （3bit）"]
    pub alpha: u8,
    #[doc = "< 四角窗边框长度"]
    pub extend: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawRangAttr"][::core::mem::size_of::<IMPISPDrawRangAttr>() - 18usize];
    ["Alignment of IMPISPDrawRangAttr"][::core::mem::align_of::<IMPISPDrawRangAttr>() - 2usize];
    ["Offset of field: IMPISPDrawRangAttr::enable"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, enable) - 0usize];
    ["Offset of field: IMPISPDrawRangAttr::left"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, left) - 2usize];
    ["Offset of field: IMPISPDrawRangAttr::top"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, top) - 4usize];
    ["Offset of field: IMPISPDrawRangAttr::width"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, width) - 6usize];
    ["Offset of field: IMPISPDrawRangAttr::height"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, height) - 8usize];
    ["Offset of field: IMPISPDrawRangAttr::color"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, color) - 10usize];
    ["Offset of field: IMPISPDrawRangAttr::line_width"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, line_width) - 13usize];
    ["Offset of field: IMPISPDrawRangAttr::alpha"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, alpha) - 14usize];
    ["Offset of field: IMPISPDrawRangAttr::extend"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, extend) - 16usize];
};
impl Default for IMPISPDrawRangAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 画线功能属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawLineAttr {
    #[doc = "< 画线功能使能"]
    pub enable: u8,
    #[doc = "< 画线横向起始点"]
    pub startx: u16,
    #[doc = "< 画线纵向起始点"]
    pub starty: u16,
    #[doc = "< 画线横向结束点"]
    pub endx: u16,
    #[doc = "< 画线纵向结束点"]
    pub endy: u16,
    #[doc = "< 线条颜色"]
    pub color: IMP_ISP_COLOR_VALUE,
    #[doc = "< 线宽"]
    pub width: u8,
    #[doc = "< 线条Alpha值"]
    pub alpha: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawLineAttr"][::core::mem::size_of::<IMPISPDrawLineAttr>() - 16usize];
    ["Alignment of IMPISPDrawLineAttr"][::core::mem::align_of::<IMPISPDrawLineAttr>() - 2usize];
    ["Offset of field: IMPISPDrawLineAttr::enable"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, enable) - 0usize];
    ["Offset of field: IMPISPDrawLineAttr::startx"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, startx) - 2usize];
    ["Offset of field: IMPISPDrawLineAttr::starty"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, starty) - 4usize];
    ["Offset of field: IMPISPDrawLineAttr::endx"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, endx) - 6usize];
    ["Offset of field: IMPISPDrawLineAttr::endy"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, endy) - 8usize];
    ["Offset of field: IMPISPDrawLineAttr::color"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, color) - 10usize];
    ["Offset of field: IMPISPDrawLineAttr::width"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, width) - 13usize];
    ["Offset of field: IMPISPDrawLineAttr::alpha"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, alpha) - 14usize];
};
impl Default for IMPISPDrawLineAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " 画图功能类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPDrawType {
    #[doc = "< 画框"]
    IMP_ISP_DRAW_WIND = 0,
    #[doc = "< 画四角窗"]
    IMP_ISP_DRAW_RANGE = 1,
    #[doc = "< 画线"]
    IMP_ISP_DRAW_LINE = 2,
}
#[doc = " 画图功能属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawBlockAttr {
    #[doc = "< 块号(范围: 0~19)"]
    pub pinum: u8,
    #[doc = "< 画图类型"]
    pub type_: IMPISPDrawType,
    #[doc = "< 填充数据类型"]
    pub color_type: IMPISP_MASK_TYPE,
    #[doc = "< 画图属性"]
    pub cfg: IMPISPDrawBlockAttr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPISPDrawBlockAttr__bindgen_ty_1 {
    #[doc = "< 画框属性"]
    pub wind: IMPISPDrawWindAttr,
    #[doc = "< 画四角窗属性"]
    pub rang: IMPISPDrawRangAttr,
    #[doc = "< 画线属性"]
    pub line: IMPISPDrawLineAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawBlockAttr__bindgen_ty_1"]
        [::core::mem::size_of::<IMPISPDrawBlockAttr__bindgen_ty_1>() - 18usize];
    ["Alignment of IMPISPDrawBlockAttr__bindgen_ty_1"]
        [::core::mem::align_of::<IMPISPDrawBlockAttr__bindgen_ty_1>() - 2usize];
    ["Offset of field: IMPISPDrawBlockAttr__bindgen_ty_1::wind"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr__bindgen_ty_1, wind) - 0usize];
    ["Offset of field: IMPISPDrawBlockAttr__bindgen_ty_1::rang"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr__bindgen_ty_1, rang) - 0usize];
    ["Offset of field: IMPISPDrawBlockAttr__bindgen_ty_1::line"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr__bindgen_ty_1, line) - 0usize];
};
impl Default for IMPISPDrawBlockAttr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawBlockAttr"][::core::mem::size_of::<IMPISPDrawBlockAttr>() - 32usize];
    ["Alignment of IMPISPDrawBlockAttr"][::core::mem::align_of::<IMPISPDrawBlockAttr>() - 4usize];
    ["Offset of field: IMPISPDrawBlockAttr::pinum"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, pinum) - 0usize];
    ["Offset of field: IMPISPDrawBlockAttr::type_"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, type_) - 4usize];
    ["Offset of field: IMPISPDrawBlockAttr::color_type"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, color_type) - 8usize];
    ["Offset of field: IMPISPDrawBlockAttr::cfg"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, cfg) - 12usize];
};
impl Default for IMPISPDrawBlockAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDrawBlock(IMPISPDrawBlockAttr *attr)\n\n 设置绘图功能参数.\n\n @param[in] num   对应sensor的标号\n @param[in] attr  绘图功能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)2;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.line.enable = en;\n block.cfg.line.startx = left / 2 * 2;\n block.cfg.line.starty = top / 2 * 2;\n block.cfg.line.endx = w / 2 * 2;\n block.cfg.line.endy = h / 2 * 2;\n block.cfg.line.color.ayuv.y_value = y;\n block.cfg.line.color.ayuv.u_value = u;\n block.cfg.line.color.ayuv.v_value = v;\n block.cfg.line.width = lw / 2 * 2;\n block.cfg.line.alpha = alpha;\n IMP_ISP_Tuning_SetDrawBlock(&block);\n\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)0;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.wind.enable = en;\n block.cfg.wind.left = left / 2 * 2;\n block.cfg.wind.top = top / 2 * 2;\n block.cfg.wind.width = w / 2 * 2;\n block.cfg.wind.height = h / 2 * 2;\n block.cfg.wind.color.ayuv.y_value = y;\n block.cfg.wind.color.ayuv.u_value = u;\n block.cfg.wind.color.ayuv.v_value = v;\n block.cfg.wind.line_width = lw / 2 * 2;\n block.cfg.wind.alpha = alpha;\n\n IMP_ISP_Tuning_SetDrawBlock(&block);\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)1;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.rang.enable = en;\n block.cfg.rang.left = left / 2 * 2;\n block.cfg.rang.top = top / 2 * 2;\n block.cfg.rang.width = w / 2 * 2;\n block.cfg.rang.height = h / 2 * 2;\n block.cfg.rang.color.ayuv.y_value = y;\n block.cfg.rang.color.ayuv.u_value = u;\n block.cfg.rang.color.ayuv.v_value = v;\n block.cfg.rang.line_width = lw / 2 * 2;\n block.cfg.rang.alpha = alpha;\n block.cfg.rang.extend = extend / 2 * 2;\n\n IMP_ISP_Tuning_SetDrawBlock(&block);\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDrawBlock(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDrawBlock(IMPISPDrawBlockAttr *attr)\n\n 获取绘图功能参数.\n\n @param[in] num   对应sensor的标号\n @param[out] attr  绘图功能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPDrawBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetDrawBlock(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetDrawBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, type:%d, color type:%d\\n\", attr.pinum, attr.type, attr.color_type);\n switch (attr.type) {\n      case IMP_ISP_DRAW_WIND:\n          printf(\"enable:%d\\n\", attr.wind.enable);\n          if (attr.wind.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_RANGE:\n          printf(\"enable:%d\\n\", attr.rang.enable);\n          if (attr.rang.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_LINE:\n          printf(\"enable:%d\\n\", attr.line.enable);\n          if (attr.line.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      default:\n          break;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDrawBlock(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetDefaultBinPath_Sec(char *path)\n\n 设置ISP bin文件默认路径\n\n @param[in] path  需要设置的bin文件路径\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 设置用户自定义ISP启动时Bin文件的绝对路径。\n\n @attention 这个函数必须在添加sensor之前、打开ISP之后被调用。"]
    pub fn IMP_ISP_SetDefaultBinPath_Sec(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetDefaultBinPath_Sec(char *path)\n\n 获取ISP bin文件默认路径\n\n @param[out] path\t需要获取的bin文件路径\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 获取用户自定义ISP启动时Bin文件的绝对路径。\n\n @attention 这个函数必须在添加sensor之后被调用。\n @attention 一次只能获取单个ISP的bin文件路径属性。"]
    pub fn IMP_ISP_GetDefaultBinPath_Sec(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_SetSensorRegister_Sec(uint32_t reg, uint32_t value)\n\n 设置sensor一个寄存器的值\n\n @param[in] reg 寄存器地址\n\n @param[in] value 寄存器值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 可以直接设置一个sensor寄存器的值。\n\n @attention 在使用这个函数之前，必须保证摄像头已经被使能."]
    pub fn IMP_ISP_SetSensorRegister_Sec(reg: u32, value: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_GetSensorRegister_Sec(uint32_t reg, uint32_t *value)\n\n 获取sensor一个寄存器的值\n\n @param[in] reg 寄存器地址\n\n @param[in] value 寄存器值的指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 可以直接获取一个sensor寄存器的值。\n\n @attention 在使用这个函数之前，必须保证摄像头已经被使能."]
    pub fn IMP_ISP_GetSensorRegister_Sec(reg: u32, value: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSensorFPS_Sec(uint32_t fps_num, uint32_t fps_den)\n\n 设置摄像头输出帧率\n\n @param[in] fps_num 设定帧率的分子参数\n @param[in] fps_den 设定帧率的分母参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor 和 IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSensorFPS_Sec(fps_num: u32, fps_den: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorFPS_Sec(uint32_t *fps_num, uint32_t *fps_den)\n\n 获取摄像头输出帧率\n\n @param[in] fps_num 获取帧率分子参数的指针\n @param[in] fps_den 获取帧率分母参数的指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor 和 IMP_ISP_EnableTuning已被调用。\n @attention 在使能帧通道开始传输数据之前必须先调用此函数获取摄像头默认帧率。"]
    pub fn IMP_ISP_Tuning_GetSensorFPS_Sec(fps_num: *mut u32, fps_den: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAntiFlickerAttr_Sec(IMPISPAntiflickerAttr attr)\n\n 设置ISP抗闪频属性\n\n @param[in] attr 设置参数值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetAntiFlickerAttr_Sec(attr: IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAntiFlickerAttr_Sec(IMPISPAntiflickerAttr *pattr)\n\n 获得ISP抗闪频属性\n\n @param[in] pattr 获取参数值指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetAntiFlickerAttr_Sec(pattr: *mut IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBrightness_Sec(unsigned char bright)\n\n 设置ISP 综合效果图片亮度\n\n @param[in] bright 图片亮度参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加亮度，小于128降低亮度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetBrightness_Sec(bright: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBrightness_Sec(unsigned char *pbright)\n\n 获取ISP 综合效果图片亮度\n\n @param[in] bright 图片亮度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加亮度，小于128降低亮度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetBrightness_Sec(pbright: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetContrast_Sec(unsigned char contrast)\n\n 设置ISP 综合效果图片对比度\n\n @param[in] contrast 图片对比度参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加对比度，小于128降低对比度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetContrast_Sec(contrast: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetContrast_Sec(unsigned char *pcontrast)\n\n 获取ISP 综合效果图片对比度\n\n @param[in] contrast 图片对比度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加对比度，小于128降低对比度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetContrast_Sec(pcontrast: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSharpness_Sec(unsigned char sharpness)\n\n 设置ISP 综合效果图片锐度\n\n @param[in] sharpness 图片锐度参数值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加锐度，小于128降低锐度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetSharpness_Sec(sharpness: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSharpness_Sec(unsigned char *psharpness)\n\n 获取ISP 综合效果图片锐度\n\n @param[in] sharpness 图片锐度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加锐度，小于128降低锐度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetSharpness_Sec(psharpness: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBcshHue_Sec(unsigned char hue)\n\n 设置图像的色调\n\n @param[in] hue 图像的色调参考值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128正向调节色调，小于128反向调节色调，调节范围0~255。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetBcshHue_Sec(hue: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBcshHue_Sec(unsigned char *hue)\n\n 获取图像的色调值。\n\n @param[out] hue 图像的色调参数指针。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128代表正向调节色调，小于128代表反向调节色调，范围0~255。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetBcshHue_Sec(hue: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSaturation_Sec(unsigned char sat)\n\n 设置ISP 综合效果图片饱和度\n\n @param[in] sat 图片饱和度参数值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加饱和度，小于128降低饱和度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetSaturation_Sec(sat: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSaturation_Sec(unsigned char *psat)\n\n 获取ISP 综合效果图片饱和度\n\n @param[in] sat 图片饱和度参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 默认值为128，大于128增加饱和度，小于128降低饱和度。\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_GetSaturation_Sec(psat: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetTotalGain_Sec(uint32_t *gain)\n\n 获取ISP输出图像的整体增益值\n\n @param[in] gain 获取增益值参数的指针,其数据存放格式为[24.8]，高24bit为整数，低8bit为小数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor 和 IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetTotalGain_Sec(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " 设置ISP图像镜面效果功能是否使能\n\n @fn int IMP_ISP_Tuning_SetISPHflip_Sec(IMPISPTuningOpsMode mode)\n\n @param[in] mode 是否使能镜面效果\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPHflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPHflip_Sec(IMPISPTuningOpsMode *pmode)\n\n 获取ISP图像镜面效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPHflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip_Sec(IMPISPTuningOpsMode mode)\n\n 设置ISP图像上下反转效果功能是否使能\n\n @param[in] mode 是否使能图像上下反转\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPVflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPVflip_Sec(IMPISPTuningOpsMode *pmode)\n\n 获取ISP图像上下反转效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPVflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " 设置Sensor图像镜面效果功能是否使能\n\n @fn int IMP_ISP_Tuning_SetSensorHflip_Sec(IMPISPTuningOpsMode mode)\n\n @param[in] mode 是否使能镜面效果\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSensorHflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorHflip_Sec(IMPISPTuningOpsMode *pmode)\n\n 获取Sensor图像镜面效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetSensorHflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip_Sec(IMPISPTuningOpsMode mode)\n\n 设置Sensor图像上下反转效果功能是否使能\n\n @param[in] mode 是否使能图像上下反转\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSensorVflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorVflip_Sec(IMPISPTuningOpsMode *pmode)\n\n 获取Sensor图像上下反转效果功能的操作状态\n\n @param[in] pmode 操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetSensorVflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPRunningMode_Sec(IMPISPRunningMode mode)\n\n 设置ISP工作模式，正常模式或夜视模式；默认为正常模式。\n\n @param[in] mode运行模式参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n 示例：\n @code\n IMPISPRunningMode mode;\n\n\tif( it is during a night now){\nmode = IMPISP_RUNNING_MODE_NIGHT\n}else{\nmode = IMPISP_RUNNING_MODE_DAY;\n}\nret = IMP_ISP_Tuning_SetISPRunningMode_Sec(mode);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetISPRunningMode error !\\n\");\nreturn -1;\n}\n\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPRunningMode_Sec(mode: IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPRunningMode_Sec(IMPISPRunningMode *pmode)\n\n 获取ISP工作模式，正常模式或夜视模式。\n\n @param[in] pmode操作参数指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPRunningMode_Sec(pmode: *mut IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPCustomMode_Sec(IMPISPTuningOpsMode mode)\n\n 使能ISP Custom Mode，加载另外一套效果参数.\n\n @param[in] mode Custom 模式，使能或者关闭\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetISPCustomMode_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPCustomMode_Sec(IMPISPTuningOpsMode mode)\n\n 获取ISP Custom Mode的状态.\n\n @param[out] mode Custom 模式，使能或者关闭\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetISPCustomMode_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetGamma_Sec(IMPISPGamma *gamma)\n\n 设置GAMMA参数.\n @param[in] gamma gamma参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetGamma_Sec(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetGamma_Sec(IMPISPGamma *gamma)\n\n 获取GAMMA参数.\n @param[out] gamma gamma参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetGamma_Sec(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeComp_Sec(int comp)\n\n 设置AE补偿。AE补偿参数可以调整图像AE target，范围为[0-255].\n @param[in] comp AE补偿参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeComp_Sec(comp: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeComp_Sec(int *comp)\n\n 获取AE补偿。\n @param[out] comp AE补偿参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeComp_Sec(comp: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeLuma_Sec(int *luma)\n\n 获取画面平均亮度。\n\n @param[out] luma AE亮度参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeLuma_Sec(luma: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeFreeze_Sec(IMPISPTuningOpsMode mode)\n\n 使能AE Freeze功能.\n\n @param[in] mode AE Freeze功能使能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeFreeze_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetExpr_Sec(IMPISPExpr *expr)\n\n 设置AE参数。\n\n @param[in] expr AE参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetExpr_Sec(expr: *mut IMPISPExpr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetExpr_Sec(IMPISPExpr *expr)\n\n 获取AE参数。\n\n @param[out] expr AE参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetExpr_Sec(expr: *mut IMPISPExpr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_Sec(IMPISPWB *wb)\n\n 设置白平衡功能设置。可以设置自动与手动模式，手动模式主要通过设置rgain、bgain实现。\n\n @param[in] wb 设置的白平衡参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetWB_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetWB_Sec(IMPISPWB *wb)\n\n 获取白平衡功能设置。\n\n @param[out] wb 获取的白平衡参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetWB_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_Statis_Sec(IMPISPWB *wb)\n\n 获取白平衡统计值。\n\n @param[out] wb 获取的白平衡统计值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetWB_Statis_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_GOL_Statis_Sec(IMPISPWB *wb)\n\n 获取白平衡全局统计值。\n\n @param[out] wb 获取的白平衡全局统计值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetWB_GOL_Statis_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbClust_Sec(IMPISPAWBCluster *awb_cluster);\n\n 设置CLuster AWB模式的参数。\n\n @param[in] CLuster AWB 模式的参数，包括使能、阈值等，awb_cluster[]设置，请咨询Tuning人员。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbClust_Sec(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbClust_Sec(IMPISPAWBCluster *awb_cluster)\n\n 获取CLuster AWB模式下的参数。\n\n @param[out] CLuster AWB 模式的参数，包括使能、阈值等。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbClust_Sec(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbCtTrend_Sec(IMPISPAWBCtTrend *ct_trend);\n\n 通过rgain与bgain的offset，设置不同色温下的色温偏向。\n\n @param[in] ct_trend 包含高中低三个色温下的rgain、bgain offset\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbCtTrend_Sec(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_GetAwbCtTrend_Sec(IMPISPAWBCtTrend *ct_trend);\n\n 获取不同色温下的色温偏向，即rgain offset与bgain offset，\n\n @param[out] ct_trend 包含高中低三个色温下的rgain、bgain offset\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbCtTrend_Sec(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_GetRgbCoefft_Sec(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n 获取sensor AWB RGB通道偏移参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_Awb_GetRgbCoefft_Sec(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_SetRgbCoefft_Sec(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n 设置sensor可以设置AWB RGB通道偏移参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。\n\n 示例：\n @code\n IMPISPCOEFFTWB isp_core_rgb_coefft_wb_attr;\n\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_r=x;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_g=y;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_b=z;\nIMP_ISP_Tuning_Awb_SetRgbCoefft_Sec(&isp_core_rgb_coefft_wb_attr);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_Awb_SetRgbCoefft error !\\n\");\nreturn -1;\n}"]
    pub fn IMP_ISP_Tuning_Awb_SetRgbCoefft_Sec(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxAgain_Sec(uint32_t gain)\n\n 设置sensor可以设置最大Again。\n\n @param[in] gain sensor可以设置的最大again.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMaxAgain_Sec(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxAgain_Sec(uint32_t *gain)\n\n 获取sensor可以设置最大Again。\n\n @param[out] gain sensor可以设置的最大again.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMaxAgain_Sec(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxDgain_Sec(uint32_t gain)\n\n 设置ISP可以设置的最大Dgain。\n\n @param[in] ISP Dgain 可以设置的最大dgain.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMaxDgain_Sec(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxDgain_Sec(uint32_t *gain)\n\n 获取ISP设置的最大Dgain。\n\n @param[out] ISP Dgain 可以得到设置的最大的dgain.0表示1x，32表示2x，依次类推。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMaxDgain_Sec(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHiLightDepress_Sec(uint32_t strength)\n\n 设置强光抑制强度。\n\n @param[in] strength 强光抑制强度参数.取值范围为［0-10], 0表示关闭功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetHiLightDepress_Sec(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHiLightDepress_Sec(uint32_t *strength)\n\n 获取强光抑制的强度。\n\n @param[out] strength 可以得到设置的强光抑制的强度.0表示关闭此功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetHiLightDepress_Sec(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBacklightComp_Sec(uint32_t strength)\n\n 设置背光补偿强度。\n\n @param[in] strength 背光补偿强度参数.取值范围为［0-10], 0表示关闭功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetBacklightComp_Sec(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBacklightComp_Sec(uint32_t *strength)\n\n 获取背光补偿的强度。\n\n @param[out] strength 可以得到设置的背光补偿的强度.0表示关闭此功能。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetBacklightComp_Sec(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetTemperStrength_Sec(uint32_t ratio)\n\n 设置3D降噪强度。\n\n @param[in] ratio 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]. *\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetTemperStrength_Sec(ratio: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSinterStrength_Sec(uint32_t ratio)\n\n 设置2D降噪强度。\n\n @param[in] ratio 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255].\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetSinterStrength_Sec(ratio: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetEVAttr_Sec(IMPISPEVAttr *attr)\n\n 获取EV属性。\n @param[out] attr EV属性参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetEVAttr_Sec(attr: *mut IMPISPEVAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableMovestate_Sec(void)\n\n 当sensor在运动时，设置ISP进入运动态。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_EnableMovestate_Sec() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_DisableMovestate_Sec(void)\n\n 当sensor从运动态恢复为静止态，设置ISP不使能运动态。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_Tuning_EnableMovestate已被调用。"]
    pub fn IMP_ISP_Tuning_DisableMovestate_Sec() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeWeight_Sec(IMPISPWeight *ae_weight)\n\n 设置AE统计区域的权重。\n\n @param[in] ae_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeWeight_Sec(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeWeight_Sec(IMPISPWeight *ae_weight)\n\n 获取AE统计区域的权重。\n\n @param[out] ae_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeWeight_Sec(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_GetROI_Sec(IMPISPWeight *roi_weight)\n\n 获取AE感兴趣区域，用于场景判断。\n\n @param[out] roi_weight AE感兴趣区域权重。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_AE_GetROI_Sec(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_SetROI_Sec(IMPISPWeight *roi_weight)\n\n 获取AE感兴趣区域，用于场景判断。\n\n @param[in] roi_weight AE感兴趣区域权重。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_AE_SetROI_Sec(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbWeight_Sec(IMPISPWeight *awb_weight)\n\n 设置AWB统计区域的权重。\n\n @param[in] awb_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbWeight_Sec(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbWeight_Sec(IMPISPWeight *awb_weight)\n\n 获取AWB统计区域的权重。\n\n @param[out] awb_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbWeight_Sec(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbZone_Sec(IMPISPAWBZONE *awb_zone)\n\n 获取WB在每个块，不同通道的统计平均值。\n\n @param[out] awb_zone 白平衡统计信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbZone_Sec(awb_zone: *mut IMPISPAWBZone) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_ALGO_Sec(IMPISPAWBALGO wb_algo)\n\n 设置AWB统计的模式。\n\n @param[in] wb_algo AWB统计的不同模式。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetWB_ALGO_Sec(wb_algo: IMPISPAWBAlgo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeHist_Sec(IMPISPAEHist *ae_hist)\n\n 设置AE统计相关参数。\n\n @param[in] ae_hist AE统计相关参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeHist_Sec(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Sec(IMPISPAEHist *ae_hist)\n\n 获取AE统计值。\n\n @param[out] ae_hist AE统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeHist_Sec(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Origin_Sec(IMPISPAEHistOrigin *ae_hist)\n\n 获取AE 256 bin统计值。\n\n @param[out] ae_hist AE统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeHist_Origin_Sec(ae_hist: *mut IMPISPAEHistOrigin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbHist_Sec(IMPISPAWBHist *awb_hist)\n\n 获取AWB统计值。\n\n @param[out] awb_hist AWB统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAwbHist_Sec(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbHist_Sec(IMPISPAWBHist *awb_hist)\n\n 设置AWB统计相关参数。\n\n @param[in] awb_hist AWB统计相关参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbHist_Sec(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetAFMetrices_Sec(unsigned int *metric);\n\n 获取AF统计值。\n\n @param[out] metric AF统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAFMetrices_Sec(metric: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfHist_Sec(IMPISPAFHist *af_hist);\n\n 获取AF统计值。\n\n @param[out] af_hist AF统计值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAfHist_Sec(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfHist_Sec(IMPISPAFHist *af_hist)\n\n 设置AF统计相关参数。\n\n @param[in] af_hist AF统计相关参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAfHist_Sec(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfWeight_Sec(IMPISPWeight *af_weight)\n\n 设置AF统计区域的权重。\n\n @param[in] af_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAfWeight_Sec(af_weigh: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfWeight_Sec(IMPISPWeight *af_weight)\n\n 获取AF统计区域的权重。\n\n @param[out] af_weight 各区域权重信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAfWeight_Sec(af_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfZone_Sec(IMPISPZone *af_zone)\n\n 获取AF各个zone的统计值。\n\n @param[out] af_zone AF各个区域的统计值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAfZone_Sec(af_zone: *mut IMPISPZone) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_WaitFrame_Sec(IMPISPWaitFrameAttr *attr)\n 等待帧结束\n\n @param[out] attr 等待帧结束属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_WaitFrame_Sec(attr: *mut IMPISPWaitFrameAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeMin_Sec(IMPISPAEMin *ae_min)\n\n 设置AE最小值参数。\n\n @param[in] ae_min AE最小值参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeMin_Sec(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeMin_Sec(IMPISPAEMin *ae_min)\n\n 获取AE最小值参数。\n\n @param[out] ae_min AE最小值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeMin_Sec(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAe_IT_MAX_Sec(unsigned int it_max)\n\n 设置AE最大值参数。\n\n @param[in] it_max AE最大值参数。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAe_IT_MAX_Sec(it_max: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAE_IT_MAX_Sec(unsigned int *it_max)\n\n 获取AE最大值参数。\n\n @param[out] it_max AE最大值信息。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAE_IT_MAX_Sec(it_max: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeZone_Sec(IMPISPZone *ae_zone)\n\n 获取AE各个zone的Y值。\n\n @param[out] ae_zone AE各个区域的Y值。\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeZone_Sec(ae_zone: *mut IMPISPZone) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList_Sec(IMPISPAETargetList *target_list)\n\n 设置AE的目标亮度表\n\n @param[in] target_list  目标亮度表\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeTargetList_Sec(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList_Sec(IMPISPAETargetList *target_list)\n\n 获取AE当前的目标亮度表\n\n @param[out] target_list  目标亮度表\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeTargetList_Sec(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetModuleControl_Sec(IMPISPModuleCtl *ispmodule)\n\n 设置ISP各个模块bypass功能\n\n @param[in] ispmodule ISP各个模块bypass功能.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetModuleControl_Sec(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetModuleControl_Sec(IMPISPModuleCtl *ispmodule)\n\n 获取ISP各个模块bypass功能.\n\n @param[out] ispmodule ISP各个模块bypass功能\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetModuleControl_Sec(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetFrontCrop_Sec(IMPISPFrontCrop *ispfrontcrop)\n\n 设置ISP前Crop的位置\n\n @param[in] ispfrontcrop 前Crop参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetFrontCrop_Sec(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetFrontCrop_Sec(IMPISPFrontCrop *ispfrontcrop)\n\n 获取前Crop参数.\n\n @param[out] ispfrontcrop 前Crop参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetFrontCrop_Sec(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDPC_Strength_Sec(unsigned int strength)\n\n 设置DPC强度.\n\n @param[in] strength 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDPC_Strength_Sec(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDPC_Strength_Sec(unsigned int *strength)\n\n 获取DPC强度.\n\n @param[out] strength 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDPC_Strength_Sec(ratio: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDRC_Strength_Sec(unsigned int ratio)\n\n 设置DRC强度值.\n\n @param[in] strength 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDRC_Strength_Sec(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDRC_Strength_Sec(unsigned int *ratio)\n\n 获取DRC强度值.\n\n @param[out] ratio 强度调节比例.默认值为128,如果设置大于128则增加强度，小于128降低强度.取值范围为［0-255]\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDRC_Strength_Sec(ratio: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHVFLIP_Sec(IMPISPHVFLIP hvflip)\n\n 设置HV Flip的模式.\n\n @param[in] hvflip HV Flip模式.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetHVFLIP_Sec(hvflip: IMPISPHVFLIP) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHVFlip_Sec(IMPISPHVFLIP *hvflip)\n\n 获取HV Flip的模式.\n\n @param[out] hvflip HV Flip模式.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetHVFlip_Sec(hvflip: *mut IMPISPHVFLIP) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMask_Sec(IMPISPMASKAttr *mask)\n\n 设置填充参数.\n\n @param[in] mask 填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMask_Sec(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMask_Sec(IMPISPMASKAttr *mask)\n\n 获取填充参数.\n\n @param[out] mask 填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMask_Sec(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorAttr_Sec(IMPISPSENSORAttr *attr)\n\n 获取填充参数.\n\n @param[out] attr sensor属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetSensorAttr_Sec(attr: *mut IMPISPSENSORAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDRC_Sec(IMPISPTuningOpsMode mode)\n\n 使能DRC功能.\n\n @param[out] mode DRC功能使能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_EnableDRC_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDefog_Sec(IMPISPTuningOpsMode mode)\n\n 使能Defog功能.\n\n @param[out] mode Defog功能使能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_EnableDefog_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbCt_Sec(unsigned int *ct)\n\n 设置AWB色温值.\n\n @param[in] ct AWB色温值.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAwbCt_Sec(ct: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAWBCt_Sec(unsigned int *ct)\n\n 获取AWB色温值.\n\n @param[out] ct AWB色温值.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAWBCt_Sec(ct: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetCCMAttr_Sec(IMPISPCCMAttr *ccm)\n\n 设置CCM属性.\n\n @param[in] ccm CCM属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetCCMAttr_Sec(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetCCMAttr_Sec(IMPISPCCMAttr *ccm)\n\n 获取CCM属性.\n\n @param[out] ccm CCM属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetCCMAttr_Sec(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeAttr_Sec(IMPISPAEAttr *ae)\n\n 设置AE手动模式属性.\n\n @param[in] ae AE手动模式属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetAeAttr_Sec(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeAttr_Sec(IMPISPAEAttr *ae)\n\n 获取AE手动模式属性.\n\n @param[out] ae AE手动模式属性参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。\n @attention 在使用这个函数之前，需要先将IMPISPAEAttr结构体初始化为0，然后配置相应的属性。"]
    pub fn IMP_ISP_Tuning_GetAeAttr_Sec(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeState_Sec(IMPISPAEState *ae_state)\n\n 获取AE收敛相关的状态参数.\n\n @param[out] ae AE的收敛状态.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetAeState_Sec(ae_state: *mut IMPISPAEState) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetScalerLv_Sec(IMPISPScalerLv *scaler_level)\n\n Set Scaler 缩放的方法及等级.\n\n @param[in] mscaler 参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证ISP效果调试功能已使能."]
    pub fn IMP_ISP_Tuning_SetScalerLv_Sec(scaler_level: *mut IMPISPScalerLv) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBlcAttr_Sec(IMPISPBlcAttr *blc)\n\n 获取BLC的相关属性.\n\n @param[out] blc blc功能属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。\n @attention 在使用这个函数之前，需要先将IMPISPAEAttr结构体初始化为0。"]
    pub fn IMP_ISP_Tuning_GetBlcAttr_Sec(blc: *mut IMPISPBlcAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDefog_Strength_Sec(uint8_t *ratio)\n\n 设置Defog模块的强度。\n\n @param[in] ratio  Defog强度.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDefog_Strength_Sec(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDefog_Strength_Sec(uint8_t *ratio)\n\n 获取Defog模块的强度。\n\n @param[in] ratio  Defog强度.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDefog_Strength_Sec(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetCsc_Attr_Sec(IMPISPCscAttr *attr)\n\n 设置CSC模块功能属性。\n\n @param[in] attr CSC模块属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetCsc_Attr_Sec(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetCsc_Attr_Sec(IMPISPCscAttr *attr)\n\n 获取CSC模块功能属性。\n\n @param[in] attr CSC模块属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetCsc_Attr_Sec(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFrameDrop_Sec(IMPISPFrameDropAttr *attr)\n\n 设置丢帧属性。\n\n @param[in] attr      丢帧属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 每接收(lsize+1)帧就会丢(fmark无效位数)帧。\n @remark 例如：lsize=3,fmark=0x5(每4帧丢第2和第4帧)\n\n @attention 在使用这个函数之前，IMP_ISP_Open已被调用。"]
    pub fn IMP_ISP_SetFrameDrop_Sec(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetFrameDrop_Sec(IMPISPFrameDropAttr *attr)\n\n 获取丢帧属性。\n\n @param[out] attr     丢帧属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 每接收(lsize+1)帧就会丢(fmark无效位数)帧。\n @remark 例如：lsize=3,fmark=0x5(每4帧丢第2和第4帧)\n\n @attention 在使用这个函数之前，IMP_ISP_Open已被调用。"]
    pub fn IMP_ISP_GetFrameDrop_Sec(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFixedContraster_Sec(IMPISPFixedContrastAttr *attr)\n\n mjpeg设置固定对比度。\n\n @param[out] attr\t属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_SetFixedContraster_Sec(attr: *mut IMPISPFixedContrastAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAutoZoom_Sec(IMPISPAutoZoom *ispautozoom)\n\n 设置自动聚焦的参数\n\n @param[in] 自动聚焦配置参数\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @attention 在使用这个函数之前，必须保证IMP_ISP_EnableSensor被执行且返回成功."]
    pub fn IMP_ISP_Tuning_SetAutoZoom_Sec(ispautozoom: *mut IMPISPAutoZoom) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetMaskBlock_Sec(IMPISPMaskBlockAttr *mask)\n\n 设置填充参数.\n\n @param[in] num   对应sensor的标号\n @param[in] mask  填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr block;\n\n if (en) {\n      block.chx = 0;\n      block.pinum = 0;\n      block.mask_en = 1;\n      block.mask_pos_top = 10;\n      block.mask_pos_left = 100;\n      block.mask_width = 200;\n      block.mask_height = 200;\n      block.mask_type = IMPISP_MASK_TYPE_YUV;\n      block.mask_value.ayuv.y_value = 100;\n      block.mask_value.ayuv.u_value = 100;\n      block.mask_value.ayuv.v_value = 100;\n } else {\n      block.mask_en = 0;\n }\n\n ret = IMP_ISP_Tuning_SetMaskBlock_Sec(&block);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetMaskBlock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetMaskBlock_Sec(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetMaskBlock_Sec(IMPISPMaskBlockAttr *mask)\n\n 获取填充参数.\n\n @param[in] num   对应sensor的标号\n @param[out] mask 填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr attr;\n\n attr.chx = 0;\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetMaskBlock_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetMaskBlock error !\\n\");\n \treturn -1;\n }\n printf(\"chx:%d, pinum:%d, en:%d\\n\", attr.chx, attr.pinum, attr.mask_en);\n if (attr.mask_en) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetMaskBlock_Sec(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDAttr_Sec(IMPISPOSDAttr *attr)\n\n 设置填充参数.\n\n @param[in] num   对应sensor的标号\n @param[in] attr  填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n attr.osd_type = IMP_ISP_PIC_ARGB_8888;\n attr.osd_argb_type = IMP_ISP_ARGB_TYPE_BGRA;\n attr.osd_pixel_alpha_disable = IMPISP_TUNING_OPS_MODE_ENABLE;\n\n if(ret){\n \tIMP_LOG_ERR(TAG, \" error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetOSDAttr_Sec(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDAttr_Sec(IMPISPOSDAttr *attr)\n\n 获取填充参数.\n\n @param[in] num   对应sensor的标号\n @param[out] attr  填充参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n ret = IMP_ISP_Tuning_GetOSDAttr_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDAttr error !\\n\");\n \treturn -1;\n }\n printf(\"type:%d, argb_type:%d, mode:%d\\n\", attr.osd_type,\n attr.osd_argb_type, attr.osd_pixel_alpha_disable);\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetOSDAttr_Sec(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDBlock_Sec(IMPISPOSDBlockAttr *attr)\n\n 设置OSD参数.\n\n @param[in] num   对应sensor的标号\n @param[in] attr  OSD参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr block;\n\n block.pinum = pinum;\n block.osd_enable = enable;\n block.osd_left = left / 2 * 2;\n block.osd_top = top / 2 * 2;\n block.osd_width = width;\n block.osd_height = height;\n block.osd_image = image;\n block.osd_stride = stride;\n\n ret = IMP_ISP_Tuning_SetOSDBlock_Sec(&block);\n if(ret){\n \timp_log_err(tag, \"imp_isp_tuning_setosdblock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetOSDBlock_Sec(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDBlock_Sec(IMPISPOSDBlockAttr *attr)\n\n 获取OSD参数.\n\n @param[in] num   对应sensor的标号\n @param[out] attr OSD参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetOSDBlock_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, en:%d\\n\", attr.pinum, attr.osd_enable);\n if (attr.osd_enable) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetOSDBlock_Sec(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDrawBlock_Sec(IMPISPDrawBlockAttr *attr)\n\n 设置绘图功能参数.\n\n @param[in] num   对应sensor的标号\n @param[in] attr  绘图功能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)2;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.line.enable = en;\n block.cfg.line.startx = left / 2 * 2;\n block.cfg.line.starty = top / 2 * 2;\n block.cfg.line.endx = w / 2 * 2;\n block.cfg.line.endy = h / 2 * 2;\n block.cfg.line.color.ayuv.y_value = y;\n block.cfg.line.color.ayuv.u_value = u;\n block.cfg.line.color.ayuv.v_value = v;\n block.cfg.line.width = lw / 2 * 2;\n block.cfg.line.alpha = alpha;\n IMP_ISP_Tuning_SetDrawBlock_Sec(&block);\n\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)0;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.wind.enable = en;\n block.cfg.wind.left = left / 2 * 2;\n block.cfg.wind.top = top / 2 * 2;\n block.cfg.wind.width = w / 2 * 2;\n block.cfg.wind.height = h / 2 * 2;\n block.cfg.wind.color.ayuv.y_value = y;\n block.cfg.wind.color.ayuv.u_value = u;\n block.cfg.wind.color.ayuv.v_value = v;\n block.cfg.wind.line_width = lw / 2 * 2;\n block.cfg.wind.alpha = alpha;\n\n IMP_ISP_Tuning_SetDrawBlock_Sec(&block);\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)1;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.rang.enable = en;\n block.cfg.rang.left = left / 2 * 2;\n block.cfg.rang.top = top / 2 * 2;\n block.cfg.rang.width = w / 2 * 2;\n block.cfg.rang.height = h / 2 * 2;\n block.cfg.rang.color.ayuv.y_value = y;\n block.cfg.rang.color.ayuv.u_value = u;\n block.cfg.rang.color.ayuv.v_value = v;\n block.cfg.rang.line_width = lw / 2 * 2;\n block.cfg.rang.alpha = alpha;\n block.cfg.rang.extend = extend / 2 * 2;\n\n IMP_ISP_Tuning_SetDrawBlock_Sec(&block);\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SetDrawBlock_Sec(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDrawBlock_Sec(IMPISPDrawBlockAttr *attr)\n\n 获取绘图功能参数.\n\n @param[in] num   对应sensor的标号\n @param[out] attr  绘图功能参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n int ret = 0;\n IMPISPDrawBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetDrawBlock_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetDrawBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, type:%d, color type:%d\\n\", attr.pinum, attr.type, attr.color_type);\n switch (attr.type) {\n      case IMP_ISP_DRAW_WIND:\n          printf(\"enable:%d\\n\", attr.wind.enable);\n          if (attr.wind.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_RANGE:\n          printf(\"enable:%d\\n\", attr.rang.enable);\n          if (attr.rang.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_LINE:\n          printf(\"enable:%d\\n\", attr.line.enable);\n          if (attr.line.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      default:\n          break;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_GetDrawBlock_Sec(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
#[repr(u32)]
#[doc = " 区域状态"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPIspOsdRngStat {
    IMP_ISP_OSD_RGN_FREE = 0,
    IMP_ISP_OSD_RGN_BUSY = 1,
}
#[repr(u32)]
#[doc = " 模式选择"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPOSDType {
    #[doc = "< 未定义的"]
    ISP_OSD_REG_INV = 0,
    #[doc = "< ISP绘制图片"]
    ISP_OSD_REG_PIC = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDNode {
    _unused: [u8; 0],
}
#[doc = " 填充功能通道属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDSingleAttr {
    pub chx: libc::c_int,
    pub sensornum: libc::c_int,
    #[doc = "< 填充功能通道属性"]
    pub chnOSDAttr: IMPISPOSDAttr,
    #[doc = "< 填充图片属性，每个通道最多可以填充8张图片"]
    pub pic: IMPISPOSDBlockAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPOSDSingleAttr"][::core::mem::size_of::<IMPISPOSDSingleAttr>() - 40usize];
    ["Alignment of IMPISPOSDSingleAttr"][::core::mem::align_of::<IMPISPOSDSingleAttr>() - 4usize];
    ["Offset of field: IMPISPOSDSingleAttr::chx"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, chx) - 0usize];
    ["Offset of field: IMPISPOSDSingleAttr::sensornum"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, sensornum) - 4usize];
    ["Offset of field: IMPISPOSDSingleAttr::chnOSDAttr"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, chnOSDAttr) - 8usize];
    ["Offset of field: IMPISPOSDSingleAttr::pic"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, pic) - 20usize];
};
impl Default for IMPISPOSDSingleAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ISPOSD属性集合"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPIspOsdAttrAsm {
    pub type_: IMPISPOSDType,
    pub __anon1: IMPIspOsdAttrAsm__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPIspOsdAttrAsm__bindgen_ty_1 {
    pub stsinglepicAttr: IMPISPOSDSingleAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPIspOsdAttrAsm__bindgen_ty_1"]
        [::core::mem::size_of::<IMPIspOsdAttrAsm__bindgen_ty_1>() - 40usize];
    ["Alignment of IMPIspOsdAttrAsm__bindgen_ty_1"]
        [::core::mem::align_of::<IMPIspOsdAttrAsm__bindgen_ty_1>() - 4usize];
    ["Offset of field: IMPIspOsdAttrAsm__bindgen_ty_1::stsinglepicAttr"]
        [::core::mem::offset_of!(IMPIspOsdAttrAsm__bindgen_ty_1, stsinglepicAttr) - 0usize];
};
impl Default for IMPIspOsdAttrAsm__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPIspOsdAttrAsm"][::core::mem::size_of::<IMPIspOsdAttrAsm>() - 44usize];
    ["Alignment of IMPIspOsdAttrAsm"][::core::mem::align_of::<IMPIspOsdAttrAsm>() - 4usize];
    ["Offset of field: IMPIspOsdAttrAsm::type_"]
        [::core::mem::offset_of!(IMPIspOsdAttrAsm, type_) - 0usize];
};
impl Default for IMPIspOsdAttrAsm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetOsdPoolSize(int size)\n\n 创建ISPOSD使用的rmem内存大小\n\n @param[in]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_ISP_Tuning_SetOsdPoolSize(size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_CreateOsdRgn(int chn,IMPIspOsdAttrAsm *pIspOsdAttr)\n\n 创建ISPOSD区域\n\n @param[in] chn通道号，IMPIspOsdAttrAsm 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_ISP_Tuning_CreateOsdRgn(
        chn: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetOsdRgnAttr(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n 设置ISPOSD 通道区域的属性\n\n @param[in] sensor num，handle号 IMPIspOsdAttrAsm 结构体指针\n\n @retval 0 成功\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_ISP_Tuning_SetOsdRgnAttr(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetOsdRgnAttr(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n 获取ISPOSD 通道号中的区域属性\n\n @param[in] sensor num，handle号，IMPOSDRgnCreateStat 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_ISP_Tuning_GetOsdRgnAttr(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_ShowOsdRgn( int chn,int handle, int showFlag)\n\n 设置ISPOSD通道号中的handle对应的显示状态\n\n @param[in] sensor num，handle号，showFlag显示状态(0:关闭显示，1:开启显示)\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_ISP_Tuning_ShowOsdRgn(
        chn: libc::c_int,
        handle: libc::c_int,
        showFlag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_DestroyOsdRgn(int chn,int handle)\n\n 销毁通道中对应的handle节点\n\n @param[in] sensor num，handle号\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_ISP_Tuning_DestroyOsdRgn(chn: libc::c_int, handle: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPBinAttr {
    #[doc = "< Switch bin功能开关"]
    pub enable: IMPISPTuningOpsMode,
    #[doc = "< bin文件的绝对路径"]
    pub bname: [libc::c_char; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPBinAttr"][::core::mem::size_of::<IMPISPBinAttr>() - 132usize];
    ["Alignment of IMPISPBinAttr"][::core::mem::align_of::<IMPISPBinAttr>() - 4usize];
    ["Offset of field: IMPISPBinAttr::enable"]
        [::core::mem::offset_of!(IMPISPBinAttr, enable) - 0usize];
    ["Offset of field: IMPISPBinAttr::bname"]
        [::core::mem::offset_of!(IMPISPBinAttr, bname) - 4usize];
};
impl Default for IMPISPBinAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SwitchBin(IMPISPBinAttr *attr)\n\n 切换Bin文件.\n\n @param[in] attr     需要切换的bin文件属性\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n @code\n int ret = 0;\n IMPISPBinAttr attr;\n char name[] = \"/etc/sensor/xxx-t23.bin\"\n\n attr.enable = IMPISP_TUNING_OPS_MODE_ENABLE;\n memcpy(attr.bname, name, sizeof(name));\n ret = IMP_ISP_Tuning_SwitchBin( &attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SwitchBin error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention 在使用这个函数之前，IMP_ISP_EnableTuning已被调用。"]
    pub fn IMP_ISP_Tuning_SwitchBin(attr: *mut IMPISPBinAttr) -> i32;
}
#[doc = " 出流状态"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPStreamState {
    #[doc = "< 下标为Sensor编号，值为1代表出流，0代表停流"]
    pub sensor: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPStreamState"][::core::mem::size_of::<IMPISPStreamState>() - 8usize];
    ["Alignment of IMPISPStreamState"][::core::mem::align_of::<IMPISPStreamState>() - 4usize];
    ["Offset of field: IMPISPStreamState::sensor"]
        [::core::mem::offset_of!(IMPISPStreamState, sensor) - 0usize];
};
#[doc = " 出流检查属性"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPStreamCheck {
    #[doc = "< 单位：ms"]
    pub timeout: libc::c_int,
    pub state: IMPISPStreamState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPStreamCheck"][::core::mem::size_of::<IMPISPStreamCheck>() - 12usize];
    ["Alignment of IMPISPStreamCheck"][::core::mem::align_of::<IMPISPStreamCheck>() - 4usize];
    ["Offset of field: IMPISPStreamCheck::timeout"]
        [::core::mem::offset_of!(IMPISPStreamCheck, timeout) - 0usize];
    ["Offset of field: IMPISPStreamCheck::state"]
        [::core::mem::offset_of!(IMPISPStreamCheck, state) - 4usize];
};
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_StreamCheck(IMPISPStreamCheck *check)\n\n 获取主次摄出流情况.\n\n @param[in] check 参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n IMPISPStreamCheck attr;\n memset(&attr, 0x0, sizeof(IMPISPStreamCheck));\n attr.timeout = 500;\n IMP_ISP_StreamCheck(&attr);\n\n printf(\"state:%d %d\\n\", attr.state.sensor[0], attr.state.sensor[1]);\n @endcode\n\n @attention 在使用这个函数之前，必须保证摄像头已经被使能."]
    pub fn IMP_ISP_StreamCheck(check: *mut IMPISPStreamCheck) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetStreamOut(IMPISPStreamState *state)\n\n 控制主次摄出流.\n\n @param[in] state 参数.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @code\n IMPISPStreamState attr;\n\n memset(&attr, 0x0, sizeof(IMPISPStreamState));\n attr.sensor[0] = 1;\n attr.sensor[1] = 0;\n IMP_ISP_SetStreamOut(&attr);\n @endcode\n\n @attention 在使用这个函数之前，必须保证摄像头已经被使能."]
    pub fn IMP_ISP_SetStreamOut(state: *mut IMPISPStreamState) -> i32;
}
#[doc = " OSD 区域句柄"]
pub type IMPRgnHandle = libc::c_int;
#[repr(u32)]
#[doc = " DrawBox OSD颜色类型，颜色格式为bgra"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPOsdColour {
    OSD_RED = 0,
    OSD_BLACK = 1,
    OSD_GREEN = 2,
    OSD_YELLOW = 3,
}
#[repr(u32)]
#[doc = " IPU OSD 颜色"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPIpuColour {
    #[doc = "< 黑色"]
    OSD_IPU_BLACK = 4278190080,
    #[doc = "< 白色"]
    OSD_IPU_WHITE = 4294967295,
    #[doc = "< 红色"]
    OSD_IPU_RED = 4294901760,
    #[doc = "< 绿色"]
    OSD_IPU_GREEN = 4278255360,
    #[doc = "< 蓝色"]
    OSD_IPU_BLUE = 4278190335,
}
#[repr(u32)]
#[doc = " OSD区域类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPOsdRgnType {
    #[doc = "< 未定义的"]
    OSD_REG_INV = 0,
    #[doc = "< 横线"]
    OSD_REG_HORIZONTAL_LINE = 1,
    #[doc = "< 竖线"]
    OSD_REG_VERTICAL_LINE = 2,
    #[doc = "< 矩形"]
    OSD_REG_RECT = 3,
    #[doc = "< 四角矩形"]
    OSD_REG_FOUR_CORNER_RECT = 4,
    #[doc = "< 点阵图片"]
    OSD_REG_BITMAP = 5,
    #[doc = "< 矩形遮挡"]
    OSD_REG_COVER = 6,
    #[doc = "< 图片，适合用作Logo或时间戳"]
    OSD_REG_PIC = 7,
    #[doc = "< 图片，适合用作Logo或时间戳, 使用RMEM内存"]
    OSD_REG_PIC_RMEM = 8,
    OSD_REG_SLASH = 9,
    OSD_REG_ISP_PIC = 10,
    OSD_REG_ISP_LINE_RECT = 11,
    OSD_REG_ISP_COVER = 12,
    OSD_REG_MOSAIC = 13,
}
#[doc = " OSD区域线和矩形数据"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lineRectData {
    #[doc = "< 颜色，支持IMPOsdColour枚举类型颜色"]
    pub color: u32,
    #[doc = "< 线宽"]
    pub linewidth: u32,
    #[doc = "< 线长"]
    pub linelength: u32,
    #[doc = "< 半边框的线长"]
    pub rectlinelength: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lineRectData"][::core::mem::size_of::<lineRectData>() - 16usize];
    ["Alignment of lineRectData"][::core::mem::align_of::<lineRectData>() - 4usize];
    ["Offset of field: lineRectData::color"][::core::mem::offset_of!(lineRectData, color) - 0usize];
    ["Offset of field: lineRectData::linewidth"]
        [::core::mem::offset_of!(lineRectData, linewidth) - 4usize];
    ["Offset of field: lineRectData::linelength"]
        [::core::mem::offset_of!(lineRectData, linelength) - 8usize];
    ["Offset of field: lineRectData::rectlinelength"]
        [::core::mem::offset_of!(lineRectData, rectlinelength) - 12usize];
};
#[doc = " OSD区域遮挡数据"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct coverData {
    #[doc = "< 颜色，只支持bgra颜色格式"]
    pub color: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of coverData"][::core::mem::size_of::<coverData>() - 4usize];
    ["Alignment of coverData"][::core::mem::align_of::<coverData>() - 4usize];
    ["Offset of field: coverData::color"][::core::mem::offset_of!(coverData, color) - 0usize];
};
#[doc = " OSD区域图片数据"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct picData {
    #[doc = "< 图片数据指针"]
    pub pData: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of picData"][::core::mem::size_of::<picData>() - 4usize];
    ["Alignment of picData"][::core::mem::align_of::<picData>() - 4usize];
    ["Offset of field: picData::pData"][::core::mem::offset_of!(picData, pData) - 0usize];
};
impl Default for picData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD区域属性数据"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPOSDRgnAttrData {
    #[doc = "< 点阵数据"]
    pub bitmapData: *mut libc::c_void,
    #[doc = "< 线、矩形数据"]
    pub lineRectData: lineRectData,
    #[doc = "< 遮挡数据"]
    pub coverData: coverData,
    #[doc = "< 图片数据"]
    pub picData: picData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDRgnAttrData"][::core::mem::size_of::<IMPOSDRgnAttrData>() - 16usize];
    ["Alignment of IMPOSDRgnAttrData"][::core::mem::align_of::<IMPOSDRgnAttrData>() - 4usize];
    ["Offset of field: IMPOSDRgnAttrData::bitmapData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, bitmapData) - 0usize];
    ["Offset of field: IMPOSDRgnAttrData::lineRectData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, lineRectData) - 0usize];
    ["Offset of field: IMPOSDRgnAttrData::coverData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, coverData) - 0usize];
    ["Offset of field: IMPOSDRgnAttrData::picData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, picData) - 0usize];
};
impl Default for IMPOSDRgnAttrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD Font大小数据"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPOSDFontSizeAttrData {
    pub fontWidth: libc::c_uint,
    pub fontHeight: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDFontSizeAttrData"][::core::mem::size_of::<IMPOSDFontSizeAttrData>() - 8usize];
    ["Alignment of IMPOSDFontSizeAttrData"]
        [::core::mem::align_of::<IMPOSDFontSizeAttrData>() - 4usize];
    ["Offset of field: IMPOSDFontSizeAttrData::fontWidth"]
        [::core::mem::offset_of!(IMPOSDFontSizeAttrData, fontWidth) - 0usize];
    ["Offset of field: IMPOSDFontSizeAttrData::fontHeight"]
        [::core::mem::offset_of!(IMPOSDFontSizeAttrData, fontHeight) - 4usize];
};
#[doc = " OSD Font属性数据"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPOSDFontAttrData {
    #[doc = "< 时间戳反色使能开关"]
    pub invertColorSwitch: libc::c_uint,
    #[doc = "< 亮度参考 默认190"]
    pub luminance: libc::c_uint,
    #[doc = "< 字体长度"]
    pub length: libc::c_uint,
    #[doc = "< 时间戳字符尺寸属性数据"]
    pub data: IMPOSDFontSizeAttrData,
    #[doc = "< 图片数据是否为时间戳"]
    pub istimestamp: libc::c_uint,
    #[doc = "< 主码流时间戳各字符反色标识"]
    pub colType: [libc::c_uint; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDFontAttrData"][::core::mem::size_of::<IMPOSDFontAttrData>() - 280usize];
    ["Alignment of IMPOSDFontAttrData"][::core::mem::align_of::<IMPOSDFontAttrData>() - 4usize];
    ["Offset of field: IMPOSDFontAttrData::invertColorSwitch"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, invertColorSwitch) - 0usize];
    ["Offset of field: IMPOSDFontAttrData::luminance"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, luminance) - 4usize];
    ["Offset of field: IMPOSDFontAttrData::length"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, length) - 8usize];
    ["Offset of field: IMPOSDFontAttrData::data"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, data) - 12usize];
    ["Offset of field: IMPOSDFontAttrData::istimestamp"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, istimestamp) - 20usize];
    ["Offset of field: IMPOSDFontAttrData::colType"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, colType) - 24usize];
};
impl Default for IMPOSDFontAttrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPOSDIspDraw {
    pub stDrawAttr: IMPISPDrawBlockAttr,
    pub stpicAttr: IMPISPOSDBlockAttr,
    pub stCoverAttr: IMPISPMaskBlockAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDIspDraw"][::core::mem::size_of::<IMPOSDIspDraw>() - 72usize];
    ["Alignment of IMPOSDIspDraw"][::core::mem::align_of::<IMPOSDIspDraw>() - 4usize];
    ["Offset of field: IMPOSDIspDraw::stDrawAttr"]
        [::core::mem::offset_of!(IMPOSDIspDraw, stDrawAttr) - 0usize];
    ["Offset of field: IMPOSDIspDraw::stpicAttr"]
        [::core::mem::offset_of!(IMPOSDIspDraw, stpicAttr) - 32usize];
    ["Offset of field: IMPOSDIspDraw::stCoverAttr"]
        [::core::mem::offset_of!(IMPOSDIspDraw, stCoverAttr) - 52usize];
};
impl Default for IMPOSDIspDraw {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD马赛克属性"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mosaicPointAttr {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub mosaic_width: libc::c_int,
    pub mosaic_height: libc::c_int,
    pub frame_width: libc::c_int,
    pub frame_height: libc::c_int,
    pub mosaic_min_size: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mosaicPointAttr"][::core::mem::size_of::<mosaicPointAttr>() - 28usize];
    ["Alignment of mosaicPointAttr"][::core::mem::align_of::<mosaicPointAttr>() - 4usize];
    ["Offset of field: mosaicPointAttr::x"][::core::mem::offset_of!(mosaicPointAttr, x) - 0usize];
    ["Offset of field: mosaicPointAttr::y"][::core::mem::offset_of!(mosaicPointAttr, y) - 4usize];
    ["Offset of field: mosaicPointAttr::mosaic_width"]
        [::core::mem::offset_of!(mosaicPointAttr, mosaic_width) - 8usize];
    ["Offset of field: mosaicPointAttr::mosaic_height"]
        [::core::mem::offset_of!(mosaicPointAttr, mosaic_height) - 12usize];
    ["Offset of field: mosaicPointAttr::frame_width"]
        [::core::mem::offset_of!(mosaicPointAttr, frame_width) - 16usize];
    ["Offset of field: mosaicPointAttr::frame_height"]
        [::core::mem::offset_of!(mosaicPointAttr, frame_height) - 20usize];
    ["Offset of field: mosaicPointAttr::mosaic_min_size"]
        [::core::mem::offset_of!(mosaicPointAttr, mosaic_min_size) - 24usize];
};
#[doc = " OSD马赛克属性"]
pub type IMPOSDMosaicAttr = mosaicPointAttr;
#[doc = " OSD区域属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPOSDRgnAttr {
    #[doc = "< OSD区域类型"]
    pub type_: IMPOsdRgnType,
    #[doc = "< 矩形数据"]
    pub rect: IMPRect,
    #[doc = "< 直线数据"]
    pub line: IMPLine,
    #[doc = "< 点格式"]
    pub fmt: IMPPixelFormat,
    #[doc = "< OSD区域属性数据"]
    pub data: IMPOSDRgnAttrData,
    #[doc = "< ISP绘制OSD的相关属性"]
    pub osdispdraw: IMPOSDIspDraw,
    #[doc = "< OSD Font属性数据"]
    pub fontData: IMPOSDFontAttrData,
    #[doc = "< 马赛克数据"]
    pub mosaicAttr: IMPOSDMosaicAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDRgnAttr"][::core::mem::size_of::<IMPOSDRgnAttr>() - 428usize];
    ["Alignment of IMPOSDRgnAttr"][::core::mem::align_of::<IMPOSDRgnAttr>() - 4usize];
    ["Offset of field: IMPOSDRgnAttr::type_"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, type_) - 0usize];
    ["Offset of field: IMPOSDRgnAttr::rect"][::core::mem::offset_of!(IMPOSDRgnAttr, rect) - 4usize];
    ["Offset of field: IMPOSDRgnAttr::line"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, line) - 20usize];
    ["Offset of field: IMPOSDRgnAttr::fmt"][::core::mem::offset_of!(IMPOSDRgnAttr, fmt) - 28usize];
    ["Offset of field: IMPOSDRgnAttr::data"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, data) - 32usize];
    ["Offset of field: IMPOSDRgnAttr::osdispdraw"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, osdispdraw) - 48usize];
    ["Offset of field: IMPOSDRgnAttr::fontData"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, fontData) - 120usize];
    ["Offset of field: IMPOSDRgnAttr::mosaicAttr"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, mosaicAttr) - 400usize];
};
impl Default for IMPOSDRgnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD区域生效时间戳"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPOSDRgnTimestamp {
    #[doc = "< 时间戳"]
    pub ts: u64,
    #[doc = "< 下限"]
    pub minus: u64,
    #[doc = "< 上限"]
    pub plus: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDRgnTimestamp"][::core::mem::size_of::<IMPOSDRgnTimestamp>() - 24usize];
    ["Alignment of IMPOSDRgnTimestamp"][::core::mem::align_of::<IMPOSDRgnTimestamp>() - 8usize];
    ["Offset of field: IMPOSDRgnTimestamp::ts"]
        [::core::mem::offset_of!(IMPOSDRgnTimestamp, ts) - 0usize];
    ["Offset of field: IMPOSDRgnTimestamp::minus"]
        [::core::mem::offset_of!(IMPOSDRgnTimestamp, minus) - 8usize];
    ["Offset of field: IMPOSDRgnTimestamp::plus"]
        [::core::mem::offset_of!(IMPOSDRgnTimestamp, plus) - 16usize];
};
#[doc = " OSD组区域属性"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPOSDGrpRgnAttr {
    #[doc = "< 是否显示"]
    pub show: libc::c_int,
    #[doc = "< 显示起始坐标"]
    pub offPos: IMPPoint,
    #[doc = "< 缩放x参数"]
    pub scalex: f32,
    #[doc = "< 缩放y参数"]
    pub scaley: f32,
    #[doc = "< Alpha开关"]
    pub gAlphaEn: libc::c_int,
    #[doc = "< 前景Alpha"]
    pub fgAlhpa: libc::c_int,
    #[doc = "< 背景Alpha"]
    pub bgAlhpa: libc::c_int,
    #[doc = "< 显示层"]
    pub layer: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDGrpRgnAttr"][::core::mem::size_of::<IMPOSDGrpRgnAttr>() - 36usize];
    ["Alignment of IMPOSDGrpRgnAttr"][::core::mem::align_of::<IMPOSDGrpRgnAttr>() - 4usize];
    ["Offset of field: IMPOSDGrpRgnAttr::show"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, show) - 0usize];
    ["Offset of field: IMPOSDGrpRgnAttr::offPos"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, offPos) - 4usize];
    ["Offset of field: IMPOSDGrpRgnAttr::scalex"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, scalex) - 12usize];
    ["Offset of field: IMPOSDGrpRgnAttr::scaley"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, scaley) - 16usize];
    ["Offset of field: IMPOSDGrpRgnAttr::gAlphaEn"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, gAlphaEn) - 20usize];
    ["Offset of field: IMPOSDGrpRgnAttr::fgAlhpa"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, fgAlhpa) - 24usize];
    ["Offset of field: IMPOSDGrpRgnAttr::bgAlhpa"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, bgAlhpa) - 28usize];
    ["Offset of field: IMPOSDGrpRgnAttr::layer"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, layer) - 32usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stRgnCreateStat {
    #[doc = "< osd区域创建的状态：0、未创建，1、区域已创建"]
    pub status: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stRgnCreateStat"][::core::mem::size_of::<stRgnCreateStat>() - 4usize];
    ["Alignment of stRgnCreateStat"][::core::mem::align_of::<stRgnCreateStat>() - 4usize];
    ["Offset of field: stRgnCreateStat::status"]
        [::core::mem::offset_of!(stRgnCreateStat, status) - 0usize];
};
pub type IMPOSDRgnCreateStat = stRgnCreateStat;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stRgnRigsterStat {
    #[doc = "< osd组区域注册的状态：0、未注册，1、区域已注册"]
    pub status: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stRgnRigsterStat"][::core::mem::size_of::<stRgnRigsterStat>() - 4usize];
    ["Alignment of stRgnRigsterStat"][::core::mem::align_of::<stRgnRigsterStat>() - 4usize];
    ["Offset of field: stRgnRigsterStat::status"]
        [::core::mem::offset_of!(stRgnRigsterStat, status) - 0usize];
};
pub type IMPOSDRgnRegisterStat = stRgnRigsterStat;
extern "C" {
    #[doc = " @fn int IMP_OSD_SetPoolSize(int size);\n\n 设置OSD rmem池大小\n\n\n @retval  0 成功\n @retval -1 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_SetPoolSize(size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetMosaic(unsigned char *frame_virAddr, IMPOSDMosaicAttr *mosaicAttr);\n\n OSD 马赛克\n\n\n @retval  0 成功\n @retval -1 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_SetMosaic(
        frame_virAddr: *mut libc::c_uchar,
        mosaicAttr: *mut IMPOSDMosaicAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRegionLuma(IMPRgnHandle handle,IMPOSDRgnAttr *prAttr)\n\n OSD 时间戳反色\n\n\n @retval  0 成功\n @retval -1 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_GetRegionLuma(handle: IMPRgnHandle, prAttr: *mut IMPOSDRgnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RgnCreate_Query(IMPRgnHandle handle,IMPOSDRgnCreateStat *pstStatus)\n\n 查询osd区域创建的状态\n\n @param[in] handle号，IMPOSDRgnCreateStat 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_RgnCreate_Query(
        handle: IMPRgnHandle,
        pstStatus: *mut IMPOSDRgnCreateStat,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RgnRegister_Query(IMPRgnHandle handle,int grpNum,IMPOSDRgnRegisterStat *pstStatus)\n\n 查询osd区域注册状态\n\n @param[in] handle 号，grpNum OSD组号,取值范围: [0, @ref NR_MAX_OSD_GROUPS - 1]，IMPOSDRgnRegisterStat 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_RgnRegister_Query(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pstStatus: *mut IMPOSDRgnRegisterStat,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_CreateGroup(int grpNum)\n\n 创建OSD组\n\n @param[in] grpNum OSD组号,取值范围: [0, @ref NR_MAX_OSD_GROUPS - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_CreateGroup(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_DestroyGroup(int grpNum)\n\n 销毁OSD组\n\n @param[in] grpNum OSD组号,取值范围: [0, @ref NR_MAX_OSD_GROUPS - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的组已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_DestroyGroup(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_AttachToGroup(IMPCell *from, IMPCell *to)\n\n 将OSD组加入到系统中\n\n @param[in] from OSD单元\n @param[in] to 系统中其他单元\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 新版本的SDK中建议使用Bind的方式将OSD串到系统的数据流中，Attach的方式不再推荐使用，但是API保留，方便兼容以往版本的软件。\\n\n 具体可以参考@ref bind 的的示例\n\n @attention 无。"]
    pub fn IMP_OSD_AttachToGroup(from: *mut IMPCell, to: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMPRgnHandle IMP_OSD_CreateRgn(IMPOSDRgnAttr *prAttr)\n\n 创建OSD区域\n\n @param[in] prAttr OSD区域属性\n\n @retval 大于等于0 成功\n @retval 小于0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_CreateRgn(prAttr: *mut IMPOSDRgnAttr) -> IMPRgnHandle;
}
extern "C" {
    #[doc = " @fn void IMP_OSD_DestroyRgn(IMPRgnHandle handle)\n\n 销毁OSD区域\n\n @param[in] prAttr 区域句柄，IMP_OSD_CreateRgn的返回值\n\n @retval 无\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_OSD_DestroyRgn(handle: IMPRgnHandle);
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RegisterRgn(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n 注册OSD区域\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] grpNum OSD组号\n @param[in] pgrAttr OSD组显示属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_RegisterRgn(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_UnRegisterRgn(IMPRgnHandle handle, int grpNum)\n\n 注销OSD区域\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] grpNum OSD组号\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建,对应的区域已经注册。\n\n @attention 无。"]
    pub fn IMP_OSD_UnRegisterRgn(handle: IMPRgnHandle, grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr)\n\n 设置区域属性\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] prAttr OSD区域属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的区域已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_SetRgnAttr(handle: IMPRgnHandle, prAttr: *mut IMPOSDRgnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttrWithTimestamp(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr, IMPOSDRgnTimestamp *prTs)\n\n 设置区域属性和生效时间\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] prAttr OSD区域属性\n @param[in] prTs 生效时间\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的区域已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_SetRgnAttrWithTimestamp(
        handle: IMPRgnHandle,
        prAttr: *mut IMPOSDRgnAttr,
        prTs: *mut IMPOSDRgnTimestamp,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr)\n\n 获取区域属性\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[out] prAttr OSD区域属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的区域已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_GetRgnAttr(handle: IMPRgnHandle, prAttr: *mut IMPOSDRgnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_UpdateRgnAttrData(IMPRgnHandle handle, IMPOSDRgnAttrData *prAttrData)\n\n 更新区域数据属性，只针对OSD_REG_BITMAP和OSD_REG_PIC的区域类型\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] prAttrData OSD区域数据属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的区域已经创建且区域属性已经设置成OSD_REG_BITMAP或OSD_REG_PIC。\n\n @attention 无。"]
    pub fn IMP_OSD_UpdateRgnAttrData(
        handle: IMPRgnHandle,
        prAttrData: *mut IMPOSDRgnAttrData,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetGrpRgnAttr(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n 设置OSD组区域属性\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] grpNum OSD组号\n @param[in] pgrAttr OSD组区域属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建,区域已经创建并注册。\n\n @attention 无。"]
    pub fn IMP_OSD_SetGrpRgnAttr(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetGrpRgnAttr(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n 获取OSD组区域属性\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] grpNum OSD组号\n @param[out] pgrAttr OSD组区域属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建,区域已经创建并注册。\n\n @attention 无。"]
    pub fn IMP_OSD_GetGrpRgnAttr(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_ShowRgn(IMPRgnHandle handle, int grpNum, int showFlag)\n\n 设置组区域是否显示\n\n @param[in] handle 区域句柄，IMP_OSD_CreateRgn的返回值\n @param[in] grpNum OSD组号\n @param[in] showFlag OSD组区域显示开关\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建,区域已经创建并注册。\n\n @attention 无。"]
    pub fn IMP_OSD_ShowRgn(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        showFlag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Start(int grpNum)\n\n 设置开始OSD组的显示\n\n @param[in] grpNum OSD组号\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_Start(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Stop(int grpNum)\n\n 设置停止OSD组的显示\n\n @param[in] grpNum OSD组号\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求对应的OSD组已经创建。\n\n @attention 无。"]
    pub fn IMP_OSD_Stop(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr_ISP(IMPOSDRgnAttr *prAttr,int bosdshow);\n\n 设置ISP绘制OSD的属性接口\n\n @param[in] prAttr OSD区域属性，bosdshow 开关osd标记，该标志为0，表示只可绘制ISPosd，为1，表示既可绘制ISPosd又可绘制ipu/dbox/软件OSD \\n\n 该接口只支持OSD_REG_ISP_PIC和OSD_REG_ISP_LINE_RECT类型\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求，IMP_ISP_EnableTuning已被调用\n\n @attention 无。"]
    pub fn IMP_OSD_SetRgnAttr_ISP(prAttr: *mut IMPOSDRgnAttr, bosdshow: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr_ISP(IMPOSDRgnAttr *prAttr,int *pbosdshow);\n\n 获取ISP绘制OSD的属性接口\n\n @param[in]prAttr，OSD区域属性，该接口只支持获取IMPOSDIspDraw的属性 ，pbosdshow 获取ISP开关osd的标记1\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API时要求，IMP_ISP_EnableTuning已被调用\n\n @attention 无。"]
    pub fn IMP_OSD_GetRgnAttr_ISP(
        prAttr: *mut IMPOSDRgnAttr,
        pbosdshow: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IMPPixfmtToString(pixfmt: IMPPixelFormat) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Init_ISP(void);\n\n ISPOSD资源初始化，集成在IMP_system_init接口中，用户无需再调用\n\n @param[in]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_Init_ISP() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetPoolSize_ISP(int size)\n\n 创建ISPOSD使用的rmem内存大小\n\n @param[in]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_SetPoolSize_ISP(size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_CreateRgn_ISP(int chn,IMPIspOsdAttrAsm *pIspOsdAttr)\n\n 创建ISPOSD区域\n\n @param[in] chn通道号，IMPIspOsdAttrAsm 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_CreateRgn_ISP(
        chn: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr_PicISP(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n 设置ISPOSD 通道区域的属性\n\n @param[in] chn通道号，handle号 IMPIspOsdAttrAsm 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_SetRgnAttr_PicISP(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr_ISPPic(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n 获取ISPOSD 通道号中的区域属性\n\n @param[in] chn 通道号，handle号，IMPOSDRgnCreateStat 结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_GetRgnAttr_ISPPic(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_ShowRgn_ISP( int chn,int handle, int showFlag)\n\n 设置ISPOSD通道号中的handle对应的显示状态\n\n @param[in] chn通道号，handle号，showFlag显示状态(0:关闭显示，1:开启显示)\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_ShowRgn_ISP(
        chn: libc::c_int,
        handle: libc::c_int,
        showFlag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_DestroyRgn_ISP(int chn,int handle)\n\n 销毁通道中对应的handle节点\n\n @param[in] chn通道号，handle号\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_DestroyRgn_ISP(chn: libc::c_int, handle: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn void IMP_OSD_Exit_ISP(void)\n\n 销毁ISPOSD相关资源，集成在IMP_System_Exit接口中，用户无需再调用\n\n @param[in]\n\n @retval 无\n\n @remarks 无。\n\n @attention 无。"]
    pub fn IMP_OSD_Exit_ISP();
}
#[doc = " 基本移动侦测算法的输入结构体"]
#[repr(C)]
#[derive(Debug, Default)]
pub struct IMP_IVS_BaseMoveParam {
    pub skipFrameCnt: libc::c_int,
    pub referenceNum: libc::c_int,
    pub sadMode: libc::c_int,
    pub sense: libc::c_int,
    #[doc = "< 帧尺寸信息,只需要配置width和height"]
    pub frameInfo: IMPFrameInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_BaseMoveParam"][::core::mem::size_of::<IMP_IVS_BaseMoveParam>() - 72usize];
    ["Alignment of IMP_IVS_BaseMoveParam"]
        [::core::mem::align_of::<IMP_IVS_BaseMoveParam>() - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::skipFrameCnt"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, skipFrameCnt) - 0usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::referenceNum"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, referenceNum) - 4usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::sadMode"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, sadMode) - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::sense"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, sense) - 12usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::frameInfo"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, frameInfo) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMP_IVS_BaseMoveOutput {
    pub ret: libc::c_int,
    pub data: *mut u8,
    pub datalen: libc::c_int,
    #[doc = "< 帧的时间戳"]
    pub timeStamp: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_BaseMoveOutput"][::core::mem::size_of::<IMP_IVS_BaseMoveOutput>() - 24usize];
    ["Alignment of IMP_IVS_BaseMoveOutput"]
        [::core::mem::align_of::<IMP_IVS_BaseMoveOutput>() - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::ret"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, ret) - 0usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::data"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, data) - 4usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::datalen"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, datalen) - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::timeStamp"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, timeStamp) - 16usize];
};
impl Default for IMP_IVS_BaseMoveOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " 创建移动侦测接口资源\n\n @fn IMPIVSInterface *IMP_IVS_CreateBaseMoveInterface(IMP_IVS_BaseMoveParam *param);\n\n @param[in] param 移动侦测算法的输入结构体参数\n\n @retval 非NULL 成功,返回移动侦测算法接口指针句柄\n @retval NULL 失败\n\n @attention 无"]
    pub fn IMP_IVS_CreateBaseMoveInterface(
        param: *mut IMP_IVS_BaseMoveParam,
    ) -> *mut IMPIVSInterface;
}
extern "C" {
    #[doc = " 销毁移动侦测接口资源\n\n @fn void IMP_IVS_DestroyBaseMoveInterface(IMPIVSInterface *moveInterface);\n\n @param[in] moveInterface 移动侦测算法接口指针句柄\n\n @retval 无返回值\n\n @attention 无"]
    pub fn IMP_IVS_DestroyBaseMoveInterface(moveInterface: *mut IMPIVSInterface);
}
#[repr(u32)]
#[doc = " 定义编码Channel码率控制器模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderRcMode {
    #[doc = "< Fixqp 模式"]
    ENC_RC_MODE_FIXQP = 0,
    #[doc = "< CBR 模式"]
    ENC_RC_MODE_CBR = 1,
    #[doc = "< VBR 模式"]
    ENC_RC_MODE_VBR = 2,
    #[doc = "< Smart 模式"]
    ENC_RC_MODE_SMART = 3,
    #[doc = "< INV 模式"]
    ENC_RC_MODE_INV = 4,
}
#[doc = " 定义编码channel帧率结构体,frmRateNum和frmRateDen经过最大公约数整除后两者之间的最小公倍数不能超过64，最好在设置之前就被最大公约数整除"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderFrmRate {
    #[doc = "< 在一秒钟内的时间单元的数量, 以时间单元为单位。即帧率的分子"]
    pub frmRateNum: u32,
    #[doc = "< 在一帧内的时间单元的数量, 以时间单元为单位。即帧率的分母"]
    pub frmRateDen: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderFrmRate"][::core::mem::size_of::<IMPEncoderFrmRate>() - 8usize];
    ["Alignment of IMPEncoderFrmRate"][::core::mem::align_of::<IMPEncoderFrmRate>() - 4usize];
    ["Offset of field: IMPEncoderFrmRate::frmRateNum"]
        [::core::mem::offset_of!(IMPEncoderFrmRate, frmRateNum) - 0usize];
    ["Offset of field: IMPEncoderFrmRate::frmRateDen"]
        [::core::mem::offset_of!(IMPEncoderFrmRate, frmRateDen) - 4usize];
};
#[doc = " 定义H.264编码Channel Fixqp属性结构"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264FixQP {
    #[doc = "< 帧级Qp值"]
    pub qp: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264FixQP"][::core::mem::size_of::<IMPEncoderAttrH264FixQP>() - 4usize];
    ["Alignment of IMPEncoderAttrH264FixQP"]
        [::core::mem::align_of::<IMPEncoderAttrH264FixQP>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264FixQP::qp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264FixQP, qp) - 0usize];
};
#[doc = " 定义H.264编码Channel CBR属性结构"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264CBR {
    #[doc = "< 编码器支持图像最大QP"]
    pub maxQp: u32,
    #[doc = "< 编码器支持图像最小QP"]
    pub minQp: u32,
    #[doc = "< 编码器输出码率,以kbps为单位"]
    pub outBitRate: u32,
    #[doc = "< 调整I帧QP以调节I帧的图像质量及其码流大小,范围:[-3,3]"]
    pub iBiasLvl: libc::c_int,
    #[doc = "< 帧间QP变化步长"]
    pub frmQPStep: u32,
    #[doc = "< GOP间QP变化步长"]
    pub gopQPStep: u32,
    #[doc = "< 自适应模式"]
    pub adaptiveMode: bool,
    #[doc = "< GOP是否关联"]
    pub gopRelation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264CBR"][::core::mem::size_of::<IMPEncoderAttrH264CBR>() - 28usize];
    ["Alignment of IMPEncoderAttrH264CBR"]
        [::core::mem::align_of::<IMPEncoderAttrH264CBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264CBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH264CBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH264CBR::outBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, outBitRate) - 8usize];
    ["Offset of field: IMPEncoderAttrH264CBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, iBiasLvl) - 12usize];
    ["Offset of field: IMPEncoderAttrH264CBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, frmQPStep) - 16usize];
    ["Offset of field: IMPEncoderAttrH264CBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, gopQPStep) - 20usize];
    ["Offset of field: IMPEncoderAttrH264CBR::adaptiveMode"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, adaptiveMode) - 24usize];
    ["Offset of field: IMPEncoderAttrH264CBR::gopRelation"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, gopRelation) - 25usize];
};
#[doc = " 定义H.264编码Channel VBR属性结构"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264VBR {
    #[doc = "< 编码器支持图像最大QP"]
    pub maxQp: u32,
    #[doc = "< 编码器支持图像最小QP"]
    pub minQp: u32,
    #[doc = "< 码率统计时间,以秒为单位"]
    pub staticTime: u32,
    #[doc = "< 编码器输出最大码率,以kbps为单位"]
    pub maxBitRate: u32,
    #[doc = "< 调整I帧QP以调节I帧的图像质量及其码流大小,范围:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "< VBR 开始调整 Qp 时的码率相对于最大码率的比例,取值范围:[50, 100]"]
    pub changePos: u32,
    #[doc = "< 视频质量最低水平, 范围[0-7], 值越低图像质量越高, 但码流越大, minBitRate = maxBitRate * quality[qualityLvl], 其中quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< 帧间QP变化步长"]
    pub frmQPStep: u32,
    #[doc = "< GOP间QP变化步长"]
    pub gopQPStep: u32,
    #[doc = "< gop是否关联"]
    pub gopRelation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264VBR"][::core::mem::size_of::<IMPEncoderAttrH264VBR>() - 40usize];
    ["Alignment of IMPEncoderAttrH264VBR"]
        [::core::mem::align_of::<IMPEncoderAttrH264VBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264VBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH264VBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH264VBR::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH264VBR::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH264VBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH264VBR::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH264VBR::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH264VBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH264VBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH264VBR::gopRelation"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, gopRelation) - 36usize];
};
#[doc = " 定义H.264编码Channel Smart属性结构"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264Smart {
    #[doc = "< 编码器支持图像最大QP"]
    pub maxQp: u32,
    #[doc = "< 编码器支持图像最小QP"]
    pub minQp: u32,
    #[doc = "< 码率统计时间,以秒为单位"]
    pub staticTime: u32,
    #[doc = "< 编码器输出最大码率,以kbps为单位"]
    pub maxBitRate: u32,
    #[doc = "< 调整I帧QP以调节I帧的图像质量及其码流大小,范围:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "< 开始调整 Qp 时的码率相对于最大码率的比例,取值范围:[50, 100]"]
    pub changePos: u32,
    #[doc = "< 视频质量最低水平, 范围[0-7], 值越低图像质量越高, 但码流越大. minBitRate = maxBitRate * quality[qualityLvl], 其中quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< 帧间QP变化步长"]
    pub frmQPStep: u32,
    #[doc = "< gop间QP变化步长"]
    pub gopQPStep: u32,
    #[doc = "< gop是否关联"]
    pub gopRelation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264Smart"]
        [::core::mem::size_of::<IMPEncoderAttrH264Smart>() - 40usize];
    ["Alignment of IMPEncoderAttrH264Smart"]
        [::core::mem::align_of::<IMPEncoderAttrH264Smart>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264Smart::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH264Smart::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH264Smart::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH264Smart::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH264Smart::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH264Smart::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH264Smart::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH264Smart::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH264Smart::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH264Smart::gopRelation"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, gopRelation) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265FixQP {
    #[doc = "< 帧级Qp值"]
    pub qp: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265FixQP"][::core::mem::size_of::<IMPEncoderAttrH265FixQP>() - 4usize];
    ["Alignment of IMPEncoderAttrH265FixQP"]
        [::core::mem::align_of::<IMPEncoderAttrH265FixQP>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265FixQP::qp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265FixQP, qp) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265CBR {
    #[doc = "< 编码器支持图像最大QP"]
    pub maxQp: u32,
    #[doc = "< 编码器支持图像最小QP"]
    pub minQp: u32,
    #[doc = "< 码率统计时间,以秒为单位"]
    pub staticTime: u32,
    #[doc = "< 编码器输出码率,以kbps为单位"]
    pub outBitRate: u32,
    #[doc = "< 调整I帧QP以调节I帧的图像质量及其码流大小,范围:[-3,3]"]
    pub iBiasLvl: libc::c_int,
    #[doc = "< 帧间QP变化步长"]
    pub frmQPStep: u32,
    #[doc = "< GOP间QP变化步长"]
    pub gopQPStep: u32,
    #[doc = "< 最大码率相对平均码率的波动等级,范围:[0,4]"]
    pub flucLvl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265CBR"][::core::mem::size_of::<IMPEncoderAttrH265CBR>() - 32usize];
    ["Alignment of IMPEncoderAttrH265CBR"]
        [::core::mem::align_of::<IMPEncoderAttrH265CBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265CBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH265CBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH265CBR::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH265CBR::outBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, outBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH265CBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH265CBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, frmQPStep) - 20usize];
    ["Offset of field: IMPEncoderAttrH265CBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, gopQPStep) - 24usize];
    ["Offset of field: IMPEncoderAttrH265CBR::flucLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, flucLvl) - 28usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265VBR {
    #[doc = "< 编码器支持图像最大QP"]
    pub maxQp: u32,
    #[doc = "< 编码器支持图像最小QP"]
    pub minQp: u32,
    #[doc = "< 码率统计时间,以秒为单位"]
    pub staticTime: u32,
    #[doc = "< 编码器输出最大码率,以kbps为单位"]
    pub maxBitRate: u32,
    #[doc = "< 调整I帧QP以调节I帧的图像质量及其码流大小,范围:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "< VBR 开始调整 Qp 时的码率相对于最大码率的比例,取值范围:[50, 100]"]
    pub changePos: u32,
    #[doc = "< 视频质量最低水平, 范围[0-7], 值越低图像质量越高, 但码流越大, minBitRate = maxBitRate * quality[qualityLvl], 其中quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< 帧间QP变化步长"]
    pub frmQPStep: u32,
    #[doc = "< GOP间QP变化步长"]
    pub gopQPStep: u32,
    #[doc = "< 最大码率相对平均码率的波动等级,范围:[0,4]"]
    pub flucLvl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265VBR"][::core::mem::size_of::<IMPEncoderAttrH265VBR>() - 40usize];
    ["Alignment of IMPEncoderAttrH265VBR"]
        [::core::mem::align_of::<IMPEncoderAttrH265VBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265VBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH265VBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH265VBR::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH265VBR::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH265VBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH265VBR::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH265VBR::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH265VBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH265VBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH265VBR::flucLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, flucLvl) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265Smart {
    #[doc = "< 编码器支持图像最大QP"]
    pub maxQp: u32,
    #[doc = "< 编码器支持图像最小QP"]
    pub minQp: u32,
    #[doc = "< 码率统计时间,以秒为单位"]
    pub staticTime: u32,
    #[doc = "< 编码器输出最大码率,以kbps为单位"]
    pub maxBitRate: u32,
    #[doc = "< 调整I帧QP以调节I帧的图像质量及其码流大小,范围:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "< 开始调整 Qp 时的码率相对于最大码率的比例,取值范围:[50, 100]"]
    pub changePos: u32,
    #[doc = "< 视频质量最低水平, 范围[0-7], 值越低图像质量越高, 但码流越大. minBitRate = maxBitRate * quality[qualityLvl], 其中quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< 帧间QP变化步长"]
    pub frmQPStep: u32,
    #[doc = "< gop间QP变化步长"]
    pub gopQPStep: u32,
    #[doc = "< 最大码率相对平均码率的波动等级,范围:[0,4]"]
    pub flucLvl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265Smart"]
        [::core::mem::size_of::<IMPEncoderAttrH265Smart>() - 40usize];
    ["Alignment of IMPEncoderAttrH265Smart"]
        [::core::mem::align_of::<IMPEncoderAttrH265Smart>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265Smart::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH265Smart::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH265Smart::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH265Smart::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH265Smart::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH265Smart::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH265Smart::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH265Smart::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH265Smart::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH265Smart::flucLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, flucLvl) - 36usize];
};
#[doc = " 定义H.264编码Channel去噪属性,一经使能不能改变,但去噪类型可以动态改变;"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrDenoise {
    #[doc = "< 是否使能去噪功能, 0:忽略,1:按当前帧类型去噪,信息损失最大,2:按I帧去噪，信息损失中等"]
    pub enable: bool,
    #[doc = "< 去噪类型,0:忽略，不降噪,1:使用IP帧类型降噪,2:使用I帧类型降噪"]
    pub dnType: libc::c_int,
    #[doc = "< 去噪I帧量化参数"]
    pub dnIQp: libc::c_int,
    #[doc = "< 去噪P帧量化参数"]
    pub dnPQp: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrDenoise"][::core::mem::size_of::<IMPEncoderAttrDenoise>() - 16usize];
    ["Alignment of IMPEncoderAttrDenoise"]
        [::core::mem::align_of::<IMPEncoderAttrDenoise>() - 4usize];
    ["Offset of field: IMPEncoderAttrDenoise::enable"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, enable) - 0usize];
    ["Offset of field: IMPEncoderAttrDenoise::dnType"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, dnType) - 4usize];
    ["Offset of field: IMPEncoderAttrDenoise::dnIQp"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, dnIQp) - 8usize];
    ["Offset of field: IMPEncoderAttrDenoise::dnPQp"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, dnPQp) - 12usize];
};
#[repr(u32)]
#[doc = " 定义H.264编码Channel输入帧使用模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EncFrmUsedMode {
    #[doc = "< 顺序全使用模式-默认模式"]
    ENC_FRM_BYPASS = 0,
    #[doc = "< 重复使用帧模式"]
    ENC_FRM_REUSED = 1,
    #[doc = "< 丢帧模式"]
    ENC_FRM_SKIP = 2,
}
#[doc = " 定义H.264编码Channel输入帧使用模式属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrFrmUsed {
    #[doc = "< 是否使能输入帧使用模式"]
    pub enable: bool,
    #[doc = "< 输入帧使用模式"]
    pub frmUsedMode: EncFrmUsedMode,
    #[doc = "< 在重复帧或丢帧模式下每次使用的帧间隔"]
    pub frmUsedTimes: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrFrmUsed"][::core::mem::size_of::<IMPEncoderAttrFrmUsed>() - 12usize];
    ["Alignment of IMPEncoderAttrFrmUsed"]
        [::core::mem::align_of::<IMPEncoderAttrFrmUsed>() - 4usize];
    ["Offset of field: IMPEncoderAttrFrmUsed::enable"]
        [::core::mem::offset_of!(IMPEncoderAttrFrmUsed, enable) - 0usize];
    ["Offset of field: IMPEncoderAttrFrmUsed::frmUsedMode"]
        [::core::mem::offset_of!(IMPEncoderAttrFrmUsed, frmUsedMode) - 4usize];
    ["Offset of field: IMPEncoderAttrFrmUsed::frmUsedTimes"]
        [::core::mem::offset_of!(IMPEncoderAttrFrmUsed, frmUsedTimes) - 8usize];
};
impl Default for IMPEncoderAttrFrmUsed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " 定义H.264编码Channel跳帧模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPSkipType {
    #[doc = "< 1倍跳帧参考"]
    IMP_Encoder_STYPE_N1X = 0,
    #[doc = "< 2倍跳帧参考"]
    IMP_Encoder_STYPE_N2X = 1,
    #[doc = "< 4倍跳帧参考"]
    IMP_Encoder_STYPE_N4X = 2,
    #[doc = "< 高级跳帧模式：N1开放跳帧"]
    IMP_Encoder_STYPE_HN1_FALSE = 3,
    #[doc = "< 高级跳帧模式：N1封闭跳帧"]
    IMP_Encoder_STYPE_HN1_TRUE = 4,
    #[doc = "< 高级跳帧模式：1M开放跳帧"]
    IMP_Encoder_STYPE_H1M_FALSE = 5,
    #[doc = "< 高级跳帧模式：1M封闭跳帧"]
    IMP_Encoder_STYPE_H1M_TRUE = 6,
}
#[repr(u32)]
#[doc = " 定义H.264编码Channel帧参考类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPRefType {
    #[doc = "< 高级跳帧模式中的关键帧(IDR帧)"]
    IMP_Encoder_FSTYPE_IDR = 0,
    #[doc = "< 高级跳帧模式中的长期基本帧(P帧)"]
    IMP_Encoder_FSTYPE_LBASE = 1,
    #[doc = "< 高级跳帧模式中的短期基本帧(P帧)"]
    IMP_Encoder_FSTYPE_SBASE = 2,
    #[doc = "< 高级跳帧模式中的增强帧(P帧)"]
    IMP_Encoder_FSTYPE_ENHANCE = 3,
}
#[doc = " 定义H.264编码Channel高级跳帧类型结构体"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrHSkip {
    #[doc = "< 跳帧类型"]
    pub skipType: IMPSkipType,
    #[doc = "< 增强帧间隔数"]
    pub m: libc::c_int,
    #[doc = "< 参考帧间隔数"]
    pub n: libc::c_int,
    #[doc = "< 同一场景占用gop最大数目,仅对H1M Skip类型有效,若设为未大于0,则m值不起作用"]
    pub maxSameSceneCnt: libc::c_int,
    #[doc = "< 是否使能场景切换,仅对H1M Skip类型有效"]
    pub bEnableScenecut: libc::c_int,
    #[doc = "< 是否使得增强帧以空码流输出"]
    pub bBlackEnhance: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrHSkip"][::core::mem::size_of::<IMPEncoderAttrHSkip>() - 24usize];
    ["Alignment of IMPEncoderAttrHSkip"][::core::mem::align_of::<IMPEncoderAttrHSkip>() - 4usize];
    ["Offset of field: IMPEncoderAttrHSkip::skipType"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, skipType) - 0usize];
    ["Offset of field: IMPEncoderAttrHSkip::m"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, m) - 4usize];
    ["Offset of field: IMPEncoderAttrHSkip::n"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, n) - 8usize];
    ["Offset of field: IMPEncoderAttrHSkip::maxSameSceneCnt"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, maxSameSceneCnt) - 12usize];
    ["Offset of field: IMPEncoderAttrHSkip::bEnableScenecut"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, bEnableScenecut) - 16usize];
    ["Offset of field: IMPEncoderAttrHSkip::bBlackEnhance"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, bBlackEnhance) - 20usize];
};
impl Default for IMPEncoderAttrHSkip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义H.264编码Channel高级跳帧类型初始化结构体"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrInitHSkip {
    #[doc = "< 高级跳帧属性"]
    pub hSkipAttr: IMPEncoderAttrHSkip,
    #[doc = "< 需要使用的最大跳帧类型，影响rmem内存大小, N1X 到 N2X 需要分配2个参考重建帧空间, N4X 到 H1M_TRUE 需要分配3个参考重建帧空间, 请按需要的跳帧类型设定"]
    pub maxHSkipType: IMPSkipType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrInitHSkip"]
        [::core::mem::size_of::<IMPEncoderAttrInitHSkip>() - 28usize];
    ["Alignment of IMPEncoderAttrInitHSkip"]
        [::core::mem::align_of::<IMPEncoderAttrInitHSkip>() - 4usize];
    ["Offset of field: IMPEncoderAttrInitHSkip::hSkipAttr"]
        [::core::mem::offset_of!(IMPEncoderAttrInitHSkip, hSkipAttr) - 0usize];
    ["Offset of field: IMPEncoderAttrInitHSkip::maxHSkipType"]
        [::core::mem::offset_of!(IMPEncoderAttrInitHSkip, maxHSkipType) - 24usize];
};
impl Default for IMPEncoderAttrInitHSkip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义H.264编码Channel码率控制器码率控制模式属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderAttrRcMode {
    #[doc = "< RC 模式"]
    pub rcMode: IMPEncoderRcMode,
    pub __anon1: IMPEncoderAttrRcMode__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderAttrRcMode__bindgen_ty_1 {
    #[doc = "< H.264 协议编码Channel Fixqp 模式属性"]
    pub attrH264FixQp: IMPEncoderAttrH264FixQP,
    #[doc = "< H.264 协议编码Channel Cbr 模式属性"]
    pub attrH264Cbr: IMPEncoderAttrH264CBR,
    #[doc = "< H.264 协议编码Channel Vbr 模式属性"]
    pub attrH264Vbr: IMPEncoderAttrH264VBR,
    #[doc = "< H.264 协议编码Channel Smart 模式属性"]
    pub attrH264Smart: IMPEncoderAttrH264Smart,
    #[doc = "< 不支持 H.265协议编码"]
    pub attrH265FixQp: IMPEncoderAttrH265FixQP,
    #[doc = "< 不支持 H.265协议编码"]
    pub attrH265Cbr: IMPEncoderAttrH265CBR,
    #[doc = "< 不支持 H.265协议编码"]
    pub attrH265Vbr: IMPEncoderAttrH265VBR,
    #[doc = "< 不支持 H.265协议编码"]
    pub attrH265Smart: IMPEncoderAttrH265Smart,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrRcMode__bindgen_ty_1"]
        [::core::mem::size_of::<IMPEncoderAttrRcMode__bindgen_ty_1>() - 40usize];
    ["Alignment of IMPEncoderAttrRcMode__bindgen_ty_1"]
        [::core::mem::align_of::<IMPEncoderAttrRcMode__bindgen_ty_1>() - 4usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264FixQp"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264FixQp) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264Cbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264Cbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264Vbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264Vbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264Smart"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264Smart) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265FixQp"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265FixQp) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265Cbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265Cbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265Vbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265Vbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265Smart"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265Smart) - 0usize];
};
impl Default for IMPEncoderAttrRcMode__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrRcMode"][::core::mem::size_of::<IMPEncoderAttrRcMode>() - 44usize];
    ["Alignment of IMPEncoderAttrRcMode"][::core::mem::align_of::<IMPEncoderAttrRcMode>() - 4usize];
    ["Offset of field: IMPEncoderAttrRcMode::rcMode"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode, rcMode) - 0usize];
};
impl Default for IMPEncoderAttrRcMode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义H.264编码Channel码率控制器属性"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderRcAttr {
    #[doc = "< 编码Channel的输出帧率（输出帧率不能大于输入帧率）"]
    pub outFrmRate: IMPEncoderFrmRate,
    #[doc = "< gop值，必须是帧率的整数倍"]
    pub maxGop: u32,
    #[doc = "< 码率控制模式属性"]
    pub attrRcMode: IMPEncoderAttrRcMode,
    #[doc = "< 输入帧使用模式属性"]
    pub attrFrmUsed: IMPEncoderAttrFrmUsed,
    #[doc = "< 去噪属性"]
    pub attrDenoise: IMPEncoderAttrDenoise,
    #[doc = "< 高级跳帧初始化属性"]
    pub attrHSkip: IMPEncoderAttrInitHSkip,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderRcAttr"][::core::mem::size_of::<IMPEncoderRcAttr>() - 112usize];
    ["Alignment of IMPEncoderRcAttr"][::core::mem::align_of::<IMPEncoderRcAttr>() - 4usize];
    ["Offset of field: IMPEncoderRcAttr::outFrmRate"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, outFrmRate) - 0usize];
    ["Offset of field: IMPEncoderRcAttr::maxGop"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, maxGop) - 8usize];
    ["Offset of field: IMPEncoderRcAttr::attrRcMode"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrRcMode) - 12usize];
    ["Offset of field: IMPEncoderRcAttr::attrFrmUsed"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrFrmUsed) - 56usize];
    ["Offset of field: IMPEncoderRcAttr::attrDenoise"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrDenoise) - 68usize];
    ["Offset of field: IMPEncoderRcAttr::attrHSkip"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrHSkip) - 84usize];
};
impl Default for IMPEncoderRcAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " 定义H.264码流NALU类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderH264NaluType {
    #[doc = "< 未指定"]
    IMP_H264_NAL_UNKNOWN = 0,
    #[doc = "< 一个非IDR图像的编码条带"]
    IMP_H264_NAL_SLICE = 1,
    #[doc = "< 编码条带数据分割块A"]
    IMP_H264_NAL_SLICE_DPA = 2,
    #[doc = "< 编码条带数据分割块B"]
    IMP_H264_NAL_SLICE_DPB = 3,
    #[doc = "< 编码条带数据分割块C"]
    IMP_H264_NAL_SLICE_DPC = 4,
    #[doc = "< IDR图像的编码条带"]
    IMP_H264_NAL_SLICE_IDR = 5,
    #[doc = "< 辅助增强信息 (SEI)"]
    IMP_H264_NAL_SEI = 6,
    #[doc = "< 序列参数集"]
    IMP_H264_NAL_SPS = 7,
    #[doc = "< 图像参数集"]
    IMP_H264_NAL_PPS = 8,
    #[doc = "< 访问单元分隔符"]
    IMP_H264_NAL_AUD = 9,
    #[doc = "< 填充数据"]
    IMP_H264_NAL_FILLER = 12,
}
#[repr(u32)]
#[doc = " 定义H.265码流NALU类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderH265NaluType {
    #[doc = "< 尾随图像, 不带参考信息"]
    IMP_H265_NAL_SLICE_TRAIL_N = 0,
    #[doc = "< 尾随图像, 带参考信息"]
    IMP_H265_NAL_SLICE_TRAIL_R = 1,
    #[doc = "< 时域子层接入点图像, 不带参考信息"]
    IMP_H265_NAL_SLICE_TSA_N = 2,
    #[doc = "< 时域子层接入点图像, 带参考信息"]
    IMP_H265_NAL_SLICE_TSA_R = 3,
    #[doc = "< 逐步时域子层接入点图像, 不带参考信息"]
    IMP_H265_NAL_SLICE_STSA_N = 4,
    #[doc = "< 逐步时域子层接入点图像, 带参考信息"]
    IMP_H265_NAL_SLICE_STSA_R = 5,
    #[doc = "< 可解码随机接入前置图像, 不带参考信息"]
    IMP_H265_NAL_SLICE_RADL_N = 6,
    #[doc = "< 可解码随机接入前置图像, 带参考信息"]
    IMP_H265_NAL_SLICE_RADL_R = 7,
    #[doc = "< 跳过随机接入的前置图像, 不带参考信息"]
    IMP_H265_NAL_SLICE_RASL_N = 8,
    #[doc = "< 跳过随机接入的前置图像, 带参考信息"]
    IMP_H265_NAL_SLICE_RASL_R = 9,
    #[doc = "< 断点连接接入, 带前置图像"]
    IMP_H265_NAL_SLICE_BLA_W_LP = 16,
    #[doc = "< 断点连接接入, 带前置图像RADL"]
    IMP_H265_NAL_SLICE_BLA_W_RADL = 17,
    #[doc = "< 断点连接接入, 不带前置图像"]
    IMP_H265_NAL_SLICE_BLA_N_LP = 18,
    #[doc = "< 即时解码刷新, 带前置图像RADL"]
    IMP_H265_NAL_SLICE_IDR_W_RADL = 19,
    #[doc = "< 即时解码刷新, 不带前置图像"]
    IMP_H265_NAL_SLICE_IDR_N_LP = 20,
    #[doc = "< 纯随机接入, 带前置图像"]
    IMP_H265_NAL_SLICE_CRA = 21,
    #[doc = "< 视频参数集"]
    IMP_H265_NAL_VPS = 32,
    #[doc = "< 序列参数集"]
    IMP_H265_NAL_SPS = 33,
    #[doc = "< 图像参数集"]
    IMP_H265_NAL_PPS = 34,
    #[doc = "< 访问单元分隔符"]
    IMP_H265_NAL_AUD = 35,
    #[doc = "< 序列结束"]
    IMP_H265_NAL_EOS = 36,
    #[doc = "< 比特流结束"]
    IMP_H265_NAL_EOB = 37,
    #[doc = "< 填充数据"]
    IMP_H265_NAL_FILLER_DATA = 38,
    #[doc = "< 辅助增强信息 (SEI)"]
    IMP_H265_NAL_PREFIX_SEI = 39,
    #[doc = "< 辅助增强信息 (SEI)"]
    IMP_H265_NAL_SUFFIX_SEI = 40,
    #[doc = "< 无效NAL类型"]
    IMP_H265_NAL_INVALID = 64,
}
#[doc = " 定义H.264编码Channel码流NAL类型"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderDataType {
    #[doc = "< H264E NALU 码流包类型"]
    pub h264Type: IMPEncoderH264NaluType,
    #[doc = "< H265E NALU 码流包类型, 不支持H265编码"]
    pub h265Type: IMPEncoderH265NaluType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderDataType"][::core::mem::size_of::<IMPEncoderDataType>() - 4usize];
    ["Alignment of IMPEncoderDataType"][::core::mem::align_of::<IMPEncoderDataType>() - 4usize];
    ["Offset of field: IMPEncoderDataType::h264Type"]
        [::core::mem::offset_of!(IMPEncoderDataType, h264Type) - 0usize];
    ["Offset of field: IMPEncoderDataType::h265Type"]
        [::core::mem::offset_of!(IMPEncoderDataType, h265Type) - 0usize];
};
impl Default for IMPEncoderDataType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义编码帧码流包结构体"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderPack {
    #[doc = "< 码流包物理地址"]
    pub phyAddr: u32,
    #[doc = "< 码流包虚拟地址"]
    pub virAddr: u32,
    #[doc = "< 码流包长度"]
    pub length: u32,
    #[doc = "< 时间戳，单位us"]
    pub timestamp: i64,
    #[doc = "< 帧结束标识"]
    pub frameEnd: bool,
    #[doc = "< H.264Channel码流NAL类型"]
    pub dataType: IMPEncoderDataType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderPack"][::core::mem::size_of::<IMPEncoderPack>() - 32usize];
    ["Alignment of IMPEncoderPack"][::core::mem::align_of::<IMPEncoderPack>() - 8usize];
    ["Offset of field: IMPEncoderPack::phyAddr"]
        [::core::mem::offset_of!(IMPEncoderPack, phyAddr) - 0usize];
    ["Offset of field: IMPEncoderPack::virAddr"]
        [::core::mem::offset_of!(IMPEncoderPack, virAddr) - 4usize];
    ["Offset of field: IMPEncoderPack::length"]
        [::core::mem::offset_of!(IMPEncoderPack, length) - 8usize];
    ["Offset of field: IMPEncoderPack::timestamp"]
        [::core::mem::offset_of!(IMPEncoderPack, timestamp) - 16usize];
    ["Offset of field: IMPEncoderPack::frameEnd"]
        [::core::mem::offset_of!(IMPEncoderPack, frameEnd) - 24usize];
    ["Offset of field: IMPEncoderPack::dataType"]
        [::core::mem::offset_of!(IMPEncoderPack, dataType) - 28usize];
};
impl Default for IMPEncoderPack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义编码帧码流类型结构体"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderStream {
    #[doc = "< 帧码流包结构"]
    pub pack: *mut IMPEncoderPack,
    #[doc = "< 一帧码流的所有包的个数"]
    pub packCount: u32,
    #[doc = "< 编码帧码流序列号"]
    pub seq: u32,
    #[doc = "< 编码帧参考类型, 只针对H264"]
    pub refType: IMPRefType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderStream"][::core::mem::size_of::<IMPEncoderStream>() - 16usize];
    ["Alignment of IMPEncoderStream"][::core::mem::align_of::<IMPEncoderStream>() - 4usize];
    ["Offset of field: IMPEncoderStream::pack"]
        [::core::mem::offset_of!(IMPEncoderStream, pack) - 0usize];
    ["Offset of field: IMPEncoderStream::packCount"]
        [::core::mem::offset_of!(IMPEncoderStream, packCount) - 4usize];
    ["Offset of field: IMPEncoderStream::seq"]
        [::core::mem::offset_of!(IMPEncoderStream, seq) - 8usize];
    ["Offset of field: IMPEncoderStream::refType"]
        [::core::mem::offset_of!(IMPEncoderStream, refType) - 12usize];
};
impl Default for IMPEncoderStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义编码器裁剪属性，针对输入编码器的图像先做裁剪，与编码通道的尺寸进行比较再做缩放"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderCropCfg {
    #[doc = "< 是否进行裁剪,取值范围:[FALSE, TRUE],TRUE:使能裁剪,FALSE:不使能裁剪"]
    pub enable: bool,
    #[doc = "< 裁剪的区域,左上角x坐标"]
    pub x: u32,
    #[doc = "< 裁剪的区域,左上角y坐标"]
    pub y: u32,
    #[doc = "< 裁剪的区域,宽"]
    pub w: u32,
    #[doc = "< 裁剪的区域,高"]
    pub h: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderCropCfg"][::core::mem::size_of::<IMPEncoderCropCfg>() - 20usize];
    ["Alignment of IMPEncoderCropCfg"][::core::mem::align_of::<IMPEncoderCropCfg>() - 4usize];
    ["Offset of field: IMPEncoderCropCfg::enable"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, enable) - 0usize];
    ["Offset of field: IMPEncoderCropCfg::x"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, x) - 4usize];
    ["Offset of field: IMPEncoderCropCfg::y"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, y) - 8usize];
    ["Offset of field: IMPEncoderCropCfg::w"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, w) - 12usize];
    ["Offset of field: IMPEncoderCropCfg::h"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, h) - 16usize];
};
#[doc = " 定义编码器插入用户数据属性,只针对H264"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderUserDataCfg {
    #[doc = "< 最大用户插入数据缓存空间个数,范围：0-2"]
    pub maxUserDataCnt: u32,
    #[doc = "< 最大用户插入数据缓存空间大小,范围：16-1024"]
    pub maxUserDataSize: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderUserDataCfg"][::core::mem::size_of::<IMPEncoderUserDataCfg>() - 8usize];
    ["Alignment of IMPEncoderUserDataCfg"]
        [::core::mem::align_of::<IMPEncoderUserDataCfg>() - 4usize];
    ["Offset of field: IMPEncoderUserDataCfg::maxUserDataCnt"]
        [::core::mem::offset_of!(IMPEncoderUserDataCfg, maxUserDataCnt) - 0usize];
    ["Offset of field: IMPEncoderUserDataCfg::maxUserDataSize"]
        [::core::mem::offset_of!(IMPEncoderUserDataCfg, maxUserDataSize) - 4usize];
};
#[doc = " 定义编码器属性结构体"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttr {
    #[doc = "< 编码协议类型"]
    pub enType: IMPPayloadType,
    #[doc = "< 配置 buffer 大小，取值范围:不小于图像宽高乘积的1.5倍。设置通道编码属性时，将此参数设置为0，IMP内部会自动计算大小"]
    pub bufSize: u32,
    #[doc = "< 编码的等级, 0: baseline; 1:MP; 2:HP"]
    pub profile: u32,
    #[doc = "< 编码图像宽度"]
    pub picWidth: u32,
    #[doc = "< 编码图像高度"]
    pub picHeight: u32,
    #[doc = "< 编码器裁剪属性"]
    pub crop: IMPEncoderCropCfg,
    #[doc = "< 插入用户数据属性,只针对H264"]
    pub userData: IMPEncoderUserDataCfg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttr"][::core::mem::size_of::<IMPEncoderAttr>() - 48usize];
    ["Alignment of IMPEncoderAttr"][::core::mem::align_of::<IMPEncoderAttr>() - 4usize];
    ["Offset of field: IMPEncoderAttr::enType"]
        [::core::mem::offset_of!(IMPEncoderAttr, enType) - 0usize];
    ["Offset of field: IMPEncoderAttr::bufSize"]
        [::core::mem::offset_of!(IMPEncoderAttr, bufSize) - 4usize];
    ["Offset of field: IMPEncoderAttr::profile"]
        [::core::mem::offset_of!(IMPEncoderAttr, profile) - 8usize];
    ["Offset of field: IMPEncoderAttr::picWidth"]
        [::core::mem::offset_of!(IMPEncoderAttr, picWidth) - 12usize];
    ["Offset of field: IMPEncoderAttr::picHeight"]
        [::core::mem::offset_of!(IMPEncoderAttr, picHeight) - 16usize];
    ["Offset of field: IMPEncoderAttr::crop"]
        [::core::mem::offset_of!(IMPEncoderAttr, crop) - 20usize];
    ["Offset of field: IMPEncoderAttr::userData"]
        [::core::mem::offset_of!(IMPEncoderAttr, userData) - 40usize];
};
impl Default for IMPEncoderAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义编码Channel属性结构体"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderCHNAttr {
    #[doc = "< 编码器属性结构体"]
    pub encAttr: IMPEncoderAttr,
    #[doc = "< 码率控制器属性结构体,只针对H264"]
    pub rcAttr: IMPEncoderRcAttr,
    #[doc = "< ISP VPU Direct Connect使能标志"]
    pub bEnableIvdc: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderCHNAttr"][::core::mem::size_of::<IMPEncoderCHNAttr>() - 164usize];
    ["Alignment of IMPEncoderCHNAttr"][::core::mem::align_of::<IMPEncoderCHNAttr>() - 4usize];
    ["Offset of field: IMPEncoderCHNAttr::encAttr"]
        [::core::mem::offset_of!(IMPEncoderCHNAttr, encAttr) - 0usize];
    ["Offset of field: IMPEncoderCHNAttr::rcAttr"]
        [::core::mem::offset_of!(IMPEncoderCHNAttr, rcAttr) - 48usize];
    ["Offset of field: IMPEncoderCHNAttr::bEnableIvdc"]
        [::core::mem::offset_of!(IMPEncoderCHNAttr, bEnableIvdc) - 160usize];
};
impl Default for IMPEncoderCHNAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义编码Channel的状态结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderCHNStat {
    #[doc = "< 注册到Group标志，取值范围:{TRUE, FALSE}，TRUE:注册，FALSE:未注册"]
    pub registered: bool,
    #[doc = "< 待编码的图像数"]
    pub leftPics: u32,
    #[doc = "< 码流buffer剩余的byte数"]
    pub leftStreamBytes: u32,
    #[doc = "< 码流buffer剩余的帧数"]
    pub leftStreamFrames: u32,
    #[doc = "< 当前帧的码流包个数"]
    pub curPacks: u32,
    #[doc = "< 通道程序运行状态，0：正在运行，1，未运行"]
    pub work_done: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderCHNStat"][::core::mem::size_of::<IMPEncoderCHNStat>() - 24usize];
    ["Alignment of IMPEncoderCHNStat"][::core::mem::align_of::<IMPEncoderCHNStat>() - 4usize];
    ["Offset of field: IMPEncoderCHNStat::registered"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, registered) - 0usize];
    ["Offset of field: IMPEncoderCHNStat::leftPics"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, leftPics) - 4usize];
    ["Offset of field: IMPEncoderCHNStat::leftStreamBytes"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, leftStreamBytes) - 8usize];
    ["Offset of field: IMPEncoderCHNStat::leftStreamFrames"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, leftStreamFrames) - 12usize];
    ["Offset of field: IMPEncoderCHNStat::curPacks"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, curPacks) - 16usize];
    ["Offset of field: IMPEncoderCHNStat::work_done"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, work_done) - 20usize];
};
#[doc = " 定义彩转灰(C2G)参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderColor2GreyCfg {
    #[doc = "< 开启或关闭彩转灰功能"]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderColor2GreyCfg"][::core::mem::size_of::<IMPEncoderColor2GreyCfg>() - 1usize];
    ["Alignment of IMPEncoderColor2GreyCfg"]
        [::core::mem::align_of::<IMPEncoderColor2GreyCfg>() - 1usize];
    ["Offset of field: IMPEncoderColor2GreyCfg::enable"]
        [::core::mem::offset_of!(IMPEncoderColor2GreyCfg, enable) - 0usize];
};
#[doc = " 定义H.264编码Channel设置EnableIDR参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderEnIDRCfg {
    #[doc = "< 是否设置EnableIDR"]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderEnIDRCfg"][::core::mem::size_of::<IMPEncoderEnIDRCfg>() - 1usize];
    ["Alignment of IMPEncoderEnIDRCfg"][::core::mem::align_of::<IMPEncoderEnIDRCfg>() - 1usize];
    ["Offset of field: IMPEncoderEnIDRCfg::enable"]
        [::core::mem::offset_of!(IMPEncoderEnIDRCfg, enable) - 0usize];
};
#[doc = " 定义H.264编码Channel设置gopsize参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderGOPSizeCfg {
    #[doc = "< IDR参数"]
    pub gopsize: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderGOPSizeCfg"][::core::mem::size_of::<IMPEncoderGOPSizeCfg>() - 4usize];
    ["Alignment of IMPEncoderGOPSizeCfg"][::core::mem::align_of::<IMPEncoderGOPSizeCfg>() - 4usize];
    ["Offset of field: IMPEncoderGOPSizeCfg::gopsize"]
        [::core::mem::offset_of!(IMPEncoderGOPSizeCfg, gopsize) - 0usize];
};
#[doc = " 定义H.264编码Channel设置ROI参数"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderROICfg {
    #[doc = "< ROI区域索引值，支持0-7"]
    pub u32Index: u32,
    #[doc = "< 是否使能本区域ROI功能"]
    pub bEnable: bool,
    #[doc = "< 0：绝对ROI，1：相对ROI"]
    pub bRelatedQp: bool,
    #[doc = "< ROI区域的相对或绝对qp值"]
    pub s32Qp: libc::c_int,
    #[doc = "< 区域坐标属性"]
    pub rect: IMPRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderROICfg"][::core::mem::size_of::<IMPEncoderROICfg>() - 28usize];
    ["Alignment of IMPEncoderROICfg"][::core::mem::align_of::<IMPEncoderROICfg>() - 4usize];
    ["Offset of field: IMPEncoderROICfg::u32Index"]
        [::core::mem::offset_of!(IMPEncoderROICfg, u32Index) - 0usize];
    ["Offset of field: IMPEncoderROICfg::bEnable"]
        [::core::mem::offset_of!(IMPEncoderROICfg, bEnable) - 4usize];
    ["Offset of field: IMPEncoderROICfg::bRelatedQp"]
        [::core::mem::offset_of!(IMPEncoderROICfg, bRelatedQp) - 5usize];
    ["Offset of field: IMPEncoderROICfg::s32Qp"]
        [::core::mem::offset_of!(IMPEncoderROICfg, s32Qp) - 8usize];
    ["Offset of field: IMPEncoderROICfg::rect"]
        [::core::mem::offset_of!(IMPEncoderROICfg, rect) - 12usize];
};
#[repr(u32)]
#[doc = " 定义H.264编码Channel码率控制中超大帧处理模式"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderSuperFrmMode {
    #[doc = "< 无特殊策略, 支持"]
    IMP_RC_SUPERFRM_NONE = 0,
    #[doc = "< 丢弃超大帧, 不支持, 由调用者自己决定是否丢弃"]
    IMP_RC_SUPERFRM_DISCARD = 1,
    #[doc = "< 重编超大帧, 支持"]
    IMP_RC_SUPERFRM_REENCODE = 2,
    IMP_RC_SUPERFRM_BUTT = 3,
}
#[repr(u32)]
#[doc = " 定义H.264编码Channel码率控制优先级枚举"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderRcPriority {
    #[doc = "< 目标码率与质量平衡"]
    IMP_RC_PRIORITY_RDO = 0,
    #[doc = "< 目标码率优先"]
    IMP_RC_PRIORITY_BITRATE_FIRST = 1,
    #[doc = "< 超大帧阈值优先"]
    IMP_RC_PRIORITY_FRAMEBITS_FIRST = 2,
    IMP_RC_PRIORITY_BUTT = 3,
}
#[doc = " 定义H.264编码Channel超大帧处理策略参数"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderSuperFrmCfg {
    #[doc = "< 超大帧处理模式,默认为 SUPERFRM_REENCODE"]
    pub superFrmMode: IMPEncoderSuperFrmMode,
    #[doc = "< I 帧超大阈值, 默认为w*h*3/2*8/ratio, ratio: 主分辨率为6, 次分辨率为3"]
    pub superIFrmBitsThr: u32,
    #[doc = "< P 帧超大阈值, 默认为I帧超大阈值除以1.4"]
    pub superPFrmBitsThr: u32,
    #[doc = "< B 帧超大阈值, 默认为P帧超大阈值除以1.3, 暂不支持B帧"]
    pub superBFrmBitsThr: u32,
    #[doc = "< 码率控制优先级, 默认为 IMP_RC_PRIORITY_RDO"]
    pub rcPriority: IMPEncoderRcPriority,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderSuperFrmCfg"][::core::mem::size_of::<IMPEncoderSuperFrmCfg>() - 20usize];
    ["Alignment of IMPEncoderSuperFrmCfg"]
        [::core::mem::align_of::<IMPEncoderSuperFrmCfg>() - 4usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superFrmMode"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superFrmMode) - 0usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superIFrmBitsThr"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superIFrmBitsThr) - 4usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superPFrmBitsThr"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superPFrmBitsThr) - 8usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superBFrmBitsThr"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superBFrmBitsThr) - 12usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::rcPriority"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, rcPriority) - 16usize];
};
impl Default for IMPEncoderSuperFrmCfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义 H.264 协议编码通道色度量化结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderH264TransCfg {
    #[doc = "< 具体含义请参见 H.264 协议, 系统默认值为 0; 取值范围:[-12, 12]"]
    pub chroma_qp_index_offset: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderH264TransCfg"][::core::mem::size_of::<IMPEncoderH264TransCfg>() - 4usize];
    ["Alignment of IMPEncoderH264TransCfg"]
        [::core::mem::align_of::<IMPEncoderH264TransCfg>() - 4usize];
    ["Offset of field: IMPEncoderH264TransCfg::chroma_qp_index_offset"]
        [::core::mem::offset_of!(IMPEncoderH264TransCfg, chroma_qp_index_offset) - 0usize];
};
#[doc = " 定义 H.265 协议编码通道色度量化结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderH265TransCfg {
    #[doc = "< 不支持H.265协议编码"]
    pub chroma_cr_qp_offset: libc::c_int,
    #[doc = "< 不支持H.265协议编码"]
    pub chroma_cb_qp_offset: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderH265TransCfg"][::core::mem::size_of::<IMPEncoderH265TransCfg>() - 8usize];
    ["Alignment of IMPEncoderH265TransCfg"]
        [::core::mem::align_of::<IMPEncoderH265TransCfg>() - 4usize];
    ["Offset of field: IMPEncoderH265TransCfg::chroma_cr_qp_offset"]
        [::core::mem::offset_of!(IMPEncoderH265TransCfg, chroma_cr_qp_offset) - 0usize];
    ["Offset of field: IMPEncoderH265TransCfg::chroma_cb_qp_offset"]
        [::core::mem::offset_of!(IMPEncoderH265TransCfg, chroma_cb_qp_offset) - 4usize];
};
#[repr(u32)]
#[doc = " 定义宏块级编码控制模式结构体, H264仅支持1-4"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderQpgMode {
    #[doc = "< 关闭宏块级编码控制"]
    ENC_QPG_CLOSE = 0,
    #[doc = "< 开启CRP模式(默认)"]
    ENC_QPG_CRP = 1,
    #[doc = "< 开启SAS模式"]
    ENC_QPG_SAS = 2,
    #[doc = "< 开启SAS模式并使能多阈值模式"]
    ENC_QPG_SASM = 3,
    #[doc = "< 开启宏块级码率控制"]
    ENC_QPG_MBRC = 4,
    #[doc = "< 开启CRP模式和QP_TAB"]
    ENC_QPG_CRP_TAB = 5,
    #[doc = "< 开启SAS模式和QP_TAB"]
    ENC_QPG_SAS_TAB = 6,
    #[doc = "< 开启SAS模式并使能多阈值模式和QP_TAB"]
    ENC_QPG_SASM_TAB = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderJpegeQl {
    #[doc = "< 0: 使用默认量化表; 1:使用用户量化表"]
    pub user_ql_en: bool,
    #[doc = "< 用户自定义量化表"]
    pub qmem_table: [u8; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderJpegeQl"][::core::mem::size_of::<IMPEncoderJpegeQl>() - 129usize];
    ["Alignment of IMPEncoderJpegeQl"][::core::mem::align_of::<IMPEncoderJpegeQl>() - 1usize];
    ["Offset of field: IMPEncoderJpegeQl::user_ql_en"]
        [::core::mem::offset_of!(IMPEncoderJpegeQl, user_ql_en) - 0usize];
    ["Offset of field: IMPEncoderJpegeQl::qmem_table"]
        [::core::mem::offset_of!(IMPEncoderJpegeQl, qmem_table) - 1usize];
};
impl Default for IMPEncoderJpegeQl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_CreateGroup(int encGroup)\n\n 创建编码Group\n\n @param[in] encGroup Group号,取值范围:[0, @ref NR_MAX_ENC_GROUPS - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 一路Group仅支持一路分辨率，不同分辨率需启动新的Group。一路Group允许最多注册2个编码channel\n\n @attention 如果指定的Group已经存在，则返回失败"]
    pub fn IMP_Encoder_CreateGroup(encGroup: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_DestroyGroup(int encGroup)\n\n 销毁编码Grouop.\n\n @param[in] encGroup Group号,取值范围:[0, @ref NR_MAX_ENC_GROUPS - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 销毁Group时，必须保证Group为空，即没有任何Channel在Group中注册，或注册到Group中的Channel已经反注册，否则返回失败\n\n @attention 销毁并不存在的Group，则返回失败"]
    pub fn IMP_Encoder_DestroyGroup(encGroup: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_CreateChn(int encChn, const IMPEncoderCHNAttr *attr)\n\n 创建编码Channel\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] attr 编码Channel属性指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 编码Channel属性由两部分组成，编码器属性和码率控制属性\n @remark 编码器属性首先需要选择编码协议，然后分别对各种协议对应的属性进行赋值"]
    pub fn IMP_Encoder_CreateChn(
        encChn: libc::c_int,
        attr: *const IMPEncoderCHNAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_DestroyChn(int encChn)\n\n 销毁编码Channel\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @attention 销毁并不存在的Channel，则返回失败\n @attention 销毁前必须保证Channel已经从Group反注册，否则返回失败"]
    pub fn IMP_Encoder_DestroyChn(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnAttr(int encChn, IMPEncoderCHNAttr * const attr)\n\n 获取编码Channel的属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] attr 编码Channel属性\n\n @retval 0 成功\n @retval 非0 失败"]
    pub fn IMP_Encoder_GetChnAttr(encChn: libc::c_int, attr: *mut IMPEncoderCHNAttr)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_RegisterChn(int encGroup, int encChn)\n\n 注册编码Channel到Group\n\n @param[in] encGroup 编码Group号,取值范围: [0, @ref NR_MAX_ENC_GROUPS - 1]\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @attention 注册并不存在的Channel，则返回失败\n @attention 注册Channel到不存在的Group，否则返回失败\n @attention 同一个编码Channel只能注册到一个Group，如果该Channel已经注册到某个Group，则返回失败\n @attention 如果一个Group已经被注册，那么这个Group就不能再被其他的Channel注册，除非之前注册关系被解除"]
    pub fn IMP_Encoder_RegisterChn(encGroup: libc::c_int, encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_UnRegisterChn(int encChn)\n\n 反注册编码Channel到Group\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark Channel注销之后，编码Channel会被复位，编码Channel里的码流buffer都会被清空，如果用户还在使用未及时释放的码流buffer，将不能保证buffer数据的正确性\n @remark 用户可以使用IMP_Encoder_Query接口来查询编码Channel码流buffer状态，确认码流buffer里的码流取完之后再反注册Channel\n\n @attention 注销未创建的Channel，则返回失败\n @attention 注销未注册的Channel，则返回失败\n @attention 如果编码Channel未停止接收图像编码，则返回失败"]
    pub fn IMP_Encoder_UnRegisterChn(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_StartRecvPic(int encChn)\n\n 开启编码Channel接收图像\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 开启编码Channel接收图像后才能开始编码\n\n @attention 如果Channel未创建，则返回失败\n @attention 如果Channel没有注册到Group，则返回失败"]
    pub fn IMP_Encoder_StartRecvPic(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_StopRecvPic(int encChn)\n\n 停止编码Channel接收图像\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 此接口并不判断当前是否停止接收，即允许重复停止接收不返回错误\n @remark 调用此接口仅停止接收原始数据编码，码流buffer并不会被消除\n\n @attention 如果Channel未创建，则返回失败\n @attention 如果Channel没有注册到Group，则返回失败"]
    pub fn IMP_Encoder_StopRecvPic(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_Query(int encChn, IMPEncoderCHNStat *stat)\n\n 查询编码Channel状态\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] stat 编码Channel状态\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无\n\n @attention 无"]
    pub fn IMP_Encoder_Query(encChn: libc::c_int, stat: *mut IMPEncoderCHNStat) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetStream(int encChn, IMPEncoderStream *stream, bool blockFlag)\n\n 获取编码的码流\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] stream 码流结构体指针\n @param[in] blockFlag 是否使用阻塞方式获取，0：非阻塞，1：阻塞\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 每次获取一帧码流的数据\n @remark 如果用户长时间不获取码流,码流缓冲区就会满。一个编码Channel如果发生码流缓冲区满,就会把后 \\n\n 面接收的图像丢掉,直到用户获取码流,从而有足够的码流缓冲可以用于编码时,才开始继续编码。建议用户   \\n\n 获取码流接口调用与释放码流的接口调用成对出现,且尽快释放码流,防止出现由于用户态获取码流,释放不   \\n\n 及时而导致的码流 buffer 满,停止编码。\n @remark 对于H264类型码流，一次调用成功获取一帧的码流，这帧码流可能包含多个包。\n @remark 对于JPEG类型码流，一次调用成功获取一帧的码流，这帧码流只包含一个包，这一帧包含了JPEG图片文件的完整信息。\n\n 示例：\n @code\n int ret;\n ret = IMP_Encoder_PollingStream(ENC_H264_CHANNEL, 1000); //Polling码流Buffer，等待可获取状态\n if (ret < 0) {\n     printf(\"Polling stream timeout\\n\");\n     return -1;\n }\n\n IMPEncoderStream stream;\n ret = IMP_Encoder_GetStream(ENC_H264_CHANNEL, &stream, 1); //获取一帧码流，阻塞方式\n if (ret < 0) {\n     printf(\"Get Stream failed\\n\");\n     return -1;\n }\n\n int i, nr_pack = stream.packCount;\n for (i = 0; i < nr_pack; i++) { //保存这一帧码流的每个包\n     ret = write(stream_fd, (void *)stream.pack[i].virAddr,\n                stream.pack[i].length);\n     if (ret != stream.pack[i].length) {\n         printf(\"stream write error:%s\\n\", strerror(errno));\n         return -1;\n     }\n }\n @endcode\n\n @attention 如果pstStream为NULL,则返回失败；\n @attention 如果Channel未创建，则返回失败；"]
    pub fn IMP_Encoder_GetStream(
        encChn: libc::c_int,
        stream: *mut IMPEncoderStream,
        blockFlag: bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_ReleaseStream(int encChn, IMPEncoderStream *stream)\n\n 释放码流缓存\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] stream 码流结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 此接口应当和IMP_Encoder_GetStream配对起来使用，\\n\n 用户获取码流后必须及时释放已经获取的码流缓存，否则可能会导致码流buffer满，影响编码器编码。\\n\n 并且用户必须按先获取先释放的顺序释放已经获取的码流缓存。\n @remark 在编码Channel反注册后，所有未释放的码流包均无效，不能再使用或者释放这部分无效的码流缓存。\n\n @attention 如果pstStream为NULL,则返回失败；\n @attention 如果Channel未创建，则返回失败；\n @attention 释放无效的码流会返回失败。"]
    pub fn IMP_Encoder_ReleaseStream(
        encChn: libc::c_int,
        stream: *mut IMPEncoderStream,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_PollingStream(int encChn, uint32_t timeoutMsec)\n\n Polling码流缓存\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] timeoutMsec 超时时间，单位：毫秒\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 在获取码流之前可以用过此API进行Polling，当码流缓存不为空时或超时时函数返回。\n\n @attention 无"]
    pub fn IMP_Encoder_PollingStream(encChn: libc::c_int, timeoutMsec: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetFd(int encChn)\n\n 获取编码Channel对应的设备文件句柄\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval >=0 成功, 返回设备文件描述符\n @retval < 0 失败\n\n @remark 在使用IMP_Encoder_PollingStream不合适的场合，比如在同一个地方Polling多个编码channel的编码完成情况时, \\n\n 可以使用此文件句柄调用select, poll等类似函数来阻塞等待编码完成事件\n @remark 调用此API需要通道已经存在\n\n @attention 无"]
    pub fn IMP_Encoder_GetFd(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetMaxStreamCnt(int encChn, int nrMaxStream)\n\n 设置码流缓存Buffer个数\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] nrMaxStream 码流Buffer数,取值范围: [1, @ref NR_MAX_ENC_CHN_STREAM]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 由于码流缓存Buffer个数在通道创建时就已经固定，因此次API需要在通道创建之前调用。\n @remark 若通道创建之前不调用此API设置码流缓存Buffer个数，则使用SDK默认的buffer个数。\n\n @attention 无"]
    pub fn IMP_Encoder_SetMaxStreamCnt(
        encChn: libc::c_int,
        nrMaxStream: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetMaxStreamCnt(int encChn, int *nrMaxStream)\n\n 获取码流Buffer数\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] nrMaxStream 码流Buffer数变量指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无\n\n @attention 无"]
    pub fn IMP_Encoder_GetMaxStreamCnt(
        encChn: libc::c_int,
        nrMaxStream: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_RequestIDR(int encChn)\n\n 请求IDR帧\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 在调用此API后，会在最近的编码帧申请IDR帧编码。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_RequestIDR(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_FlushStream(int encChn)\n\n 刷掉编码器里残留的旧码流，并以IDR帧开始编码\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 在调用此API后，会在最近的编码帧申请IDR帧编码。\n\n @attention 无"]
    pub fn IMP_Encoder_FlushStream(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnColor2Grey(int encChn, const IMPEncoderColor2GreyCfg *pstColor2Grey).\n\n 设置彩转灰功能\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstColor2Grey 彩转灰功能的参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API设置通道的彩转灰功能，在下一个IDR或者P帧生效。\n @remark 调用此API需要通道已经存在。\n\n @attention 无"]
    pub fn IMP_Encoder_SetChnColor2Grey(
        encChn: libc::c_int,
        pstColor2Grey: *const IMPEncoderColor2GreyCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnColor2Grey(int encChn, IMPEncoderColor2GreyCfg *pstColor2Grey).\n\n 获取彩转灰功能属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstColor2Grey 彩转灰功能的参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的彩转灰功能属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnColor2Grey(
        encChn: libc::c_int,
        pstColor2Grey: *mut IMPEncoderColor2GreyCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnAttrRcMode(int encChn, const IMPEncoderAttrRcMode *pstRcModeCfg).\n\n 设置码率控制模式属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstRcCfg 码率控制模式属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道的码率控制模式属性，下一个IDR生效,调用此API需要通道已经存在。\n\n @attention 目前，码率控制模式支持ENC_RC_MODE_FIXQP, ENC_RC_MODE_CBR, ENC_RC_MODE_VBR 与 ENC_RC_MODE_SMART\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnAttrRcMode(
        encChn: libc::c_int,
        pstRcModeCfg: *const IMPEncoderAttrRcMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnAttrRcMode(int encChn, IMPEncoderAttrRcMode *pstRcModeCfg).\n\n 获取码率控制模式属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstRcCfg 码率控制模式属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的码率控制模式属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnAttrRcMode(
        encChn: libc::c_int,
        pstRcModeCfg: *mut IMPEncoderAttrRcMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnFrmRate(int encChn, const IMPEncoderFrmRate *pstFps)\n\n 动态设置帧率控制属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg 帧率控制属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会重新设置编码器帧率属性，帧率属性在下一个GOP生效，最大延时1秒钟生效，调用此API需要通道已经存在。\n @remark 如果调用IMP_FrameSource_SetChnFPS()函数动态改变系统帧率，那么需要调用该函数修改编码器帧率，完成正确参数配置。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnFrmRate(
        encChn: libc::c_int,
        pstFps: *const IMPEncoderFrmRate,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnFrmRate(int encChn, IMPEncoderFrmRate *pstFps)\n\n 获取帧率控制属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg 帧率控制属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的帧率控制属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnFrmRate(
        encChn: libc::c_int,
        pstFps: *mut IMPEncoderFrmRate,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnROI(int encChn, const IMPEncoderROICfg *pstVencRoiCfg)\n\n 设置通道ROI属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg ROI属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道的ROI属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnROI(
        encChn: libc::c_int,
        pstVencRoiCfg: *const IMPEncoderROICfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnROI(int encChn, IMPEncoderROICfg *pstVencRoiCfg)\n\n 获取通道ROI属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg ROI属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的ROI属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnROI(
        encChn: libc::c_int,
        pstVencRoiCfg: *mut IMPEncoderROICfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetGOPSize(int encChn, IMPEncoderGOPSizeCfg *pstGOPSizeCfg)\n\n 获取通道GOP属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstGOPSizeCfg GOPSize属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的GOPSize属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetGOPSize(
        encChn: libc::c_int,
        pstGOPSizeCfg: *mut IMPEncoderGOPSizeCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetGOPSize(int encChn, const IMPEncoderGOPSizeCfg *pstGOPSizeCfg)\n\n 设置通道GOP属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstGOPSizeCfg GOP属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道的GOPSize属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetGOPSize(
        encChn: libc::c_int,
        pstGOPSizeCfg: *const IMPEncoderGOPSizeCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnFrmUsedMode(int encChn, const IMPEncoderAttrFrmUsed *pfrmUsedAttr)\n\n 设置通道输入帧使用模式属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pfrmUsedAttr 输入帧使用模式属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道的输入帧使用模式属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnFrmUsedMode(
        encChn: libc::c_int,
        pfrmUsedAttr: *const IMPEncoderAttrFrmUsed,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnFrmUsedMode(int encChn, IMPEncoderAttrFrmUsed *pfrmUsedAttr)\n\n 获取通道输入帧使用模式属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pfrmUsedAttr 输入帧使用模式属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的输入帧使用模式属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnFrmUsedMode(
        encChn: libc::c_int,
        pfrmUsedAttr: *mut IMPEncoderAttrFrmUsed,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnDenoise(int encChn, const IMPEncoderAttrDenoise *pdenoiseAttr)\n\n 设置通道去噪属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pdenoiseAttr 去噪属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道的去噪属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnDenoise(
        encChn: libc::c_int,
        pdenoiseAttr: *const IMPEncoderAttrDenoise,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnDenoise(int encChn, IMPEncoderAttrDenoise *pdenoiseAttr)\n\n 获取通道去噪属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pdenoiseAttr 去噪属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道的去噪属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnDenoise(
        encChn: libc::c_int,
        pdenoiseAttr: *mut IMPEncoderAttrDenoise,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnHSkip(int encChn, const IMPEncoderAttrHSkip *phSkipAttr)\n\n 设置通道高级跳帧属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] phSkipAttr 高级跳帧属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道高级跳帧属性，调用此API需要通道已经存在。\n @remark 若创建通道时设置的高级跳帧类型是 IMP_Encoder_STYPE_N1X 到 IMP_Encoder_STYPE_N2X 中的一个, \\n\n 此API设置跳帧类型只能为 IMP_Encoder_STYPE_N1X 或 IMP_Encoder_STYPE_N2X 中的任意一个\n @remark 若创建通道时设置的高级跳帧类型是 IMP_Encoder_STYPE_N4X 到 IMP_Encoder_STYPE_H1M_TRUE 中的一个，\\n\n 则可以设置为任意一个高级跳帧类型\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnHSkip(
        encChn: libc::c_int,
        phSkipAttr: *const IMPEncoderAttrHSkip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnHSkip(int encChn, IMPEncoderAttrHSkip *phSkipAttr)\n\n 获取通道高级跳帧属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] phSkipAttr 高级跳帧属性参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会获取通道高级跳帧属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChnHSkip(
        encChn: libc::c_int,
        phSkipAttr: *mut IMPEncoderAttrHSkip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnHSkipBlackEnhance(int encChn, const int bBlackEnhance)\n\n 设置通道高级跳帧中bBlackEnhance属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] bBlackEnhance 逻辑值，对应IMPEncoderAttrHSkip中bBlackEnhance值\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API会设置通道高级跳帧中bBlackEnhance属性，调用此API需要通道已经存在。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChnHSkipBlackEnhance(
        encChn: libc::c_int,
        bBlackEnhance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_InsertUserData(int encChn, void *userData, uint32_t userDataLen)\n\n 插入用户数据\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] userData 用户数据指针\n @param[in] userDataLen 用户数据长度, 取值范围:(0, 1024],以 byte 为单位\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 调用此API需要通道已经存在\n @remark 如果通道未创建,则返回失败\n @remark 如果userData为空或userDataLen为0,则返回失败\n @remark 插入用户数据,只支持H.264编码协议\n @remark 最多分配2块内存空间用于缓存用户数据,且每段用户数据大小不超过1k byte。\\n\n 如果用户插入的数据多余2块,或插入的一段用户数据大于1k byte 时,此接口会返回错误。\n @remark 每段用户数据以SEI包的形式被插入到最新的图像码流包之前。在某段用户数据包被编码发送之后, \\n\n 通道内缓存这段用户数据的内存空间被清零,用于存放新的用户数据\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_InsertUserData(
        encChn: libc::c_int,
        userData: *mut libc::c_void,
        userDataLen: u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetFisheyeEnableStatus(int encChn, int enable)\n\n 设置Ingenic提供的鱼眼矫正算法的使能状态\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] enable 0:不使能(默认),1:使能\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 由于鱼眼矫正算法的使能状态在通道创建时就已经固定，因此次API需要在通道创建之前调用。\n @remark 若通道创建之前不调用此API设置Ingenic提供的鱼眼矫正算法的使能状态,则默认不使能，即不能使用君正提供的鱼眼矫正算法。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetFisheyeEnableStatus(
        encChn: libc::c_int,
        enable: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetFisheyeEnableStatus(int encChn, int *enable)\n\n 获取Ingenic提供的鱼眼矫正算法的使能状态\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] enable 返回设置的Ingenic提供的鱼眼矫正算法的使能状态,0:未使能,1:已使能\n\n @retval 0 成功\n @retval 非0 失败\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetFisheyeEnableStatus(
        encChn: libc::c_int,
        enable: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChangeRef(int encChn, int bEnable)\n\n 设置是否允许改变BASE帧参考方式的状态\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] enable 0：不允许改变，1，允许改变(默认)\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 此API必须在创建编码通道后调用，设置完后编码下一帧就会生效。\n @remark 此API只适用于SMART编码方式\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetChangeRef(encChn: libc::c_int, bEnable: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChangeRef(int encChn, int *bEnable)\n\n 获取是否允许改变BASE帧参考方式的状态\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] enable 返回是否允许改变BASE帧参考方式的状态，0：不允许改变，1，允许改变\n\n @retval 0 成功\n @retval 非0 失败\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetChangeRef(encChn: libc::c_int, bEnable: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetMbRC(int encChn, int bEnable)\n\n 设置是否开启宏块级qp控制\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] bEnable 0:不开启(默认), 1:开启\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 此API必须在创建编码通道后调用，设置完后编码下一帧就会生效。\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetMbRC(encChn: libc::c_int, bEnable: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetMbRC(int encChn, int *bEnable)\n\n 获取是否开启宏块级qp控制的状态\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] bEnable 返回是否开启宏块级qp控制的状态, 0:不开启, 1:开启\n\n @retval 0 成功\n @retval 非0 失败\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetMbRC(encChn: libc::c_int, bEnable: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetSuperFrameCfg(int encChn, const IMPEncoderSuperFrmCfg *pstSuperFrmParam)\n\n 设置编码超大帧配置\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstSuperFrmParam 编码超大帧配置\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建,则返回失败\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_SetSuperFrameCfg(
        encChn: libc::c_int,
        pstSuperFrmParam: *const IMPEncoderSuperFrmCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetSuperFrameCfg(int encChn, IMPEncoderSuperFrmCfg *pstSuperFrmParam)\n\n 获取编码超大帧配置\n\n @param[in] encChn 编码Channel号, 取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstSuperFrmParam 返回编码超大帧配置\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建, 则返回失败\n\n @attention 此API只适用于H264编码channel"]
    pub fn IMP_Encoder_GetSuperFrameCfg(
        encChn: libc::c_int,
        pstSuperFrmParam: *mut IMPEncoderSuperFrmCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetH264TransCfg(int encChn, const IMPEncoderH264TransCfg *pstH264TransCfg)\n\n 设置 H.264 协议编码通道的色度量化属性\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstH264TransCfg H.264 协议编码通道的色度量化属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建,则返回失败\n @remark 此API只适用于H264\n @remark 建议在创建编码channel之后，startRecvPic之前调用, 设置时先GetH264TransCfg，然后再SetH264TransCfg\n\n @attention 无"]
    pub fn IMP_Encoder_SetH264TransCfg(
        encChn: libc::c_int,
        pstH264TransCfg: *const IMPEncoderH264TransCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetH264TransCfg(int encChn, IMPEncoderH264TransCfg *pstH264TransCfg)\n\n 获取 H.264 协议编码通道的色度量化属性\n\n @param[in] encChn 编码Channel号, 取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstH264TransCfg 返回H.264 协议编码通道的色度量化属性\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建, 则返回失败\n @remark 此API只适用于H264\n\n @attention 无"]
    pub fn IMP_Encoder_GetH264TransCfg(
        encChn: libc::c_int,
        pstH264TransCfg: *mut IMPEncoderH264TransCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetQpgMode(int encChn, const IMPEncoderQpgMode *pstQpgMode)\n\n 设置宏块级编码模式\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstQpgMode 宏块级编码模式\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建,则返回失败\n @remark 此API只适用于H264\n\n @attention 无"]
    pub fn IMP_Encoder_SetQpgMode(
        encChn: libc::c_int,
        pstQpgMode: *const IMPEncoderQpgMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetQpgMode(int encChn, IMPEncoderQpgMode *pstQpgMode)\n\n 获取宏块级编码模式\n\n @param[in] encChn 编码Channel号, 取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstQpgMode 宏块级编码模式\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建, 则返回失败\n @remark 此API只适用于H264\n\n @attention 无"]
    pub fn IMP_Encoder_GetQpgMode(
        encChn: libc::c_int,
        pstQpgMode: *mut IMPEncoderQpgMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnEncType(int encChn, IMPPayloadType *payLoadType)\n\n 获取图像编码协议类型\n\n @param[in] encChn 编码Channel号, 取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] payLoadType 返回获取图像编码协议类型\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建, 则返回失败\n\n @attention 无"]
    pub fn IMP_Encoder_GetChnEncType(
        encChn: libc::c_int,
        payLoadType: *mut IMPPayloadType,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetJpegeQl(int encChn, const IMPEncoderJpegeQl *pstJpegeQl)\n\n 设置 JPEG 协议编码通道的量化表配置参数\n\n @param[in] encChn 编码Channel号,取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstJpegeQl JPEG 协议编码通道的量化表配置参数,128个字节填入量化表\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建,则返回失败\n @remark 此API只适用于JPEG\n\n @attention 无"]
    pub fn IMP_Encoder_SetJpegeQl(
        encChn: libc::c_int,
        pstJpegeQl: *const IMPEncoderJpegeQl,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetJpegeQl(int encChn, IMPEncoderJpegeQl *pstJpegeQl)\n\n 获取 JPEG 协议编码通道的用户量化表配置参数\n\n @param[in] encChn 编码Channel号, 取值范围: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstJpegeQl 返回JPEG 协议编码通道的量化表配置参数\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 如果通道未创建, 则返回失败\n @remark 此API只适用于JPEG\n\n @attention 无"]
    pub fn IMP_Encoder_GetJpegeQl(
        encChn: libc::c_int,
        pstJpegeQl: *mut IMPEncoderJpegeQl,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief int IMP_Encoder_SetPool(int chnNum, int poolID);\n\n 绑定chnnel 到内存池中，即Encoder申请mem从pool申请.\n\n @param[in] chnNum\t\t通道编号.\n @param[in] poolID\t\t内存池编号.\n\n @retval 0\t\t\t\t成功.\n @retval 非0\t\t\t\t失败.\n\n @remarks\t  为了解决rmem碎片化，将该channel Encoder绑定到对应的mempool\n 中, Encoder 申请mem就在mempool中申请，若不调用，Encoder会在rmem中申请\n 此时对于rmem来说会存在碎片的可能\n\n @attention ChannelId 必须大于等于0 且小于32"]
    pub fn IMP_Encoder_SetPool(chnNum: libc::c_int, poolID: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_GetPool(int chnNum);\n\n 通过channel ID 获取poolID.\n\n @param[in] chnNum       通道编号.\n\n @retval  >=0 && < 32    成功.\n @retval  <0\t\t\t   失败.\n\n @remarks   通过ChannelId 获取PoolId，客户暂时使用不到\n\n @attention 无."]
    pub fn IMP_Encoder_GetPool(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief int IMP_Encoder_InputJpege(uint8_t *src, uint8_t *dst, int src_w, int src_h, int q,int *stream_length);\n\n IVPU 外部输入NV12编码JPEG\n\n @param[in] *src 源数据地址指针\n @param[in] *dst 码流数据地址指针\n @param[in] src_w 图像高\n @param[in] src_h 图像宽\n @param[in] q 图像质量控制<暂不支持>\n @param[out] stream_length 码流数据长度\n\n @retval 0 成功\n @retval 非0 失败\n\n @remarks 此API只适用于宽32对齐,高8对齐的NV12输入编码JPEG\n\n @attention 无"]
    pub fn IMP_Encoder_InputJpege(
        src: *mut u8,
        dst: *mut u8,
        src_w: libc::c_int,
        src_h: libc::c_int,
        q: libc::c_int,
        stream_length: *mut libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " 音频流阻塞类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPBlock {
    #[doc = "< 阻塞"]
    BLOCK = 0,
    #[doc = "< 非阻塞"]
    NOBLOCK = 1,
}
#[repr(u32)]
#[doc = " 音频采样率定义."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioSampleRate {
    #[doc = "< 8KHz采样率"]
    AUDIO_SAMPLE_RATE_8000 = 8000,
    #[doc = "< 12KHz采样率"]
    AUDIO_SAMPLE_RATE_12000 = 12000,
    #[doc = "< 16KHz采样率"]
    AUDIO_SAMPLE_RATE_16000 = 16000,
    #[doc = "< 24KHz采样率"]
    AUDIO_SAMPLE_RATE_24000 = 24000,
    #[doc = "< 32KHz采样率"]
    AUDIO_SAMPLE_RATE_32000 = 32000,
    #[doc = "< 44.1KHz采样率"]
    AUDIO_SAMPLE_RATE_44100 = 44100,
    #[doc = "< 48KHz采样率"]
    AUDIO_SAMPLE_RATE_48000 = 48000,
    #[doc = "< 96KHz采样率"]
    AUDIO_SAMPLE_RATE_96000 = 96000,
}
#[repr(u32)]
#[doc = " 音频采样精度定义."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioBitWidth {
    #[doc = "< 16bit采样精度"]
    AUDIO_BIT_WIDTH_16 = 16,
}
#[repr(u32)]
#[doc = " 音频声道模式定义."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioSoundMode {
    #[doc = "< 单声道"]
    AUDIO_SOUND_MODE_MONO = 1,
    #[doc = "< 双声道"]
    AUDIO_SOUND_MODE_STEREO = 2,
}
#[repr(u32)]
#[doc = " 回音消除通道选择."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioAecChn {
    #[doc = "< 选择左声道或者通道1做回音消除"]
    AUDIO_AEC_CHANNEL_FIRST_LEFT = 0,
    #[doc = "< 选择右声道或者通道2做回音消除"]
    AUDIO_AEC_CHANNEL_SECOND_RIGHT = 1,
    #[doc = "< 选择通道3做回音消除"]
    AUDIO_AEC_CHANNEL_THIRD = 2,
    #[doc = "< 选择通道4回音消除"]
    AUDIO_AEC_CHANNEL_FOURTH = 3,
}
#[repr(u32)]
#[doc = " 定义音频净荷类型枚举."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioPalyloadType {
    PT_PCM = 0,
    PT_G711A = 1,
    PT_G711U = 2,
    PT_G726 = 3,
    PT_AEC = 4,
    PT_ADPCM = 5,
    PT_MAX = 6,
}
#[repr(u32)]
#[doc = " 定义解码方式."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioDecMode {
    #[doc = "< Pack 方式解码"]
    ADEC_MODE_PACK = 0,
    #[doc = "< Stream 方式解码"]
    ADEC_MODE_STREAM = 1,
}
#[doc = " 音频输入输出设备属性."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioIOAttr {
    #[doc = "< 音频采样率"]
    pub samplerate: IMPAudioSampleRate,
    #[doc = "< 音频采样精度"]
    pub bitwidth: IMPAudioBitWidth,
    #[doc = "< 音频声道模式"]
    pub soundmode: IMPAudioSoundMode,
    #[doc = "< 缓存帧的数目, 取值范围:[2, MAX_AUDIO_FRAME_NUM]"]
    pub frmNum: libc::c_int,
    #[doc = "< 每帧的采样点个数"]
    pub numPerFrm: libc::c_int,
    #[doc = "< 支持的通道数目"]
    pub chnCnt: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioIOAttr"][::core::mem::size_of::<IMPAudioIOAttr>() - 24usize];
    ["Alignment of IMPAudioIOAttr"][::core::mem::align_of::<IMPAudioIOAttr>() - 4usize];
    ["Offset of field: IMPAudioIOAttr::samplerate"]
        [::core::mem::offset_of!(IMPAudioIOAttr, samplerate) - 0usize];
    ["Offset of field: IMPAudioIOAttr::bitwidth"]
        [::core::mem::offset_of!(IMPAudioIOAttr, bitwidth) - 4usize];
    ["Offset of field: IMPAudioIOAttr::soundmode"]
        [::core::mem::offset_of!(IMPAudioIOAttr, soundmode) - 8usize];
    ["Offset of field: IMPAudioIOAttr::frmNum"]
        [::core::mem::offset_of!(IMPAudioIOAttr, frmNum) - 12usize];
    ["Offset of field: IMPAudioIOAttr::numPerFrm"]
        [::core::mem::offset_of!(IMPAudioIOAttr, numPerFrm) - 16usize];
    ["Offset of field: IMPAudioIOAttr::chnCnt"]
        [::core::mem::offset_of!(IMPAudioIOAttr, chnCnt) - 20usize];
};
impl Default for IMPAudioIOAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 音频帧结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioFrame {
    #[doc = "< 音频采样精度"]
    pub bitwidth: IMPAudioBitWidth,
    #[doc = "< 音频声道模式"]
    pub soundmode: IMPAudioSoundMode,
    #[doc = "< 音频帧数据虚拟地址"]
    pub virAddr: *mut u32,
    #[doc = "< 音频帧数据物理地址"]
    pub phyAddr: u32,
    #[doc = "< 音频帧数据时间戳"]
    pub timeStamp: i64,
    #[doc = "< 音频帧序号"]
    pub seq: libc::c_int,
    #[doc = "< 音频帧长度"]
    pub len: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioFrame"][::core::mem::size_of::<IMPAudioFrame>() - 32usize];
    ["Alignment of IMPAudioFrame"][::core::mem::align_of::<IMPAudioFrame>() - 8usize];
    ["Offset of field: IMPAudioFrame::bitwidth"]
        [::core::mem::offset_of!(IMPAudioFrame, bitwidth) - 0usize];
    ["Offset of field: IMPAudioFrame::soundmode"]
        [::core::mem::offset_of!(IMPAudioFrame, soundmode) - 4usize];
    ["Offset of field: IMPAudioFrame::virAddr"]
        [::core::mem::offset_of!(IMPAudioFrame, virAddr) - 8usize];
    ["Offset of field: IMPAudioFrame::phyAddr"]
        [::core::mem::offset_of!(IMPAudioFrame, phyAddr) - 12usize];
    ["Offset of field: IMPAudioFrame::timeStamp"]
        [::core::mem::offset_of!(IMPAudioFrame, timeStamp) - 16usize];
    ["Offset of field: IMPAudioFrame::seq"][::core::mem::offset_of!(IMPAudioFrame, seq) - 24usize];
    ["Offset of field: IMPAudioFrame::len"][::core::mem::offset_of!(IMPAudioFrame, len) - 28usize];
};
impl Default for IMPAudioFrame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 音频通道参数结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioIChnParam {
    #[doc = "< 音频帧缓存深度"]
    pub usrFrmDepth: libc::c_int,
    #[doc = "< 选择回音消除的通道"]
    pub aecChn: IMPAudioAecChn,
    #[doc = "< 保留"]
    pub Rev: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioIChnParam"][::core::mem::size_of::<IMPAudioIChnParam>() - 12usize];
    ["Alignment of IMPAudioIChnParam"][::core::mem::align_of::<IMPAudioIChnParam>() - 4usize];
    ["Offset of field: IMPAudioIChnParam::usrFrmDepth"]
        [::core::mem::offset_of!(IMPAudioIChnParam, usrFrmDepth) - 0usize];
    ["Offset of field: IMPAudioIChnParam::aecChn"]
        [::core::mem::offset_of!(IMPAudioIChnParam, aecChn) - 4usize];
    ["Offset of field: IMPAudioIChnParam::Rev"]
        [::core::mem::offset_of!(IMPAudioIChnParam, Rev) - 8usize];
};
impl Default for IMPAudioIChnParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 音频输出通道的数据缓存状态结构体."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPAudioOChnState {
    #[doc = "< 输出通道总的缓存块数"]
    pub chnTotalNum: libc::c_int,
    #[doc = "< 空闲缓存块数"]
    pub chnFreeNum: libc::c_int,
    #[doc = "< 被占用的缓存块数"]
    pub chnBusyNum: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioOChnState"][::core::mem::size_of::<IMPAudioOChnState>() - 12usize];
    ["Alignment of IMPAudioOChnState"][::core::mem::align_of::<IMPAudioOChnState>() - 4usize];
    ["Offset of field: IMPAudioOChnState::chnTotalNum"]
        [::core::mem::offset_of!(IMPAudioOChnState, chnTotalNum) - 0usize];
    ["Offset of field: IMPAudioOChnState::chnFreeNum"]
        [::core::mem::offset_of!(IMPAudioOChnState, chnFreeNum) - 4usize];
    ["Offset of field: IMPAudioOChnState::chnBusyNum"]
        [::core::mem::offset_of!(IMPAudioOChnState, chnBusyNum) - 8usize];
};
#[doc = " 定义音频码流结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioStream {
    #[doc = "< 数据流指针"]
    pub stream: *mut u8,
    #[doc = "< 数据流物理地址"]
    pub phyAddr: u32,
    #[doc = "< 音频码流长度"]
    pub len: libc::c_int,
    #[doc = "< 时间戳"]
    pub timeStamp: i64,
    #[doc = "< 音频码流序号"]
    pub seq: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioStream"][::core::mem::size_of::<IMPAudioStream>() - 32usize];
    ["Alignment of IMPAudioStream"][::core::mem::align_of::<IMPAudioStream>() - 8usize];
    ["Offset of field: IMPAudioStream::stream"]
        [::core::mem::offset_of!(IMPAudioStream, stream) - 0usize];
    ["Offset of field: IMPAudioStream::phyAddr"]
        [::core::mem::offset_of!(IMPAudioStream, phyAddr) - 4usize];
    ["Offset of field: IMPAudioStream::len"][::core::mem::offset_of!(IMPAudioStream, len) - 8usize];
    ["Offset of field: IMPAudioStream::timeStamp"]
        [::core::mem::offset_of!(IMPAudioStream, timeStamp) - 16usize];
    ["Offset of field: IMPAudioStream::seq"]
        [::core::mem::offset_of!(IMPAudioStream, seq) - 24usize];
};
impl Default for IMPAudioStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义音频编码通道属性结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioEncChnAttr {
    #[doc = "< 音频净荷数据类型"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "<  buf 大小，以帧为单位，[2～MAX_AUDIO_FRAME_NUM]"]
    pub bufSize: libc::c_int,
    #[doc = "< 协议属性指针"]
    pub value: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioEncChnAttr"][::core::mem::size_of::<IMPAudioEncChnAttr>() - 12usize];
    ["Alignment of IMPAudioEncChnAttr"][::core::mem::align_of::<IMPAudioEncChnAttr>() - 4usize];
    ["Offset of field: IMPAudioEncChnAttr::type_"]
        [::core::mem::offset_of!(IMPAudioEncChnAttr, type_) - 0usize];
    ["Offset of field: IMPAudioEncChnAttr::bufSize"]
        [::core::mem::offset_of!(IMPAudioEncChnAttr, bufSize) - 4usize];
    ["Offset of field: IMPAudioEncChnAttr::value"]
        [::core::mem::offset_of!(IMPAudioEncChnAttr, value) - 8usize];
};
impl Default for IMPAudioEncChnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义编码器属性结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioEncEncoder {
    #[doc = "< 编码协议类型"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< 最大码流长度"]
    pub maxFrmLen: libc::c_int,
    #[doc = "< 编码器名称"]
    pub name: [libc::c_char; 16usize],
    pub openEncoder: ::core::option::Option<
        unsafe extern "C" fn(
            encoderAttr: *mut libc::c_void,
            encoder: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub encoderFrm: ::core::option::Option<
        unsafe extern "C" fn(
            encoder: *mut libc::c_void,
            data: *mut IMPAudioFrame,
            outbuf: *mut libc::c_uchar,
            outLen: *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub closeEncoder:
        ::core::option::Option<unsafe extern "C" fn(encoder: *mut libc::c_void) -> libc::c_int>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioEncEncoder"][::core::mem::size_of::<IMPAudioEncEncoder>() - 36usize];
    ["Alignment of IMPAudioEncEncoder"][::core::mem::align_of::<IMPAudioEncEncoder>() - 4usize];
    ["Offset of field: IMPAudioEncEncoder::type_"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, type_) - 0usize];
    ["Offset of field: IMPAudioEncEncoder::maxFrmLen"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, maxFrmLen) - 4usize];
    ["Offset of field: IMPAudioEncEncoder::name"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, name) - 8usize];
    ["Offset of field: IMPAudioEncEncoder::openEncoder"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, openEncoder) - 24usize];
    ["Offset of field: IMPAudioEncEncoder::encoderFrm"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, encoderFrm) - 28usize];
    ["Offset of field: IMPAudioEncEncoder::closeEncoder"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, closeEncoder) - 32usize];
};
impl Default for IMPAudioEncEncoder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义解码通道属性结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioDecChnAttr {
    #[doc = "< 音频解码协议类型"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< 音频解码缓存大小"]
    pub bufSize: libc::c_int,
    #[doc = "< 解码方式"]
    pub mode: IMPAudioDecMode,
    #[doc = "< 具体协议属性指针"]
    pub value: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioDecChnAttr"][::core::mem::size_of::<IMPAudioDecChnAttr>() - 16usize];
    ["Alignment of IMPAudioDecChnAttr"][::core::mem::align_of::<IMPAudioDecChnAttr>() - 4usize];
    ["Offset of field: IMPAudioDecChnAttr::type_"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, type_) - 0usize];
    ["Offset of field: IMPAudioDecChnAttr::bufSize"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, bufSize) - 4usize];
    ["Offset of field: IMPAudioDecChnAttr::mode"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, mode) - 8usize];
    ["Offset of field: IMPAudioDecChnAttr::value"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, value) - 12usize];
};
impl Default for IMPAudioDecChnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义解码器属性结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioDecDecoder {
    #[doc = "< 音频解码协议类型"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< 音频解码器名字"]
    pub name: [libc::c_char; 16usize],
    pub openDecoder: ::core::option::Option<
        unsafe extern "C" fn(
            decoderAttr: *mut libc::c_void,
            decoder: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub decodeFrm: ::core::option::Option<
        unsafe extern "C" fn(
            decoder: *mut libc::c_void,
            inbuf: *mut libc::c_uchar,
            inLen: libc::c_int,
            outbuf: *mut libc::c_ushort,
            outLen: *mut libc::c_int,
            chns: *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub getFrmInfo: ::core::option::Option<
        unsafe extern "C" fn(decoder: *mut libc::c_void, info: *mut libc::c_void) -> libc::c_int,
    >,
    pub closeDecoder:
        ::core::option::Option<unsafe extern "C" fn(decoder: *mut libc::c_void) -> libc::c_int>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioDecDecoder"][::core::mem::size_of::<IMPAudioDecDecoder>() - 36usize];
    ["Alignment of IMPAudioDecDecoder"][::core::mem::align_of::<IMPAudioDecDecoder>() - 4usize];
    ["Offset of field: IMPAudioDecDecoder::type_"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, type_) - 0usize];
    ["Offset of field: IMPAudioDecDecoder::name"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, name) - 4usize];
    ["Offset of field: IMPAudioDecDecoder::openDecoder"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, openDecoder) - 20usize];
    ["Offset of field: IMPAudioDecDecoder::decodeFrm"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, decodeFrm) - 24usize];
    ["Offset of field: IMPAudioDecDecoder::getFrmInfo"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, getFrmInfo) - 28usize];
    ["Offset of field: IMPAudioDecDecoder::closeDecoder"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, closeDecoder) - 32usize];
};
impl Default for IMPAudioDecDecoder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义AGC增益结构体."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPAudioAgcConfig {
    #[doc = "< 增益级别,取值为[0, 31], 这指目标音量级别,单位为db,为负值.值越小,音量越大."]
    pub TargetLevelDbfs: libc::c_int,
    #[doc = "< 设置最大的增益值,[0, 90],0代表无增益,值越大,增益越高."]
    pub CompressionGaindB: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioAgcConfig"][::core::mem::size_of::<IMPAudioAgcConfig>() - 8usize];
    ["Alignment of IMPAudioAgcConfig"][::core::mem::align_of::<IMPAudioAgcConfig>() - 4usize];
    ["Offset of field: IMPAudioAgcConfig::TargetLevelDbfs"]
        [::core::mem::offset_of!(IMPAudioAgcConfig, TargetLevelDbfs) - 0usize];
    ["Offset of field: IMPAudioAgcConfig::CompressionGaindB"]
        [::core::mem::offset_of!(IMPAudioAgcConfig, CompressionGaindB) - 4usize];
};
#[repr(u32)]
#[doc = " 定义噪声抑制级别."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Level_ns {
    #[doc = "< 低等级级别噪声抑制"]
    NS_LOW = 0,
    #[doc = "< 中等级级别噪声抑制"]
    NS_MODERATE = 1,
    #[doc = "< 高等级级别噪声抑制"]
    NS_HIGH = 2,
    #[doc = "< 最高等级级别噪声抑制"]
    NS_VERYHIGH = 3,
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n 设置音频输入设备属性.\n\n @param[in] audioDevId 音频设备号.\n @param[in] attr 音频设备属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n int devID = 1;\n IMPAudioIOAttr attr;\n attr.samplerate = AUDIO_SAMPLE_RATE_8000;\n attr.bitwidth = AUDIO_BIT_WIDTH_16;\n attr.soundmode = AUDIO_SOUND_MODE_MONO;\n attr.frmNum = 20;\n attr.numPerFrm = 400;\n attr.chnCnt = 1;\n ret = IMP_AI_SetPubAttr(devID, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Set Audio in %d attr err: %d\\n\", devID, ret);\n\t\treturn ret;\n }\n @endcode\n\n @attention 需要在IMP_AI_Enable前调用."]
    pub fn IMP_AI_SetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n 获取音频输入设备属性.\n\n @param[in] audioDevId 音频设备号.\n @param[out] attr 音频设备属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_GetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_Enable(int audioDevId)\n\n 启用音频输入设备.\n\n @param[in] audioDevId 音频设备号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 在调用此函数前必须调用 IMP_AI_SetPubAttr()."]
    pub fn IMP_AI_Enable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_Disable(int audioDevId)\n\n 禁用音频输入设备.\n\n @param[in] audioDevId 音频设备号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 与IMP_AI_Enable配套使用,在系统休眠前必须执行IMP_AI_Disable."]
    pub fn IMP_AI_Disable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableChn(int audioDevId, int aiChn)\n\n 启用音频输入通道.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 必须先使能device."]
    pub fn IMP_AI_EnableChn(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableChn(int audioDevId, int aiChn)\n\n 禁用音频输入通道.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 与IMP_AI_EnableChn配套使用."]
    pub fn IMP_AI_DisableChn(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_PollingFrame(int audioDevId, int aiChn, unsigned int timeout_ms)\n\n Polling音频流缓存.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] timeout_ms Polling超时时间.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 在使用IMP_AI_GetFrame之前使用该接口，当该接口调用成功之后表示音频\n\t\t\t  数据已经准备完毕，可以使用IMP_AI_GetFrame获取音频数据."]
    pub fn IMP_AI_PollingFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        timeout_ms: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetFrame(int audioDevId, int aiChn, IMPAudioFrame *frm, IMPBlock block)\n\n 获取音频帧.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[out] frm 音频帧结构体指针.\n @param[in] block 阻塞/非阻塞标识.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n IMPAudioFrame frm;\n // 获取音频帧\n ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Get Frame Data error\\n\");\n\t\treturn ret;\n }\n\n fwrite(frm.virAddr, 1, frm.len, record_file); // 使用音频帧数据\n\n // 释放音频帧\n ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio release frame data error\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention 无."]
    pub fn IMP_AI_GetFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        frm: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_ReleaseFrame(int audioDevId, int aiChn, IMPAudioFrame *frm)\n\n 释放音频帧.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] frm 音频帧结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 与IMP_AI_GetFrame配套使用."]
    pub fn IMP_AI_ReleaseFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        frm: *mut IMPAudioFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetChnParam(int audioDevId, int aiChn, IMPAudioIChnParam *chnParam)\n\n 设置音频输入通道参数.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] chnParam 音频通道参数.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n int chnID = 0;\n IMPAudioIChnParam chnParam;\n chnParam.usrFrmDepth = 20;\t// the range of valid value is [2, MAX_AUDIO_FRAME_NUM].\n ret = IMP_AI_SetChnParam(devID, chnID, &chnParam);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"set ai %d channel %d attr err: %d\\n\", devID, chnID, ret);\n\t\treturn ret;\n }\n @endcode\n\n @attention 在IMP_AI_EnableChn前调用."]
    pub fn IMP_AI_SetChnParam(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        chnParam: *mut IMPAudioIChnParam,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetChnParam(int audioDevId, int aiChn, IMPAudioIChnParam *chnParam)\n\n 获取音频输入通道参数.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[out] chnParam 音频通道参数.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_GetChnParam(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        chnParam: *mut IMPAudioIChnParam,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAec(int aiDevId, int aiChn, int aoDevId, int aoChn)\n\n 启用指定音频输入和音频输出的回声抵消功能.\n\n @param[in] aiDevId 需要进行回声抵消的音频输入设备号.\n @param[in] aiChn 需要进行回声抵消的音频输入通道号.\n @param[in] aoDevId 需要进行回声抵消的音频输出设备号.\n @param[in] aoChn 需要进行回声抵消的音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 回音消除针对不同的设备，不同的封装，回音消除会有不同的效果.\n @remarks 回音消除目前不支持自适应，所以针对不同设备有单独的回音消除参数,\n @remarks 仅仅只是使能该功能效果不一定会好。\n @remarks 回音消除的参数文件位于/etc/webrtc_profile.ini 配置文件中.\n @remarks 配置文件格式为如下(以下列出主要需要调试的三个参数):\n @remarks [Set_Far_Frame]\n @remarks Frame_V=0.3\n @remarks [Set_Near_Frame]\n @remarks Frame_V=0.1\n @remarks delay_ms=150\n\n @remarks 其中第一个标签[Set_Far_Frame]中的内容代表远端参数,即SPK端放音数据参数.\n @remarks Fram_V 代表音频幅值比例,调节该参数可以调节放音数据的幅度(此幅度只用于回音消除).\n @remarks 其中第一个标签[Set_Near_Frame]中的内容代表近端参数,即MIC端录音数据参数.\n @remarks Fram_V 代表音频幅值比例,调节该参数可以调节录音数据的幅度(此幅度只用于回音消除).\n @remarks delay_ms 由于软件和硬件具有延时性,且SPK与MIC的安放有一定距离,SPK放音数据会重新被MIC采样,所以SPK数据在MIC数据中体现会存在一定延时.\n @remarks 该时间代表放音数据在录音数据中的时间差.\n\n @attention 实际上接口只会检查aiDevId和aiChn.但是最好在两个通道同时使能后调用. \\n\n 在关闭音频输入通道的同时,回音消除功能同时关闭.如果再次使用需要再次打开."]
    pub fn IMP_AI_EnableAec(
        aiDevId: libc::c_int,
        aiChn: libc::c_int,
        aoDevId: libc::c_int,
        aoChn: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "@fn  int IMP_AI_Set_WebrtcProfileIni_Path(char *path)\n设置AEC配置文件\" webrtc_profile.ini\" 的路径.\n\npath参数：用于设置配置文件的路径.\n例如 用户想将配置文件放在/system目录下  IMP_AI_Set_WebrtcProfileIni_Path(\"/system\");\n\n此函数必须在   IMP_AI_EnableAec(int aiDevId, int aiChn, int aoDevId, int aoChn)前使用。\n此函数必须在   IMP_AI_EnableAlgo(int audioDevId, int aiChn)前使用。\n此函数必须在   IMP_AO_EnableAlgo(int audioDevId, int aoChn)前使用。\n返回值为0"]
    pub fn IMP_AI_Set_WebrtcProfileIni_Path(path: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAec(int aiDevId, int aiChn)\n\n 禁用回声抵消功能.\n\n @param[in] aiDevId 音频输入设备号.\n @param[in] aiChn 音频输入通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_DisableAec(aiDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableNs(IMPAudioIOAttr *attr, int mode)\n\n 启用指定音频输入的噪声抑制功能.\n\n @param[in] attr 需要进行噪声抑制的音频属性.\n @param[in] mode 噪声抑制的级别0 ～ 3,参见 Level_ns.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 噪声抑制的mode参数表示噪声抑制的级别,范围为[0 ~ 3],级别越高,噪声抑制的越干净.\n @remarks 然而,噪声抑制的越干净同时也就会丢失更多的声音细节,所以这里有一个矛盾点,需要在\n @remarks 使用的时候进行权衡.\n\n @attention 回声消除包含了噪声抑制功能,如果启用回声抵消,就不需要做噪声抑制."]
    pub fn IMP_AI_EnableNs(attr: *mut IMPAudioIOAttr, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableNs(void)\n\n 禁用噪声抑制功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_DisableNs() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableHs(void)\n\n 启用啸叫抑制的功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_EnableHs() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableHs(void)\n\n 禁用啸叫抑制功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_DisableHs() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAgc(IMPAudioIOAttr *attr, IMPAudioAgcConfig agcConfig)\n\n 启用音频输入的自动增益功能.\n\n @param[in] attr 需要进行自动增益的音频属性.\n @param[in] agcConfig 自动增益的参数配置,配置放大倍数.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 需要注意agcConfig的配置,AGC的放大倍数主要有该参数配置,具体增益见IMPAudioAgcConfig说明.\n @remarks 需要注意的是,AGC可以将声音的增益放大,但是如果增益的参数不合适,就会导致破音等情况,请在具体使用时自行调整.\n\n @attention 回声消除包含了 AGC 功能,如果启用回声抵消,就不需要做自动增益."]
    pub fn IMP_AI_EnableAgc(attr: *mut IMPAudioIOAttr, agcConfig: IMPAudioAgcConfig)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAgc(void)\n\n 禁用AI自动增益功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_DisableAgc() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableAgc(IMPAudioIOAttr *attr, IMPAudioAgcConfig agcConfig)\n\n 启用音频输出的自动增益功能.\n\n @param[in] attr 需要进行自动增益的音频属性.\n @param[in] agcConfig 自动增益的参数配置,配置放大倍数.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 需要注意agcConfig的配置,AGC的放大倍数主要有该参数配置,具体增益见IMPAudioAgcConfig说明.\n @remarks 需要注意的是,AGC可以将声音的增益放大,但是如果增益的参数不合适,就会导致破音等情况,请在具体使用时自行调整.\n\n @attention 回声消除包含了 AGC 功能,如果启用回声抵消,就不需要做自动增益."]
    pub fn IMP_AO_EnableAgc(attr: *mut IMPAudioIOAttr, agcConfig: IMPAudioAgcConfig)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableAgc(void)\n\n 禁用AO自动增益功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_DisableAgc() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableHpf(IMPAudioIOAttr *attr)\n\n 启用音频输入的高通滤波.\n\n @param[in] attr 需要进行高通滤波的音频属性.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 回声消除包含了 HPF 功能,如果启用回声抵消,就不需要做 HPF."]
    pub fn IMP_AI_EnableHpf(attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetHpfCoFrequency(int cofrequency)\n\n 设置音频输入的高通滤波器的截止频率.\n\n @param[in] cofrequency 高通滤波的截止频率\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 开启高通滤波器之前先设置截至频率"]
    pub fn IMP_AI_SetHpfCoFrequency(cofrequency: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableHpf(void)\n\n 禁用AI高通滤波功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_DisableHpf() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableHpf(IMPAudioIOAttr *attr)\n\n 启用音频输出的高通滤波.\n\n @param[in] attr 需要进行高通滤波的音频属性.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 回声消除包含了 HPF 功能,如果启用回声抵消,就不需要做 HPF."]
    pub fn IMP_AO_EnableHpf(attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetHpfCoFrequency(int cofrequency)\n\n 设置音频输出的高通滤波器的截止频率.\n\n @param[in] cofrequency 高通滤波的截止频率\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 开启高通滤波器之前先设置截止频率."]
    pub fn IMP_AO_SetHpfCoFrequency(cofrequency: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableHpf(void)\n\n 禁用AO高通滤波功能.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_DisableHpf() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n 设置音频输入输出设备属性.\n\n @param[in] audioDevId 音频设备号.\n @param[in] attr 音频输出设备属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_SetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n 获取音频输入输出设备属性.\n\n @param[in] audioDevId 音频设备号.\n @param[out] attr 音频输出设备属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_GetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Enable(int audioDevId)\n\n 启用音频输出设备.\n\n @param[in] audioDevId 音频设备号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 在使能之前必须先调用IMP_AO_SetPubAttr."]
    pub fn IMP_AO_Enable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Disable(int audioDevId)\n\n 禁用音频输出设备.\n\n @param[in] audioDevId 音频设备号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_Disable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableChn(int audioDevId, int aoChn)\n\n 启用音频输出通道.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_EnableChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableChn(int audioDevId, int aoChn)\n\n 禁用音频输出通道.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_DisableChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SendFrame(int audioDevId, int aoChn, IMPAudioFrame *data, IMPBlock block)\n\n 发送音频输出帧.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n @param[in] data 音频帧结构体指针.\n @param[in] block 阻塞/非阻塞标识.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n while(1) {\n\t\tsize = fread(buf, 1, IMP_AUDIO_BUF_SIZE, play_file);\n\t\tif(size < IMP_AUDIO_BUF_SIZE)\n\t\t\tbreak;\n\n\t\tIMPAudioFrame frm;\n\t\tfrm.virAddr = (uint32_t *)buf;\n\t\tfrm.len = size;\n\t\tret = IMP_AO_SendFrame(devID, chnID, &frm, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"send Frame Data error\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention 无."]
    pub fn IMP_AO_SendFrame(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        data: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_PauseChn(int audioDevId, int aoChn)\n\n 暂停音频输出通道.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_PauseChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_ResumeChn(int audioDevId, int aoChn)\n\n 恢复音频输出通道.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_ResumeChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_ClearChnBuf(int audioDevId, int aoChn)\n\n 清除音频输出通道中当前的音频数据缓存.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_ClearChnBuf(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_QueryChnStat(int audioDevId, int aoChn, IMPAudioOChnState *status)\n\n 查询音频输出通道中当前的音频数据缓存状态.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n @param[out] status 缓存状态结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_QueryChnStat(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        status: *mut IMPAudioOChnState,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_CreateChn(int aeChn, IMPAudioEncChnAttr *attr)\n\n 创建音频编码通道.\n\n @param[in] aeChn 通道号.\n @param[in] attr 音频编码通道属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n int AeChn = 0;\n IMPAudioEncChnAttr attr;\n attr.type = PT_G711A;\n attr.bufSize = 20;\n ret = IMP_AENC_CreateChn(AeChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio encode create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention 目前SDK支持PT_G711A、PT_G711U和PT_G726编码. \\n\n 所以使用SDK中的编码,只需要attr.type = PT_G711A即可. \\n\n 如何需要使用自定义的编码器,则需要注册编码器,示例代码在注册接口中说明."]
    pub fn IMP_AENC_CreateChn(aeChn: libc::c_int, attr: *mut IMPAudioEncChnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_DestroyChn(int aeChn)\n\n 销毁音频编码通道.\n\n @param[in] aeChn 通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 与IMP_AENC_CreateChn配套使用."]
    pub fn IMP_AENC_DestroyChn(aeChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_SendFrame(int aeChn, IMPAudioFrame *frm)\n\n 发送音频编码音频帧.\n\n @param[in] aeChn 通道号.\n @param[in] frm 音频帧结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n while(1) {\n\t\t// 读取一帧数据\n\t\tret = fread(buf_pcm, 1, IMP_AUDIO_BUF_SIZE, file_pcm);\n\t\tif(ret < IMP_AUDIO_BUF_SIZE)\n\t\t\tbreak;\n\n\t\t// 编码\n\t\tIMPAudioFrame frm;\n\t\tfrm.virAddr = (uint32_t *)buf_pcm;\n\t\tfrm.len = ret;\n\t\tret = IMP_AENC_SendFrame(AeChn, &frm);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode send frame failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// 获取编码码流\n\t\tIMPAudioStream stream;\n\t\tret = IMP_AENC_GetStream(AeChn, &stream, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode get stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// 使用编码码流\n\t\tfwrite(stream.stream, 1, stream.len, file_g711);\n\n\t\t// 释放编码码流\n\t\tret = IMP_AENC_ReleaseStream(AeChn, &stream);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode release stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention 无."]
    pub fn IMP_AENC_SendFrame(aeChn: libc::c_int, frm: *mut IMPAudioFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_PollingStream(int AeChn, unsigned int timeout_ms)\n\n Polling编码音频流缓存.\n\n @param[in] AeChn 音频编码输入通道号.\n @param[in] timeout_ms Polling超时时间.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 在使用IMP_AENC_GetStream之前使用该接口，当该接口调用成功之后表示音频\n\t\t\t  编码数据已经准备完毕，可以使用IMP_AENC_GetStream获取编码完毕的数据."]
    pub fn IMP_AENC_PollingStream(AeChn: libc::c_int, timeout_ms: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_GetStream(int aeChn, IMPAudioStream *stream ,IMPBlock block)\n\n 获取编码后码流.\n\n @param[in] aeChn 通道号.\n @param[in] stream 获取音频码流.\n @param[in] block 阻塞/非阻塞标识.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码见IMP_AENC_SendFrame函数说明.\n\n @attention 无."]
    pub fn IMP_AENC_GetStream(
        aeChn: libc::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_ReleaseStream(int aeChn,IMPAudioStream *stream)\n\n 释放从音频编码通道获取的码流.\n\n @param[in] aeChn 通道号.\n @param[in] stream 获取音频码流指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码见IMP_AENC_SendFrame函数说明.\n\n @attention 无."]
    pub fn IMP_AENC_ReleaseStream(aeChn: libc::c_int, stream: *mut IMPAudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_RegisterEncoder(int *handle, IMPAudioEncEncoder *encoder)\n\n 注册编码器.\n\n @param[in] ps32handle 注册句柄.\n @param[in] encoder 编码器属性结构体.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n int handle_g711a = 0;\n IMPAudioEncEncoder my_encoder;\n my_encoder.maxFrmLen = 1024;\n sprintf(my_encoder.name, \"%s\", \"MY_G711A\");\n my_encoder.openEncoder = NULL; // 编码器回调函数\n my_encoder.encoderFrm = MY_G711A_Encode_Frm; // 编码器回调函数\n my_encoder.closeEncoder = NULL; // 编码器回调函数\n\n ret = IMP_AENC_RegisterEncoder(&handle_g711a, &my_encoder);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"IMP_AENC_RegisterEncoder failed\\n\");\n\t\treturn ret;\n }\n\n // 使用编码器\n int AeChn = 0;\n IMPAudioEncChnAttr attr;\n attr.type = handle_g711a; // 编码器type等于注册成功返回的handle_g711a的值即可.\n attr.bufSize = 20;\n ret = IMP_AENC_CreateChn(AeChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio encode create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention 注册之后使用方法和使用SDK自带编码器一样."]
    pub fn IMP_AENC_RegisterEncoder(
        handle: *mut libc::c_int,
        encoder: *mut IMPAudioEncEncoder,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_UnRegisterEncoder(int *handle)\n\n 注销编码器.\n\n @param[in] ps32handle 注册句柄(注册编码器时获得的句柄).\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AENC_UnRegisterEncoder(handle: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_CreateChn(int adChn, IMPAudioDecChnAttr *attr)\n\n 创建音频解码通道.\n\n @param[in] adChn 通道号.\n @param[in] attr 通道属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n int adChn = 0;\n IMPAudioDecChnAttr attr;\n attr.type = PT_G711A;\n attr.bufSize = 20;\n attr.mode = ADEC_MODE_PACK;\n ret = IMP_ADEC_CreateChn(adChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio decoder create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention 无."]
    pub fn IMP_ADEC_CreateChn(adChn: libc::c_int, attr: *mut IMPAudioDecChnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_DestroyChn(int adChn)\n\n 销毁音频解码通道.\n\n @param[in] adChn 通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_ADEC_DestroyChn(adChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_SendStream(int adChn, IMPAudioStream *stream, IMPBlock block)\n\n 发送音频码流到音频解码通道.\n\n @param[in] adChn 通道号.\n @param[in] stream 音频码流.\n @param[in] block 阻塞/非阻塞标识.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n while(1) {\n\t\t// 获取需要解码的数据\n\t\tret = fread(buf_g711, 1, IMP_AUDIO_BUF_SIZE/2, file_g711);\n\t\tif(ret < IMP_AUDIO_BUF_SIZE/2)\n\t\t\tbreak;\n\n\t\t// 发送解码数据\n\t\tIMPAudioStream stream_in;\n\t\tstream_in.stream = (uint8_t *)buf_g711;\n\t\tstream_in.len = ret;\n\t\tret = IMP_ADEC_SendStream(adChn, &stream_in, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode send frame failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// 获取解码后的数据\n\t\tIMPAudioStream stream_out;\n\t\tret = IMP_ADEC_GetStream(adChn, &stream_out, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio decoder get stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// 使用解码后的数据\n\t\tfwrite(stream_out.stream, 1, stream_out.len, file_pcm);\n\n\t\t// 释放解码后的数据\n\t\tret = IMP_ADEC_ReleaseStream(adChn, &stream_out);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio decoder release stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention 无."]
    pub fn IMP_ADEC_SendStream(
        adChn: libc::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_PollingStream(int AdChn, unsigned int timeout_ms)\n\n Polling解码音频流缓存.\n\n @param[in] AdChn 音频解码输入通道号.\n @param[in] timeout_ms Polling超时时间.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 在使用IMP_ADEC_GetStream之前使用该接口，当该接口调用成功之后表示音频\n\t\t\t  解码数据已经准备完毕，可以使用IMP_ADEC_GetStream获取解码完毕的数据."]
    pub fn IMP_ADEC_PollingStream(AdChn: libc::c_int, timeout_ms: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_GetStream(int adChn, IMPAudioStream *stream ,IMPBlock block)\n\n 获取解码后码流.\n\n @param[in] adChn 通道号.\n @param[in] stream 获取解码码流.\n @param[in] block 阻塞/非阻塞标识.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码见IMP_ADEC_SendStream函数说明.\n\n @attention 无."]
    pub fn IMP_ADEC_GetStream(
        adChn: libc::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_ReleaseStream(int adChn,IMPAudioStream *stream)\n 释放从音频解码通道获取的码流.\n\n @param[in] adChn 通道号.\n @param[in] stream 音频码流指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码见IMP_ADEC_SendStream函数说明.\n\n @attention 无."]
    pub fn IMP_ADEC_ReleaseStream(adChn: libc::c_int, stream: *mut IMPAudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_ClearChnBuf(int adChn)\n\n 清除音频解码通道中当前的音频数据缓存.\n\n @param[in] adChn 通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_ADEC_ClearChnBuf(adChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_RegisterDecoder(int *handle, IMPAudioDecDecoder *decoder)\n\n 注册解码器.\n\n @param[in] ps32handle 注册句柄.\n @param[in] decoder 解码器属性结构体.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n int handle_g711a = 0;\n IMPAudioDecDecoder my_decoder;\n sprintf(my_decoder.name, \"%s\", \"MY_G711A\");\n my_decoder.openDecoder = NULL; // 解码器回调函数\n my_decoder.decodeFrm = MY_G711A_Decode_Frm; // 解码器回调函数\n my_decoder.getFrmInfo = NULL; // 解码器回调函数\n my_decoder.closeDecoder = NULL; // 解码器回调函数\n\n // 注册解码器\n ret = IMP_ADEC_RegisterDecoder(&handle_g711a, &my_decoder);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"IMP_ADEC_RegisterDecoder failed\\n\");\n\t\treturn ret;\n }\n\n // 使用解码器\n int adChn = 0;\n IMPAudioDecChnAttr attr;\n attr.type = handle_g711a; // 解码type等于解码器注册返回的handle_g711a.\n attr.bufSize = 20;\n attr.mode = ADEC_MODE_PACK;\n // 创建解码通道\n ret = IMP_ADEC_CreateChn(adChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio decoder create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention 注册之后使用方法和使用SDK自带解码器一样."]
    pub fn IMP_ADEC_RegisterDecoder(
        handle: *mut libc::c_int,
        decoder: *mut IMPAudioDecDecoder,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_UnRegisterDecoder(int *handle)\n\n 注销解码器.\n\n @param[in] ps32handle 注册句柄(注册解码器时获得的句柄).\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_ADEC_UnRegisterDecoder(handle: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " ACODEC配置.\n/\n/**\n @fn int IMP_AI_SetVol(int audioDevId, int aiChn, int aiVol)\n\n 设置音频输入音量.\n\n @param[in] aiDevId 音频输入设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] aiVol 音频输入音量大小.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 音量的取值范围为[-30 ~ 120]. -30代表静音,120表示将声音放大30dB,步长0.5dB.\n @remarks 其中60是音量设置的一个临界点，在这个值上软件不对音量做增加或减小，当音量值小于60时，每下降1，音量减小0.5dB；当音量值大于60时，上增加1，音量增加0.5dB。\n\n 示例代码\n @code\n int volume = 60;\n ret = IMP_AI_SetVol(devID, chnID, volume);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Record set volume failed\\n\");\n\t\treturn ret;\n }\n @endcode\n @attention 如果输入的aiVol超过了[-30 ~ 120]的范围,小于-30的将会取-30,大于120的取120."]
    pub fn IMP_AI_SetVol(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        aiVol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetVol(int audioDevId, int aiChn, int *vol)\n\n 获取音频输入音量.\n\n @param[in] aiDevId 音频输入设备号.\n @param[in] aiChn 音频输入通道号.\n @param[out] vol 音频输入通道音量.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_GetVol(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        vol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetVolMute(int audioDevId, int aiChn, int mute)\n\n 设置音频输入静音.\n\n @param[in] aiDevId 音频输入设备号.\n @param[in] aiChn 音频输入通道号.\n @param[out] mute 音频输入静音标志, mute = 0:关闭静音, mute = 1:打开静音.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该接口可立刻静音.\n\n @attention 无."]
    pub fn IMP_AI_SetVolMute(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        mute: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetVol(int audioDevId, int aoChn, int aoVol)\n\n 设置音频输出通道音量.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n @param[in] aoVol 音频输出音量.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 音量的取值范围为[-30 ~ 120]. -30代表静音,120表示将声音放大30dB,步长0.5dB.\n @remarks 其中60是音量设置的一个临界点，在这个值上软件不对音量做增加或减小，当音量值小于60时，每下降1，音量减小0.5dB；当音量值大于60时，上增加1，音量增加0.5dB。\n\n @attention 如果输入的aoVol超过了[-30 ~ 120]的范围,小于-30的将会取-30,大于120的取120."]
    pub fn IMP_AO_SetVol(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        aoVol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetVol(int audioDevId, int aoChn, int *vol)\n\n 获取音频输出通道音量.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n @param[out] aoVol 音频输出音量.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_GetVol(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        vol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetVolMute(int audioDevId, int aoChn, int mute)\n\n 设置音频输出静音.\n\n @param[in] audioDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n @param[out] mute 音频输出静音标志, mute = 0:关闭静音, mute = 1:打开静音.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该接口可立刻静音.\n\n @attention 无."]
    pub fn IMP_AO_SetVolMute(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        mute: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetGain(int audioDevId, int aiChn, int aiGain)\n\n 设置音频输入模拟增益.\n\n @param[in] audioDevId 音频输入设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] aigain 音频通道输入增益.\n\n 范围[0 ~ 31],对应[-18dB ~ 28.5dB],步长1.5dB.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention aiGain的范围为[0 ~ 31],如果输入的值小于0,则aiGain的值将会\\n\n 被设置为0.如果值大于31,aiGain的值会被设置为31.\n"]
    pub fn IMP_AI_SetGain(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        aigain: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetGain(int audioDevId, int aiChn, int *aiGain)\n\n 获取音频输入模拟增益值.\n\n @param[in] audioDevId 音频输入设备号.\n @param[in] aiChn 音频输入通道号.\n @param[out] aigain 音频通道输入增益属性指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AI_GetGain(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        aigain: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetGain(int audioDevId, int aoChn, int aoGain)\n\n 设置音频输出增益.\n\n @param[in] audioDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n @param[out] aoGain 音频输出增益,范围[0 ~ 0x1f],对应[-39dB ~ 6dB],步长1.5dB.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention aoGain的范围为[0 ~ 31],如果输入的值小于0,则aoGain的值将会\\n\n 被设置为0.如果值大于31,aoGain的值会被设置为31.\n"]
    pub fn IMP_AO_SetGain(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        aoGain: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetGain(int audioDevId, int aoChn, int *aoGain)\n\n 获取音频输出增益.\n\n @param[in] audioDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n @param[out] aoGain 音频输出增益.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn IMP_AO_GetGain(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        aoGain: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Soft_Mute(int audioDevId, int aoChn)\n\n 输出软静音控制.\n\n @param[in] audioDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该接口不会立马静音，会从正常放音状态缓慢将音量降低，直到真正静音.\n\n @attention 无."]
    pub fn IMP_AO_Soft_Mute(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Soft_UNMute(int audioDevId, int aoChn)\n\n 输出软撤销静音控制.\n\n @param[in] audioDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该接口不会立马恢复当前音量，会从静音状态缓慢将音量增加，直到音量达到设置好的音量.\n\n @attention 无."]
    pub fn IMP_AO_Soft_UNMute(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetFrameAndRef(int audioDevId, int aiChn, IMPAudioFrame *frm, IMPAudioFrame *ref, IMPBlock block)\n\n 获取音频帧和输出参考帧.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[out] frm 音频帧结构体指针.\n @param[out] ref 参考帧结构体指针.\n @param[in] block 阻塞/非阻塞标识.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 示例代码\n @code\n IMPAudioFrame frm;\n IMPAudioFrame ref;\n // 获取音频帧和输出参考帧\n ret = IMP_AI_GetFrameAndRef(devID, chnID, &frm, &ref, BLOCK);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Get Frame Data error\\n\");\n\t\treturn ret;\n }\n\n fwrite(frm.virAddr, 1, frm.len, record_file); // 使用音频帧数据\n fwrite(ref.virAddr, 1, ref.len, ref_file); // 使用音频参考帧\n\n // 释放音频帧\n ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio release frame data error\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention 无."]
    pub fn IMP_AI_GetFrameAndRef(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        frm: *mut IMPAudioFrame,
        ref_: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAecRefFrame(int audioDevId, int aiChn, int audioAoDevId, int aoChn)\n\n 打开获取参考帧.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] audioAoDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用IMP_AI_GetFrameAndRef之前调用此接口.\n @attention 无."]
    pub fn IMP_AI_EnableAecRefFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        audioAoDevId: libc::c_int,
        aoChn: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAecRefFrame(int audioDevId, int aiChn, int audioAoDevId, int aoChn)\n\n 关闭获取参考帧.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n @param[in] audioAoDevId 音频输出设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n @attention 无."]
    pub fn IMP_AI_DisableAecRefFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        audioAoDevId: libc::c_int,
        aoChn: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_CacheSwitch(int audioDevId, int aoChn, int cache_en)\n 关闭音频播放缓存机制\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n @param[in] cache_en 缓存机制开启开关\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n @attention 无."]
    pub fn IMP_AO_CacheSwitch(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        cache_en: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_FlushChnBuf(int audioDevId, int aoChn);\n 等待最后一段音频数据播完;\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n @attention 无."]
    pub fn IMP_AO_FlushChnBuf(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAlgo(int audioDevId, int aiChn)\n\n 启用音频算法NS/AGC/HPF.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 必须先使能device."]
    pub fn IMP_AI_EnableAlgo(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAlgo(void)\n\n 关闭音频算法NS/AGC/HPF.\n @param[in] audioDevId 音频设备号.\n @param[in] aiChn 音频输入通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attentio 无."]
    pub fn IMP_AI_DisableAlgo(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableAlgo(int audioDevId, int aoChn)\n\n 启用音频算法NS/AGC/HPF.\n\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输出通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 必须先使能device."]
    pub fn IMP_AO_EnableAlgo(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableAlgo(void)\n\n 关闭音频算法NS/AGC/HPF.\n @param[in] audioDevId 音频设备号.\n @param[in] aoChn 音频输入通道号.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attentio 无."]
    pub fn IMP_AO_DisableAlgo(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
#[doc = " 定义解码器属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderAttr {
    #[doc = "< 解码帧原数据协议类型"]
    pub decType: IMPPayloadType,
    #[doc = "< 解码帧最大的宽度"]
    pub maxWidth: u32,
    #[doc = "< 解码帧最大的高度"]
    pub maxHeight: u32,
    #[doc = "< 解码帧目标数据协议类型"]
    pub pixelFormat: IMPPixelFormat,
    #[doc = "< 解码器缓存帧个数"]
    pub nrKeepStream: u32,
    #[doc = "< 在一秒钟内的时间单元的数量, 以时间单元为单位。即帧率的分子"]
    pub frmRateNum: u32,
    #[doc = "< 在一帧内的时间单元的数量, 以时间单元为单位。即帧率的分母"]
    pub frmRateDen: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderAttr"][::core::mem::size_of::<IMPDecoderAttr>() - 28usize];
    ["Alignment of IMPDecoderAttr"][::core::mem::align_of::<IMPDecoderAttr>() - 4usize];
    ["Offset of field: IMPDecoderAttr::decType"]
        [::core::mem::offset_of!(IMPDecoderAttr, decType) - 0usize];
    ["Offset of field: IMPDecoderAttr::maxWidth"]
        [::core::mem::offset_of!(IMPDecoderAttr, maxWidth) - 4usize];
    ["Offset of field: IMPDecoderAttr::maxHeight"]
        [::core::mem::offset_of!(IMPDecoderAttr, maxHeight) - 8usize];
    ["Offset of field: IMPDecoderAttr::pixelFormat"]
        [::core::mem::offset_of!(IMPDecoderAttr, pixelFormat) - 12usize];
    ["Offset of field: IMPDecoderAttr::nrKeepStream"]
        [::core::mem::offset_of!(IMPDecoderAttr, nrKeepStream) - 16usize];
    ["Offset of field: IMPDecoderAttr::frmRateNum"]
        [::core::mem::offset_of!(IMPDecoderAttr, frmRateNum) - 20usize];
    ["Offset of field: IMPDecoderAttr::frmRateDen"]
        [::core::mem::offset_of!(IMPDecoderAttr, frmRateDen) - 24usize];
};
impl Default for IMPDecoderAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义解码Channel属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderCHNAttr {
    #[doc = "< 解码器属性"]
    pub decAttr: IMPDecoderAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderCHNAttr"][::core::mem::size_of::<IMPDecoderCHNAttr>() - 28usize];
    ["Alignment of IMPDecoderCHNAttr"][::core::mem::align_of::<IMPDecoderCHNAttr>() - 4usize];
    ["Offset of field: IMPDecoderCHNAttr::decAttr"]
        [::core::mem::offset_of!(IMPDecoderCHNAttr, decAttr) - 0usize];
};
impl Default for IMPDecoderCHNAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义解码帧数据属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderNal {
    #[doc = "< 解码帧的数据长度"]
    pub i_payload: libc::c_int,
    #[doc = "< 解码帧的数据指针"]
    pub p_payload: *mut u8,
    #[doc = "< 解码帧的时间戳"]
    pub timeStamp: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderNal"][::core::mem::size_of::<IMPDecoderNal>() - 16usize];
    ["Alignment of IMPDecoderNal"][::core::mem::align_of::<IMPDecoderNal>() - 8usize];
    ["Offset of field: IMPDecoderNal::i_payload"]
        [::core::mem::offset_of!(IMPDecoderNal, i_payload) - 0usize];
    ["Offset of field: IMPDecoderNal::p_payload"]
        [::core::mem::offset_of!(IMPDecoderNal, p_payload) - 4usize];
    ["Offset of field: IMPDecoderNal::timeStamp"]
        [::core::mem::offset_of!(IMPDecoderNal, timeStamp) - 8usize];
};
impl Default for IMPDecoderNal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 定义解码器码流属性"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderStream {
    #[doc = "< 解码帧数据结构体"]
    pub decoderNal: IMPDecoderNal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderStream"][::core::mem::size_of::<IMPDecoderStream>() - 16usize];
    ["Alignment of IMPDecoderStream"][::core::mem::align_of::<IMPDecoderStream>() - 8usize];
    ["Offset of field: IMPDecoderStream::decoderNal"]
        [::core::mem::offset_of!(IMPDecoderStream, decoderNal) - 0usize];
};
impl Default for IMPDecoderStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_CreateChn(int decChn, const IMPDecoderCHNAttr *attr)\n\n 创建解码Channel\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] attr 解码Channel属性指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n @attention 无。"]
    pub fn IMP_Decoder_CreateChn(
        decChn: libc::c_int,
        attr: *const IMPDecoderCHNAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_DestroyChn(int decChn)\n\n 销毁解码Channel\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n @attention 无。"]
    pub fn IMP_Decoder_DestroyChn(decChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_StartRecvPic(int decChn)\n\n 开启解码Channel接收图像\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 开启解码Channel接收图像后才能开始解码\n\n @attention 如果Channel未创建，则返回失败"]
    pub fn IMP_Decoder_StartRecvPic(decChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_StopRecvPic(int decChn)\n\n 停止解码Channel接收图像\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 停止解码Channel接收图像\n\n @attention 如果Channel未创建，则返回失败"]
    pub fn IMP_Decoder_StopRecvPic(decChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_SendStreamTimeout(int decChn, IMPDecoderStream *stream, uint32_t timeoutMsec)\n\n 发送需解码数据\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] stream 需解码的数据流结构体指针\n @param[in] timeoutMsec 解码超时时间 单位ms\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 如果Channel未创建，则返回失败"]
    pub fn IMP_Decoder_SendStreamTimeout(
        decChn: libc::c_int,
        stream: *mut IMPDecoderStream,
        timeoutMsec: u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_PollingFrame(int decChn, uint32_t timeoutMsec)\n\n Polling 解码码流缓存\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] timeoutMsec 超时时间 单位ms\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 如果Channel未创建，则返回失败"]
    pub fn IMP_Decoder_PollingFrame(decChn: libc::c_int, timeoutMsec: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_GetFrame(int decChn, IMPFrameInfo **frame)\n\n 获取解码码流\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[out] frame 解码码流结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 解码码流buffer由解码器内部申请，该函数只需要传入结构体指针即可。"]
    pub fn IMP_Decoder_GetFrame(decChn: libc::c_int, frame: *mut *mut IMPFrameInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_ReleaseFrame(int decChn, IMPFrameInfo *frame)\n\n 释放码流缓存\n\n @param[in] decChn 解码Channel号,取值范围: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] frame 解码码流结构体指针\n\n @retval 0 成功\n @retval 非0 失败\n\n @remark 无。\n\n @attention 无。"]
    pub fn IMP_Decoder_ReleaseFrame(decChn: libc::c_int, frame: *mut IMPFrameInfo) -> libc::c_int;
}
#[doc = " 通道裁剪结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPFSChnCrop {
    #[doc = "< 使能裁剪功能"]
    pub enable: libc::c_int,
    #[doc = "< 裁剪左起始点"]
    pub left: libc::c_int,
    #[doc = "< 裁剪上起始点"]
    pub top: libc::c_int,
    #[doc = "< 图片裁剪宽度"]
    pub width: libc::c_int,
    #[doc = "< 图片裁剪高度"]
    pub height: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnCrop"][::core::mem::size_of::<IMPFSChnCrop>() - 20usize];
    ["Alignment of IMPFSChnCrop"][::core::mem::align_of::<IMPFSChnCrop>() - 4usize];
    ["Offset of field: IMPFSChnCrop::enable"]
        [::core::mem::offset_of!(IMPFSChnCrop, enable) - 0usize];
    ["Offset of field: IMPFSChnCrop::left"][::core::mem::offset_of!(IMPFSChnCrop, left) - 4usize];
    ["Offset of field: IMPFSChnCrop::top"][::core::mem::offset_of!(IMPFSChnCrop, top) - 8usize];
    ["Offset of field: IMPFSChnCrop::width"]
        [::core::mem::offset_of!(IMPFSChnCrop, width) - 12usize];
    ["Offset of field: IMPFSChnCrop::height"]
        [::core::mem::offset_of!(IMPFSChnCrop, height) - 16usize];
};
#[doc = " 通道缩放结构体"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPFSChnScaler {
    #[doc = "< 使能缩放功能"]
    pub enable: libc::c_int,
    #[doc = "< 缩放后图片宽度"]
    pub outwidth: libc::c_int,
    #[doc = "< 缩放后图片高度"]
    pub outheight: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnScaler"][::core::mem::size_of::<IMPFSChnScaler>() - 12usize];
    ["Alignment of IMPFSChnScaler"][::core::mem::align_of::<IMPFSChnScaler>() - 4usize];
    ["Offset of field: IMPFSChnScaler::enable"]
        [::core::mem::offset_of!(IMPFSChnScaler, enable) - 0usize];
    ["Offset of field: IMPFSChnScaler::outwidth"]
        [::core::mem::offset_of!(IMPFSChnScaler, outwidth) - 4usize];
    ["Offset of field: IMPFSChnScaler::outheight"]
        [::core::mem::offset_of!(IMPFSChnScaler, outheight) - 8usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPFSChnType {
    #[doc = "< 物理通道"]
    FS_PHY_CHANNEL = 0,
    #[doc = "< 拓展通道"]
    FS_EXT_CHANNEL = 1,
}
#[repr(u32)]
#[doc = " 通道FIFO类型"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPFSChnFifoType {
    #[doc = "< FIFO 优先缓存，然后输出数据"]
    FIFO_CACHE_PRIORITY = 0,
    #[doc = "< FIFO 优先输出数据，然后缓存"]
    FIFO_DATA_PRIORITY = 1,
}
#[doc = " 通道FIFO属性结构体"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnFifoAttr {
    #[doc = "< FIFO 最大深度"]
    pub maxdepth: libc::c_int,
    #[doc = "< 通道FIFO类型"]
    pub type_: IMPFSChnFifoType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnFifoAttr"][::core::mem::size_of::<IMPFSChnFifoAttr>() - 8usize];
    ["Alignment of IMPFSChnFifoAttr"][::core::mem::align_of::<IMPFSChnFifoAttr>() - 4usize];
    ["Offset of field: IMPFSChnFifoAttr::maxdepth"]
        [::core::mem::offset_of!(IMPFSChnFifoAttr, maxdepth) - 0usize];
    ["Offset of field: IMPFSChnFifoAttr::type_"]
        [::core::mem::offset_of!(IMPFSChnFifoAttr, type_) - 4usize];
};
impl Default for IMPFSChnFifoAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 通道属性结构体"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnAttr {
    #[doc = "< 图片宽度"]
    pub picWidth: libc::c_int,
    #[doc = "< 图片高度"]
    pub picHeight: libc::c_int,
    #[doc = "< 图片格式"]
    pub pixFmt: IMPPixelFormat,
    #[doc = "< 图片裁剪属性"]
    pub crop: IMPFSChnCrop,
    #[doc = "< 图片缩放属性"]
    pub scaler: IMPFSChnScaler,
    #[doc = "< 通道的输出帧率分子"]
    pub outFrmRateNum: libc::c_int,
    #[doc = "< 通道的输出帧率分母"]
    pub outFrmRateDen: libc::c_int,
    #[doc = "< Video buffer数量"]
    pub nrVBs: libc::c_int,
    #[doc = "< 通道类型"]
    pub type_: IMPFSChnType,
    #[doc = "< 图片镜像属性"]
    pub mirr_enable: libc::c_int,
    #[doc = "< 图片裁剪属性"]
    pub fcrop: IMPFSChnCrop,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnAttr"][::core::mem::size_of::<IMPFSChnAttr>() - 84usize];
    ["Alignment of IMPFSChnAttr"][::core::mem::align_of::<IMPFSChnAttr>() - 4usize];
    ["Offset of field: IMPFSChnAttr::picWidth"]
        [::core::mem::offset_of!(IMPFSChnAttr, picWidth) - 0usize];
    ["Offset of field: IMPFSChnAttr::picHeight"]
        [::core::mem::offset_of!(IMPFSChnAttr, picHeight) - 4usize];
    ["Offset of field: IMPFSChnAttr::pixFmt"]
        [::core::mem::offset_of!(IMPFSChnAttr, pixFmt) - 8usize];
    ["Offset of field: IMPFSChnAttr::crop"][::core::mem::offset_of!(IMPFSChnAttr, crop) - 12usize];
    ["Offset of field: IMPFSChnAttr::scaler"]
        [::core::mem::offset_of!(IMPFSChnAttr, scaler) - 32usize];
    ["Offset of field: IMPFSChnAttr::outFrmRateNum"]
        [::core::mem::offset_of!(IMPFSChnAttr, outFrmRateNum) - 44usize];
    ["Offset of field: IMPFSChnAttr::outFrmRateDen"]
        [::core::mem::offset_of!(IMPFSChnAttr, outFrmRateDen) - 48usize];
    ["Offset of field: IMPFSChnAttr::nrVBs"]
        [::core::mem::offset_of!(IMPFSChnAttr, nrVBs) - 52usize];
    ["Offset of field: IMPFSChnAttr::type_"]
        [::core::mem::offset_of!(IMPFSChnAttr, type_) - 56usize];
    ["Offset of field: IMPFSChnAttr::mirr_enable"]
        [::core::mem::offset_of!(IMPFSChnAttr, mirr_enable) - 60usize];
    ["Offset of field: IMPFSChnAttr::fcrop"]
        [::core::mem::offset_of!(IMPFSChnAttr, fcrop) - 64usize];
};
impl Default for IMPFSChnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_CreateChn(int chnNum, IMPFSChnAttr *chnAttr)\n\n 创建通道\n\n @param[in] chnNum 通道号\n @param[in] chnAttr 通道属性结构体指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 创建通道，给后端模块提供数据源; \\n\n 可以设置通道的相关属性，包括：图片宽度，图片高度，图片格式，通道的输出帧率, 缓存buf数，裁剪和缩放属性。\\n\n 对于T10，通道0、1只能被设置为物理通道，通道2,3只能被设置为拓展通道。\n\n @attention 无。"]
    pub fn IMP_FrameSource_CreateChn(
        chnNum: libc::c_int,
        chn_attr: *mut IMPFSChnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_DestroyChn(int chnNum)\n\n 销毁通道\n\n @param[in] chnNum 通道号\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 销毁通道\n\n @attention 如果程序调用过IMP_FrameSource_EnableChn，一定要调用IMP_FrameSource_DisableChn之后，再使用此函数。"]
    pub fn IMP_FrameSource_DestroyChn(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_EnableChn(int chnNum)\n\n 使能通道\n\n @param[in] chnNum 通道号\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 在使用这个函数之前，必须确保所使能的通道已经创建."]
    pub fn IMP_FrameSource_EnableChn(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_DisableChn(int chnNum)\n\n 关闭通道\n\n @param[in] chnNum 通道号\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无"]
    pub fn IMP_FrameSource_DisableChn(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_GetChnAttr(int chnNum, IMPFSChnAttr *chnAttr)\n\n 获得通道属性\n\n @param[in] chnNum 通道号\n\n @param[out] chnAttr 通道属性结构体指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 可以获得通道的相关属性，包括：图片宽度，图片高度，图片格式，通道的输出帧率, 缓存buf数，裁剪和缩放属性.\n\n @attention 无"]
    pub fn IMP_FrameSource_GetChnAttr(
        chnNum: libc::c_int,
        chnAttr: *mut IMPFSChnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_SetChnAttr(int chnNum, const IMPFSChnAttr *chnAttr)\n\n 设置通道属性\n\n @param[in] chnNum 通道号\n\n @param[in] chnAttr 通道属性结构体指针\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 可以设置通道的相关属性，包括：图片宽度，图片高度，图片格式，通道的输出帧率, 缓存buf数，裁剪和缩放属性.\n\n @attention 无"]
    pub fn IMP_FrameSource_SetChnAttr(
        chnNum: libc::c_int,
        chnAttr: *const IMPFSChnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetFrameDepth(int chnNum, int depth)\n\n 设置可获取的图像最大深度\n\n @param[in] chnNum 通道的编号\n @param[in] depth 设置可获取的图像最大深度值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 此接口用于设置某一通道缓存的视频图像帧数。当用户设置缓存多帧视频图像时，用户可以获取到一定数目的连续图像数据。\n @remark 若指定depth为0，表示不需要系统为该通道缓存图像，故用户获取不到该通道图像数据。系统默认不为通道缓存图像，即depth默认为0。\n @remark 系统将自动更新最旧的图像数据，保证用户一旦开始获取，就可获取到最近最新的图像。\n @remark 系统因获取不到图像而自动停止缓存新的图像，用户也不能获取新的图像。因此建议用户保证获取和释放接口配对使用。\n @remark 系统将自动更新用户仍未获取的最旧的图像数据，保证缓存的图像队列为最近最新的图像。由于用户不能保证获取速度，导致获取的可能不是连续的图像。\n @remark 此函数可以调用位置，没有要求。但是只能使用一次。\n\n @attention 无."]
    pub fn IMP_FrameSource_SetFrameDepth(chnNum: libc::c_int, depth: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetFrameDepth(int chnNum, int *depth);\n\n 获取的图像最大深度\n\n @param[in] chnNum 通道的编号\n @param[out] depth 获取的图像最大深度值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 无."]
    pub fn IMP_FrameSource_GetFrameDepth(
        chnNum: libc::c_int,
        depth: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetFrame(int chnNum, IMPFrameInfo **frame);\n\n 获取的图像\n\n @param[in] chnNum 通道的编号\n @param[out] frame 获取的图像\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 此接口可以获取指定通道的视频图像信息。图像信息主要包括：图像的宽度、高度、像素格式以及图片数据起始地址。\n @remark 此接口需在通道已启用后才有效。\n @remark 支持多次获取后再释放，但建议获取和释放接口配对使用。\n @remark 该接口默认超时时间为 2s，即2s 内仍未获取到图像，则超时返回。\n\n @attention 无."]
    pub fn IMP_FrameSource_GetFrame(
        chnNum: libc::c_int,
        frame: *mut *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetTimedFrame(int chnNum, IMPFrameTimestamp *framets, int block, void *framedata, IMPFrameInfo *frame);\n\n 获取指定时间的图像\n\n @param[in] chnNum 通道的编号\n @param[in] framets 时间信息\n @param[in] block 阻塞属性\n @param[in] framedata 拷贝图像的内存指针\n @param[in] frame 获取到图像信息\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 此接口可以获取指定通道指定时间的视频图像信息。图像信息主要包括：图像的宽度、高度、像素格式以及图片数据。\n @remark 此接口需在通道已启用后才有效。\n @remark 此接口需要先设置IMP_FrameSource_SetMaxDelay和IMP_FrameSource_SetDelay。\n\n @attention 无."]
    pub fn IMP_FrameSource_GetTimedFrame(
        chnNum: libc::c_int,
        framets: *mut IMPFrameTimestamp,
        block: libc::c_int,
        framedata: *mut libc::c_void,
        frame: *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_ReleaseFrame(int chnNum, IMPFrameInfo *frame);\n\n 释放获取的图像\n\n @param[in] chnNum 通道的编号\n @param[in] frame 释放获取的图像\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 无."]
    pub fn IMP_FrameSource_ReleaseFrame(
        chnNum: libc::c_int,
        frame: *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SnapFrame(int chnNum, IMPPixelFormat fmt, int width, int height, void *framedata, IMPFrameInfo *frame);\n\n 获取图像\n\n @param[in] chnNum 通道的编号\n @param[in] fmt    图像格式\n @param[in] width  图像宽度\n @param[in] height 图像高度\n @param[in] framedata 拷贝图像的内存指针\n @param[in] frame 获取到图像信息\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 此接口可以获取一帧指定格式和大小的图像；目前格式支持NV12，YUYV422；\\n\n 大小和通道分辨率一致；不需要调用IMP_FrameSource_SetFrameDepth接口.\n @remark 此接口需在通道已启用后才有效。\n\n\n @attention 无."]
    pub fn IMP_FrameSource_SnapFrame(
        chnNum: libc::c_int,
        fmt: IMPPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        framedata: *mut libc::c_void,
        frame: *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetMaxDelay(int chnNum, int maxcnt);\n\n 设置最大延迟帧数\n\n @param[in] chnNum 通道的编号\n @param[in] maxcnt 最大延迟，单位帧\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn与IMP_FrameSource_EnableChn之间调用."]
    pub fn IMP_FrameSource_SetMaxDelay(chnNum: libc::c_int, maxcnt: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetMaxDelay(int chnNum, int *maxcnt);\n\n 获取最大延迟帧数\n\n @param[in] chnNum 通道的编号\n @param[out] maxcnt 最大延迟，单位帧\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn之后."]
    pub fn IMP_FrameSource_GetMaxDelay(
        chnNum: libc::c_int,
        maxcnt: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetDelay(int chnNum, int cnt);\n\n 设置延迟帧数\n\n @param[in] chnNum 通道的编号\n @param[in] cnt 延迟，单位帧\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 使用时需要在函数IMP_FrameSource_SetMaxDelay之后调用."]
    pub fn IMP_FrameSource_SetDelay(chnNum: libc::c_int, cnt: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetDelay(int chnNum, int *cnt);\n\n 获取延迟帧数\n\n @param[in] chnNum 通道的编号\n @param[out] cnt 延迟，单位帧\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn之后."]
    pub fn IMP_FrameSource_GetDelay(chnNum: libc::c_int, cnt: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetChnFifoAttr(int chnNum, IMPFSChnFifoAttr *attr);\n\n 设置通道最大缓存FIFO属性\n\n @param[in] chnNum 通道的编号\n @param[in] attr\tFIFO属性，包括 FIFO最大深度，单位帧；FIFO 类型.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn与IMP_FrameSource_EnableChn之间调用."]
    pub fn IMP_FrameSource_SetChnFifoAttr(
        chnNum: libc::c_int,
        attr: *mut IMPFSChnFifoAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetChnFifoAttr(int chnNum, IMPFSChnFifoAttr *attr);\n\n 获取通道最大缓存FIFO属性\n\n @param[in] chnNum 通道的编号\n @param[out] attr\tFIFO属性.\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn之后."]
    pub fn IMP_FrameSource_GetChnFifoAttr(
        chnNum: libc::c_int,
        attr: *mut IMPFSChnFifoAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_SetPool(int chnNum, int poolID);\n\n 绑定chnnel 到内存池中，即FrameSource申请mem从pool申请.\n\n @param[in] chnNum\t\t通道编号.\n @param[in] poolID\t\t内存池编号.\n\n @retval 0\t\t\t\t成功.\n @retval 非0\t\t\t\t失败.\n\n @remark  为了解决rmem碎片化，将该channel FrameSource 绑定到对应的mempool  \\n\n 中, FramSource 申请mem就在mempool中申请，若不调用，FramSource会在rmem中申请 \\n\n 此时对于rmem来说会存在碎片的可能\n\n @attention ChannelId 必须大于等于0 且小于32."]
    pub fn IMP_FrameSource_SetPool(chnNum: libc::c_int, poolID: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_GetPool(int chnNum);\n\n 通过channel ID 获取poolID.\n\n @param[in] chnNum       通道编号.\n\n @retval  >=0 && < 32    成功.\n @retval  <0\t\t\t   失败.\n\n @remark 通过ChannelId 获取poolId, 客户暂时用不到\n\n @attention 无."]
    pub fn IMP_FrameSource_GetPool(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_SetDirectModeAttr(int chnNum, int data_threshold)\n\n 设置双摄直通时，根据编码数据缓存阈值决定编码或丢帧.\n\n @param[in] chnNum          通道编号.\n @param[in] data_threshold  编码缓存阈值\n\n @retval 0                  成功.\n @retval 非0                失败.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn之后."]
    pub fn IMP_FrameSource_SetDirectModeAttr(
        chnNum: libc::c_int,
        data_threshold: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_GetDirectModeAttr(int chnNum, int *data_threshold)\n\n 获取双摄直通时编码数据缓存值.\n\n @param[in] chnNum           通道编号.\n @param[out] data_threshold  编码缓存阈值\n\n @retval 0                   成功.\n @retval 非0                 失败.\n\n @attention 使用时需要在函数IMP_FrameSource_CreateChn之后."]
    pub fn IMP_FrameSource_GetDirectModeAttr(
        chnNum: libc::c_int,
        data_threshold: *mut libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " 选择加密算法.\n @remarks 支持AES和DES两种加密算法."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_ALG_E {
    IN_UNF_CIPHER_ALG_AES = 0,
    IN_UNF_CIPHER_ALG_DES = 1,
}
#[doc = " 选择加密算法.\n @remarks 支持AES和DES两种加密算法."]
pub use self::IN_UNF_CIPHER_ALG_E as IN_UNF_CIPHER_ALG;
#[repr(u32)]
#[doc = " 选择加密模式.\n @remarks 支持CBC和ECB两种加密模式."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_WORK_MODE_E {
    IN_UNF_CIPHER_WORK_MODE_ECB = 0,
    IN_UNF_CIPHER_WORK_MODE_CBC = 1,
    IN_UNF_CIPHER_WORK_MODE_OTHER = 2,
}
#[doc = " 选择加密模式.\n @remarks 支持CBC和ECB两种加密模式."]
pub use self::IN_UNF_CIPHER_WORK_MODE_E as IN_UNF_CIPHER_WORK_MODE;
#[repr(u32)]
#[doc = " 选择加密使用的密钥长度.\n @remarks 受硬件的限制,现阶段只支持128bit长度的KEY."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_KEY_LENGTH_E {
    IN_UNF_CIPHER_KEY_AES_128BIT = 0,
}
#[doc = " 选择加密使用的密钥长度.\n @remarks 受硬件的限制,现阶段只支持128bit长度的KEY."]
pub use self::IN_UNF_CIPHER_KEY_LENGTH_E as IN_UNF_CIPHER_KEY_LENGTH;
#[repr(u32)]
#[doc = " 选择加密算法一次处理的数据长度.\n @remarks 受硬件的限制,现阶段只支持一次处理128bit长度的数据."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_BIT_WIDTH_E {
    IN_UNF_CIPHER_BIT_WIDTH_128BIT = 0,
}
#[doc = " 选择加密算法一次处理的数据长度.\n @remarks 受硬件的限制,现阶段只支持一次处理128bit长度的数据."]
pub use self::IN_UNF_CIPHER_BIT_WIDTH_E as IN_UNF_CIPHER_BIT_WIDTH;
#[doc = " 选择加密处理控制结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IN_UNF_CIPHER_CTRL_S {
    #[doc = "< 加密时使用的密钥"]
    pub key: [libc::c_uint; 4usize],
    #[doc = "< 加密时使用的IV向量"]
    pub IV: [libc::c_uint; 4usize],
    #[doc = "< 需要处理的数据总长度"]
    pub enDataLen: libc::c_uint,
    #[doc = "< 处理数据使用的加密算法"]
    pub enAlg: IN_UNF_CIPHER_ALG,
    #[doc = "< 加密算法一次处理的数据长度"]
    pub enBitWidth: IN_UNF_CIPHER_BIT_WIDTH,
    #[doc = "< 处理数据使用的加密算法的模式"]
    pub enWorkMode: IN_UNF_CIPHER_WORK_MODE,
    #[doc = "< 加密算法使用的KEY的长度"]
    pub enKeyLen: IN_UNF_CIPHER_KEY_LENGTH,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IN_UNF_CIPHER_CTRL_S"][::core::mem::size_of::<IN_UNF_CIPHER_CTRL_S>() - 52usize];
    ["Alignment of IN_UNF_CIPHER_CTRL_S"][::core::mem::align_of::<IN_UNF_CIPHER_CTRL_S>() - 4usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::key"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, key) - 0usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::IV"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, IV) - 16usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enDataLen"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enDataLen) - 32usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enAlg"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enAlg) - 36usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enBitWidth"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enBitWidth) - 40usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enWorkMode"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enWorkMode) - 44usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enKeyLen"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enKeyLen) - 48usize];
};
impl Default for IN_UNF_CIPHER_CTRL_S {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 选择加密处理控制结构体."]
pub type IN_UNF_CIPHER_CTRL = IN_UNF_CIPHER_CTRL_S;
extern "C" {
    #[doc = " @fn int SU_CIPHER_Init(void)\n\n 加密模块打开接口.\n\n @param\t无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_CIPHER_Init() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Exit(void)\n\n 加密模块关闭接口.\n\n @param\t无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_CIPHER_Exit() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_CreateHandle(void)\n\n 获得加密模块句柄接口.\n\n @param\t无.\n\n @retval  成功: 返回句柄.\n @retval  失败: retval <  0.\n\n @remarks 无.\n\n @attention 该函数可以多次调用,每调用一次都会返回一个句柄.\n 当调用的N次该函数之后,需要调用N次SU_CIPHER_DestroyHandle()才可以\n 将所有的句柄销毁.\n"]
    pub fn SU_CIPHER_CreateHandle() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_DestroyHandle(int fd)\n\n 销毁加密模块句柄.\n\n @param[in] fd 需要销毁的句柄\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 该函数可以多次调用,每调用一次都会销毁一个句柄.\n"]
    pub fn SU_CIPHER_DestroyHandle(fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_ConfigHandle(int hCipher, IN_UNF_CIPHER_CTRL* Ctrl)\n\n 对加密模块进行配置.\n\n @param[in] hCipher 需要进行配置的句柄.\n @param[in] Ctrl 带有配置信息的结构体.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention  无.\n"]
    pub fn SU_CIPHER_ConfigHandle(
        hCipher: libc::c_int,
        Ctrl: *mut IN_UNF_CIPHER_CTRL,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Encrypt(int hCipher, unsigned int * srcAddr, unsigned int * dstAddr, unsigned int dataLen)\n\n 开始进行数据的加密.\n\n @param[in] hCipher 需要进行操作的句柄.\n @param[in] srcAddr 需要进行加密的数据源地址.\n @param[in] dstAddr 加密完成之后的数据存放地址.\n @param[in] dataLen 需要处理的数据长度.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention  加密的数据长度dataLen最大不要超过1Mbyte (1024*1024).\n"]
    pub fn SU_CIPHER_Encrypt(
        hCipher: libc::c_int,
        srcAddr: *mut libc::c_uint,
        dstAddr: *mut libc::c_uint,
        dataLen: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Decrypt(int hCipher, unsigned int * srcAddr, unsigned int * dstAddr, unsigned int dataLen);\n\n 开始进行数据的解密.\n\n @param[in] hCipher 需要进行操作的句柄.\n @param[in] srcAddr 需要进行解密的数据源地址.\n @param[in] dstAddr 解密完成之后的数据存放地址.\n @param[in] dataLen 需要处理的数据长度.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention  解密的数据长度dataLen最大不要超过1Mbyte (1024*1024).\n"]
    pub fn SU_CIPHER_Decrypt(
        hCipher: libc::c_int,
        srcAddr: *mut libc::c_uint,
        dstAddr: *mut libc::c_uint,
        dataLen: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_Init(void);\n\n 初始化ADC模块\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 使用ADC之前，一定要调用这个函数。\n\n @attention 无。"]
    pub fn SU_ADC_Init() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_Exit(void);\n\n 去初始化ADC模块\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 不使用ADC之后，一定要调用这个函数。\n\n @attention 无。"]
    pub fn SU_ADC_Exit() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_EnableChn(uint32_t chn_num);\n\n 启动通道\n\n @param[in] chn_num 启动第几路通道\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无."]
    pub fn SU_ADC_EnableChn(chn_num: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_DisableChn(uint32_t chn_num);\n\n 关闭通道\n\n @param[in] chn_num 停止第几路通道\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无"]
    pub fn SU_ADC_DisableChn(chn_num: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_GetChnValue(uint32_t chn_num, int *value);\n\n 得到第chn_num通道的ADC值\n\n @param[in] chn_num 第几路通道\n\n @param[out] value 得到的ADC值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无"]
    pub fn SU_ADC_GetChnValue(chn_num: u32, value: *mut libc::c_int) -> libc::c_int;
}
#[repr(i32)]
#[doc = " 电池状态."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SUBatStatus {
    #[doc = "< 未知状态或者没有电池"]
    Unknown = -1,
    #[doc = "< 充电中"]
    Charging = 0,
    #[doc = "< 未充电"]
    Discharging = 1,
    #[doc = "< 充满电"]
    Full = 2,
}
#[repr(u32)]
#[doc = " 电池事件."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SUBatEvent {
    #[doc = "< AC Adapter插入"]
    AC_ONLINE = 0,
    #[doc = "< AC Adapter拔出"]
    AC_OFFLINE = 1,
    #[doc = "< USB插入"]
    USB_ONLINE = 2,
    #[doc = "< USB拔出"]
    USB_OFFLINE = 3,
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetStatus(SUBatStatus *status)\n\n 获取电池状态.\n\n @param[in] status 电池状态指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 该函数直接返回,无阻塞.\n\n @attention 无."]
    pub fn SU_Battery_GetStatus(status: *mut SUBatStatus) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetEvent(SUBatEvent *event)\n\n 获取电池事件.\n\n @param[out] event 电池事件指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 该函数阻塞,直到有事件发生返回.\n\n @attention 无."]
    pub fn SU_Battery_GetEvent(event: *mut SUBatEvent) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetCapacity(void)\n\n 获取电池电量百分比.\n\n @param 无.\n\n @retval >=0 电池电量百分比.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Battery_GetCapacity() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetVoltageUV(void)\n\n 获取电池当前电压.\n\n @param 无.\n\n @retval >=0 电池电压,单位uV.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Battery_GetVoltageUV() -> libc::c_int;
}
#[doc = " 设备型号."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUModelNum {
    #[doc = "< 设备型号字符串"]
    pub chr: [libc::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUModelNum"][::core::mem::size_of::<SUModelNum>() - 64usize];
    ["Alignment of SUModelNum"][::core::mem::align_of::<SUModelNum>() - 1usize];
    ["Offset of field: SUModelNum::chr"][::core::mem::offset_of!(SUModelNum, chr) - 0usize];
};
impl Default for SUModelNum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 设备软件版本."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUVersion {
    #[doc = "< 设备软件版本字符串"]
    pub chr: [libc::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUVersion"][::core::mem::size_of::<SUVersion>() - 64usize];
    ["Alignment of SUVersion"][::core::mem::align_of::<SUVersion>() - 1usize];
    ["Offset of field: SUVersion::chr"][::core::mem::offset_of!(SUVersion, chr) - 0usize];
};
impl Default for SUVersion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 设备ID.设备ID为唯一值，不同的CPU芯片间的值有差异"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUDevID {
    #[doc = "< 设备ID字符串"]
    pub chr: [libc::c_char; 64usize],
    #[doc = "< 设备ID二进制"]
    pub hex: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUDevID"][::core::mem::size_of::<SUDevID>() - 64usize];
    ["Alignment of SUDevID"][::core::mem::align_of::<SUDevID>() - 1usize];
    ["Offset of field: SUDevID::chr"][::core::mem::offset_of!(SUDevID, chr) - 0usize];
    ["Offset of field: SUDevID::hex"][::core::mem::offset_of!(SUDevID, hex) - 0usize];
};
impl Default for SUDevID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " 系统时间结构体."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SUTime {
    #[doc = "< 秒数，范围：0~59"]
    pub sec: libc::c_int,
    #[doc = "< 分钟数，范围：0~59"]
    pub min: libc::c_int,
    #[doc = "< 小时数，范围：0~23"]
    pub hour: libc::c_int,
    #[doc = "< 一个月中的第几天，范围：1~31"]
    pub mday: libc::c_int,
    #[doc = "< 月份，范围：1~12"]
    pub mon: libc::c_int,
    #[doc = "< 年份，范围：>1900"]
    pub year: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUTime"][::core::mem::size_of::<SUTime>() - 24usize];
    ["Alignment of SUTime"][::core::mem::align_of::<SUTime>() - 4usize];
    ["Offset of field: SUTime::sec"][::core::mem::offset_of!(SUTime, sec) - 0usize];
    ["Offset of field: SUTime::min"][::core::mem::offset_of!(SUTime, min) - 4usize];
    ["Offset of field: SUTime::hour"][::core::mem::offset_of!(SUTime, hour) - 8usize];
    ["Offset of field: SUTime::mday"][::core::mem::offset_of!(SUTime, mday) - 12usize];
    ["Offset of field: SUTime::mon"][::core::mem::offset_of!(SUTime, mon) - 16usize];
    ["Offset of field: SUTime::year"][::core::mem::offset_of!(SUTime, year) - 20usize];
};
extern "C" {
    #[doc = " @fn int SU_Base_GetModelNumber(SUModelNum *modelNum)\n\n 获取设备型号.\n\n @param[out] modelNum 设备型号结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetModelNumber(modelNum: *mut SUModelNum) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetVersion(SUVersion *version)\n\n 获取设备版本.\n\n @param[out] version 设备版本结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetVersion(version: *mut SUVersion) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetDevID(SUDevID *devID)\n\n 获取设备ID.\n\n @param[out] devID 设备ID结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 每颗CPU芯片的设备ID是唯一的.\n\n @attention 无."]
    pub fn SU_Base_GetDevID(devID: *mut SUDevID) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetTime(SUTime *time)\n\n 获得系统时间.\n\n @param[in] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetTime(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SetTime(SUTime *time)\n\n 设置系统时间.\n\n @param[out] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 系统时间参数需在合理范围，否则函数调用失败."]
    pub fn SU_Base_SetTime(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SUTime2Raw(SUTime *suTime, uint32_t *rawTime)\n\n 将SUTime类型的时间转换为以秒为单位的Raw时间.\n\n @param[in] suTime 系统时间结构体指针.\n @param[out] rawTime Raw时间(从1970-01-01 00:00:00开始算起).\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 此函数可以用在设置相对秒数的Alarm.\n\n @attention 无."]
    pub fn SU_Base_SUTime2Raw(suTime: *mut SUTime, rawTime: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Raw2SUTime(uint32_t *rawTime, SUTime *suTime)\n\n 将以秒为单位的Raw时间转换为SUTime类型的时间.\n\n @param[in] rawTime Raw时间(从1970-01-01 00:00:00开始算起).\n @param[out] suTime 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 此函数可以用在设置相对秒数的Alarm.\n\n @attention 无."]
    pub fn SU_Base_Raw2SUTime(rawTime: *mut u32, suTime: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SetAlarm(SUTime *time)\n\n 设定闹钟时间.\n\n @param[in] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 暂支持24小时内的闹钟设定.\n\n @attention 系统时间参数需在合理范围，否则函数调用失败."]
    pub fn SU_Base_SetAlarm(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetAlarm(SUTime *time)\n\n 获得闹钟定时时间.\n\n @param[out] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetAlarm(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_EnableAlarm()\n\n 使能闹钟.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数之前，请调用SU_Base_GetAlarm（SUTime *time）设定闹钟时间.\n\n @attention 如果闹钟时间在当前系统时间之前返回失败."]
    pub fn SU_Base_EnableAlarm() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_DisableAlarm()\n\n 关闭闹钟.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_DisableAlarm() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_PollingAlarm(uint32_t timeoutMsec)\n\n 等待闹钟.\n\n @param[in] 超时时间，单位：毫秒.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后，程序会进入阻塞状态，一直到闹钟响应退出或超时退出.\n\n @attention 无."]
    pub fn SU_Base_PollingAlarm(timeoutMsec: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Shutdown(void)\n\n 设备关机.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后设备会立即关机并关闭主电源.\n\n @attention 在调用此函数之前请确保已保存所有文件."]
    pub fn SU_Base_Shutdown() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Reboot(void)\n\n 设备重启.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后设备会立即重启.\n\n @attention 在调用此函数之前请确保已保存所有文件."]
    pub fn SU_Base_Reboot() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Suspend(void)\n\n 设备休眠.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后设备会立即进入休眠,函数正常退出后说明系统已经唤醒.\n\n @attention 无."]
    pub fn SU_Base_Suspend() -> libc::c_int;
}
#[repr(u32)]
#[doc = " 按键事件."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SUKeyEvent {
    #[doc = "< 按键抬起"]
    KEY_RELEASED = 0,
    #[doc = "< 按键按下"]
    KEY_PRESSED = 1,
}
#[repr(u32)]
#[doc = " LED行为命令."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SULedCmd {
    #[doc = "< LED关闭"]
    LED_OFF = 0,
    #[doc = "< LED打开"]
    LED_ON = 1,
}
extern "C" {
    #[doc = " @fn int SU_Key_OpenEvent(void)\n\n 获得按键事件句柄.\n\n @param 无\n\n @retval >0 按键事件句柄.\n @retval <=0 失败.\n\n @remarks 在成功获得一个按键事件句柄之后，即开始“记录”按键事件，直到关闭这个按键事件。\n @remarks 若打开多个句柄，则每个按键事件会记录一份按键事件。\n @remarks 例如，两个线程分别打开了一个按键事件，每个线程持有一个句柄，则这两个线程会读取到相同的事件序列。\n 但是如果两个线程共享同一个句柄，则每个按键事件只能被读取到一次。\n\n @attention 无。"]
    pub fn SU_Key_OpenEvent() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_CloseEvent(int evfd)\n\n 关闭按键事件.\n\n @param[in] evfd 按键事件句柄\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无\n\n @attention 无。"]
    pub fn SU_Key_CloseEvent(evfd: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_ReadEvent(int evfd, int *keyCode, SUKeyEvent *event)\n\n 读取按键事件.\n\n @param[in] evfd 按键事件句柄\n @param[in] keyCode 按键码\n @param[out] event 按键事件指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 该函数阻塞，直到有按键事件发生返回.\n @remarks 按键码的定义在linux/input.h中，与GPIO的映射关系定义在kernel板级文件中。\n @remarks 例如几个常用的按键：\n @code\n#define KEY_HOME                102 //HOME键\n#define KEY_POWER               116 //开关机键，一般也可用来作为唤醒键\n#define KEY_WAKEUP              143 //唤醒键，除POWER键之外用来唤醒系统的按键\n#define KEY_F13                 183 //当PIR作为按键使用时被定义为F13键\n @endcode\n\n @remarks 按键键码与GPIO号的定义，是否作为唤醒源，有效电平等信息均定义在内核板级文件中，如下所示：\n\n @code\nstruct gpio_keys_button __attribute__((weak)) board_buttons[] = {\n#ifdef GPIO_HOME\n{\n.gpio           = GPIO_HOME,\t\t//定义GPIO号\n.code           = KEY_HOME,\t\t\t//定义按键码\n.desc           = \"home key\",\n.active_low     = ACTIVE_LOW_HOME,\t//定义有效电平\n#ifdef WAKEUP_HOME\n.wakeup         = WAKEUP_HOME,\t\t//定义是否可做为唤醒源，1为可唤醒suspend\n#endif\n#ifdef CAN_DISABLE_HOME\n.can_disable    = CAN_DISABLE_HOME,\t//定义是否可以被Disable\n#endif\n},\n#endif\n#ifdef GPIO_POWER\n{\n.gpio           = GPIO_POWER,\n.code           = KEY_POWER,\n.desc           = \"power key\",\n.active_low     = ACTIVE_LOW_POWER,\n#ifdef WAKEUP_POWER\n.wakeup         = WAKEUP_POWER,\n#endif\n#ifdef CAN_DISABLE_POWER\n.can_disable    = CAN_DISABLE_POWER,\n#endif\n},\n#endif\n}\n @endcode\n @remarks 对于数字PIR，一种使用方式是把PIR作为一个按键定义，PIR触发相当于按键按下事件(@ref KEY_PRESSED)，\n PIR恢复相当于按键抬起事件(@ref KEY_RELEASED)。若需要PIR唤醒功能，则把PIR对应的按键定义为唤醒源即可。\n @remarks API详细使用方法请参考sample-keyevent.c.\n\n @attention 无。"]
    pub fn SU_Key_ReadEvent(
        evfd: libc::c_int,
        keyCode: *mut libc::c_int,
        event: *mut SUKeyEvent,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_DisableEvent(int keyCode)\n\n Disable按键事件.\n\n @param[in] keyCode 按键码\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 如果按键被配置为唤醒源，那么在系统suspend时，(无论该按键是否被Open)按下按键会使系统唤醒。\n 在Disable按键事件后，系统会关闭按键事件的中断，该按键也就无法唤醒系统\n @remarks 该API可用来Disable PIR\"按键\"唤醒系统。\n\n @attention 无。"]
    pub fn SU_Key_DisableEvent(keyCode: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_EnableEvent(int keyCode)\n\n Enable按键事件.\n\n @param[in] keyCode 按键码\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 作为Disable按键事件的反过程。详见@ref SU_Key_DisableEvent(int keyCode)\n\n @attention 无。"]
    pub fn SU_Key_EnableEvent(keyCode: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_LED_Command(int ledNum, SULedCmd cmd)\n\n 发送LED命令.\n\n @param[in] ledNum LED号.\n @param[in] cmd LED行为命令.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks LED号根据开发板的不同而不同。LED号定义在内核板级文件中，注册为Linux标\n 准Fixed Regulator设备。在板级文件中需定义LED的GPIO号，有效电平，电源递归关系等\n 信息。下面是定义了两个LED fixed regulator的例子：\n @code\nFIXED_REGULATOR_DEF(  //定义fixed regulator\nled0,\n\"LED0\",         3300000,        GPIO_PA(14),\nHIGH_ENABLE,    UN_AT_BOOT,     0,\n\"ldo7\",         \"vled0\",        NULL);\n\nFIXED_REGULATOR_DEF(\nled1,\n\"LED1\",         3300000,        GPIO_PA(15),\nHIGH_ENABLE,    UN_AT_BOOT,     0,\n\"ldo7\",         \"vled1\",        NULL);\n\nstatic struct platform_device *fixed_regulator_devices[] __initdata = {\n&gsensor_regulator_device,\n&led0_regulator_device,\n&led1_regulator_device,\n};\n\nstatic int __init fix_regulator_init(void)  //在subsys_initcall_sync中注册regulator\n{\nint i;\n\nfor (i = 0; i < ARRAY_SIZE(fixed_regulator_devices); i++)\nfixed_regulator_devices[i]->id = i;\n\nreturn platform_add_devices(fixed_regulator_devices,\nARRAY_SIZE(fixed_regulator_devices));\n}\nsubsys_initcall_sync(fix_regulator_init);\n @endcode\n @remarks 此API的使用示例：\n @code\nif (SU_LED_Command(0, LED_ON) < 0)  //使能LED0\nprintf(\"LED0 turn on error\\n\");\nif (SU_LED_Command(1, LED_ON) < 0)  //使能LED1\nprintf(\"LED0 turn on error\\n\");\nif (SU_LED_Command(0, LED_OFF) < 0)  //关闭LED0\nprintf(\"LED1 turn off error\\n\");\nif (SU_LED_Command(1, LED_OFF) < 0)  //关闭LED1\nprintf(\"LED1 turn off error\\n\");\n @endcode\n @attention 无。"]
    pub fn SU_LED_Command(ledNum: libc::c_int, cmd: SULedCmd) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut libc::c_void;
