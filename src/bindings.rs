#[allow(non_upper_case_globals)]
/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 30;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const _SGIDEFS_H: u32 = 1;
pub const _MIPS_ISA_MIPS1: u32 = 1;
pub const _MIPS_ISA_MIPS2: u32 = 2;
pub const _MIPS_ISA_MIPS3: u32 = 3;
pub const _MIPS_ISA_MIPS4: u32 = 4;
pub const _MIPS_ISA_MIPS5: u32 = 5;
pub const _MIPS_ISA_MIPS32: u32 = 6;
pub const _MIPS_ISA_MIPS64: u32 = 7;
pub const _ABIN32: u32 = 2;
pub const _MIPS_SIM_NABI32: u32 = 2;
pub const _ABI64: u32 = 3;
pub const _MIPS_SIM_ABI64: u32 = 3;
pub const _ABIO64: u32 = 4;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __NO_LONG_DOUBLE_MATH: u32 = 1;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const IMP_IVS_MOVE_MAX_ROI_CNT: u32 = 52;
pub const _PTHREAD_H: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 36;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 24;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 20;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 0;
pub const __PTHREAD_RWLOCK_ELISION_EXTRA: u32 = 0;
pub const __PTHREAD_SPINS: u32 = 0;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 0;
pub const __have_pthread_attr_t: u32 = 1;
pub const _MIPS_BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _SYS_TIME_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _IOC_SIZEBITS: u32 = 13;
pub const _IOC_DIRBITS: u32 = 3;
pub const _IOC_NONE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const _IOC_WRITE: u32 = 4;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 8191;
pub const _IOC_DIRMASK: u32 = 7;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 29;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 536805376;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const V4L2_SEL_TGT_CROP: u32 = 0;
pub const V4L2_SEL_TGT_CROP_DEFAULT: u32 = 1;
pub const V4L2_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SEL_TGT_NATIVE_SIZE: u32 = 3;
pub const V4L2_SEL_TGT_COMPOSE: u32 = 256;
pub const V4L2_SEL_TGT_COMPOSE_DEFAULT: u32 = 257;
pub const V4L2_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SEL_TGT_COMPOSE_PADDED: u32 = 259;
pub const V4L2_SEL_FLAG_GE: u32 = 1;
pub const V4L2_SEL_FLAG_LE: u32 = 2;
pub const V4L2_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_SEL_TGT_CROP_ACTIVE: u32 = 0;
pub const V4L2_SEL_TGT_COMPOSE_ACTIVE: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_ACTUAL: u32 = 0;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_ACTUAL: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_GE: u32 = 1;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_LE: u32 = 2;
pub const V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_CTRL_CLASS_USER: u32 = 9961472;
pub const V4L2_CTRL_CLASS_MPEG: u32 = 10027008;
pub const V4L2_CTRL_CLASS_CAMERA: u32 = 10092544;
pub const V4L2_CTRL_CLASS_FM_TX: u32 = 10158080;
pub const V4L2_CTRL_CLASS_FLASH: u32 = 10223616;
pub const V4L2_CTRL_CLASS_JPEG: u32 = 10289152;
pub const V4L2_CTRL_CLASS_IMAGE_SOURCE: u32 = 10354688;
pub const V4L2_CTRL_CLASS_IMAGE_PROC: u32 = 10420224;
pub const V4L2_CTRL_CLASS_DV: u32 = 10485760;
pub const V4L2_CTRL_CLASS_FM_RX: u32 = 10551296;
pub const V4L2_CTRL_CLASS_RF_TUNER: u32 = 10616832;
pub const V4L2_CTRL_CLASS_DETECT: u32 = 10682368;
pub const V4L2_CID_BASE: u32 = 9963776;
pub const V4L2_CID_USER_BASE: u32 = 9963776;
pub const V4L2_CID_USER_CLASS: u32 = 9961473;
pub const V4L2_CID_BRIGHTNESS: u32 = 9963776;
pub const V4L2_CID_CONTRAST: u32 = 9963777;
pub const V4L2_CID_SATURATION: u32 = 9963778;
pub const V4L2_CID_HUE: u32 = 9963779;
pub const V4L2_CID_AUDIO_VOLUME: u32 = 9963781;
pub const V4L2_CID_AUDIO_BALANCE: u32 = 9963782;
pub const V4L2_CID_AUDIO_BASS: u32 = 9963783;
pub const V4L2_CID_AUDIO_TREBLE: u32 = 9963784;
pub const V4L2_CID_AUDIO_MUTE: u32 = 9963785;
pub const V4L2_CID_AUDIO_LOUDNESS: u32 = 9963786;
pub const V4L2_CID_BLACK_LEVEL: u32 = 9963787;
pub const V4L2_CID_AUTO_WHITE_BALANCE: u32 = 9963788;
pub const V4L2_CID_DO_WHITE_BALANCE: u32 = 9963789;
pub const V4L2_CID_RED_BALANCE: u32 = 9963790;
pub const V4L2_CID_BLUE_BALANCE: u32 = 9963791;
pub const V4L2_CID_GAMMA: u32 = 9963792;
pub const V4L2_CID_WHITENESS: u32 = 9963792;
pub const V4L2_CID_EXPOSURE: u32 = 9963793;
pub const V4L2_CID_AUTOGAIN: u32 = 9963794;
pub const V4L2_CID_GAIN: u32 = 9963795;
pub const V4L2_CID_HFLIP: u32 = 9963796;
pub const V4L2_CID_VFLIP: u32 = 9963797;
pub const V4L2_CID_POWER_LINE_FREQUENCY: u32 = 9963800;
pub const V4L2_CID_HUE_AUTO: u32 = 9963801;
pub const V4L2_CID_WHITE_BALANCE_TEMPERATURE: u32 = 9963802;
pub const V4L2_CID_SHARPNESS: u32 = 9963803;
pub const V4L2_CID_BACKLIGHT_COMPENSATION: u32 = 9963804;
pub const V4L2_CID_CHROMA_AGC: u32 = 9963805;
pub const V4L2_CID_COLOR_KILLER: u32 = 9963806;
pub const V4L2_CID_COLORFX: u32 = 9963807;
pub const V4L2_CID_AUTOBRIGHTNESS: u32 = 9963808;
pub const V4L2_CID_BAND_STOP_FILTER: u32 = 9963809;
pub const V4L2_CID_ROTATE: u32 = 9963810;
pub const V4L2_CID_BG_COLOR: u32 = 9963811;
pub const V4L2_CID_CHROMA_GAIN: u32 = 9963812;
pub const V4L2_CID_ILLUMINATORS_1: u32 = 9963813;
pub const V4L2_CID_ILLUMINATORS_2: u32 = 9963814;
pub const V4L2_CID_MIN_BUFFERS_FOR_CAPTURE: u32 = 9963815;
pub const V4L2_CID_MIN_BUFFERS_FOR_OUTPUT: u32 = 9963816;
pub const V4L2_CID_ALPHA_COMPONENT: u32 = 9963817;
pub const V4L2_CID_COLORFX_CBCR: u32 = 9963818;
pub const V4L2_CID_LASTP1: u32 = 9963819;
pub const V4L2_CID_USER_MEYE_BASE: u32 = 9967872;
pub const V4L2_CID_USER_BTTV_BASE: u32 = 9967888;
pub const V4L2_CID_USER_S2255_BASE: u32 = 9967920;
pub const V4L2_CID_USER_SI476X_BASE: u32 = 9967936;
pub const V4L2_CID_USER_TI_VPE_BASE: u32 = 9967952;
pub const V4L2_CID_USER_SAA7134_BASE: u32 = 9967968;
pub const V4L2_CID_USER_ADV7180_BASE: u32 = 9967984;
pub const V4L2_CID_USER_TC358743_BASE: u32 = 9968000;
pub const V4L2_CID_USER_MAX217X_BASE: u32 = 9968016;
pub const V4L2_CID_USER_IMX_BASE: u32 = 9968048;
pub const V4L2_CID_MPEG_BASE: u32 = 10029312;
pub const V4L2_CID_MPEG_CLASS: u32 = 10027009;
pub const V4L2_CID_MPEG_STREAM_TYPE: u32 = 10029312;
pub const V4L2_CID_MPEG_STREAM_PID_PMT: u32 = 10029313;
pub const V4L2_CID_MPEG_STREAM_PID_AUDIO: u32 = 10029314;
pub const V4L2_CID_MPEG_STREAM_PID_VIDEO: u32 = 10029315;
pub const V4L2_CID_MPEG_STREAM_PID_PCR: u32 = 10029316;
pub const V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: u32 = 10029317;
pub const V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: u32 = 10029318;
pub const V4L2_CID_MPEG_STREAM_VBI_FMT: u32 = 10029319;
pub const V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: u32 = 10029412;
pub const V4L2_CID_MPEG_AUDIO_ENCODING: u32 = 10029413;
pub const V4L2_CID_MPEG_AUDIO_L1_BITRATE: u32 = 10029414;
pub const V4L2_CID_MPEG_AUDIO_L2_BITRATE: u32 = 10029415;
pub const V4L2_CID_MPEG_AUDIO_L3_BITRATE: u32 = 10029416;
pub const V4L2_CID_MPEG_AUDIO_MODE: u32 = 10029417;
pub const V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: u32 = 10029418;
pub const V4L2_CID_MPEG_AUDIO_EMPHASIS: u32 = 10029419;
pub const V4L2_CID_MPEG_AUDIO_CRC: u32 = 10029420;
pub const V4L2_CID_MPEG_AUDIO_MUTE: u32 = 10029421;
pub const V4L2_CID_MPEG_AUDIO_AAC_BITRATE: u32 = 10029422;
pub const V4L2_CID_MPEG_AUDIO_AC3_BITRATE: u32 = 10029423;
pub const V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK: u32 = 10029424;
pub const V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: u32 = 10029425;
pub const V4L2_CID_MPEG_VIDEO_ENCODING: u32 = 10029512;
pub const V4L2_CID_MPEG_VIDEO_ASPECT: u32 = 10029513;
pub const V4L2_CID_MPEG_VIDEO_B_FRAMES: u32 = 10029514;
pub const V4L2_CID_MPEG_VIDEO_GOP_SIZE: u32 = 10029515;
pub const V4L2_CID_MPEG_VIDEO_GOP_CLOSURE: u32 = 10029516;
pub const V4L2_CID_MPEG_VIDEO_PULLDOWN: u32 = 10029517;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_MODE: u32 = 10029518;
pub const V4L2_CID_MPEG_VIDEO_BITRATE: u32 = 10029519;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: u32 = 10029520;
pub const V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: u32 = 10029521;
pub const V4L2_CID_MPEG_VIDEO_MUTE: u32 = 10029522;
pub const V4L2_CID_MPEG_VIDEO_MUTE_YUV: u32 = 10029523;
pub const V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE: u32 = 10029524;
pub const V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER: u32 = 10029525;
pub const V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB: u32 = 10029526;
pub const V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE: u32 = 10029527;
pub const V4L2_CID_MPEG_VIDEO_HEADER_MODE: u32 = 10029528;
pub const V4L2_CID_MPEG_VIDEO_MAX_REF_PIC: u32 = 10029529;
pub const V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE: u32 = 10029530;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES: u32 = 10029531;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB: u32 = 10029532;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE: u32 = 10029533;
pub const V4L2_CID_MPEG_VIDEO_VBV_SIZE: u32 = 10029534;
pub const V4L2_CID_MPEG_VIDEO_DEC_PTS: u32 = 10029535;
pub const V4L2_CID_MPEG_VIDEO_DEC_FRAME: u32 = 10029536;
pub const V4L2_CID_MPEG_VIDEO_VBV_DELAY: u32 = 10029537;
pub const V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER: u32 = 10029538;
pub const V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE: u32 = 10029539;
pub const V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE: u32 = 10029540;
pub const V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME: u32 = 10029541;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL: u32 = 10029582;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE: u32 = 10029583;
pub const V4L2_CID_FWHT_I_FRAME_QP: u32 = 10029602;
pub const V4L2_CID_FWHT_P_FRAME_QP: u32 = 10029603;
pub const V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP: u32 = 10029612;
pub const V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP: u32 = 10029613;
pub const V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP: u32 = 10029614;
pub const V4L2_CID_MPEG_VIDEO_H263_MIN_QP: u32 = 10029615;
pub const V4L2_CID_MPEG_VIDEO_H263_MAX_QP: u32 = 10029616;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP: u32 = 10029662;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP: u32 = 10029663;
pub const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP: u32 = 10029664;
pub const V4L2_CID_MPEG_VIDEO_H264_MIN_QP: u32 = 10029665;
pub const V4L2_CID_MPEG_VIDEO_H264_MAX_QP: u32 = 10029666;
pub const V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM: u32 = 10029667;
pub const V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE: u32 = 10029668;
pub const V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE: u32 = 10029669;
pub const V4L2_CID_MPEG_VIDEO_H264_I_PERIOD: u32 = 10029670;
pub const V4L2_CID_MPEG_VIDEO_H264_LEVEL: u32 = 10029671;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA: u32 = 10029672;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA: u32 = 10029673;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE: u32 = 10029674;
pub const V4L2_CID_MPEG_VIDEO_H264_PROFILE: u32 = 10029675;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT: u32 = 10029676;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH: u32 = 10029677;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE: u32 = 10029678;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC: u32 = 10029679;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING: u32 = 10029680;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0: u32 = 10029681;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE: u32 = 10029682;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO: u32 = 10029683;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE: u32 = 10029684;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP: u32 = 10029685;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION: u32 = 10029686;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE: u32 = 10029687;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH: u32 = 10029688;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO: u32 = 10029689;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER: u32 = 10029690;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING: u32 = 10029691;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE: u32 = 10029692;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER: u32 = 10029693;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP: u32 = 10029694;
pub const V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION: u32 = 10029695;
pub const V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET: u32 = 10029696;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MIN_QP: u32 = 10029697;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MAX_QP: u32 = 10029698;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MIN_QP: u32 = 10029699;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MAX_QP: u32 = 10029700;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP: u32 = 10029712;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP: u32 = 10029713;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP: u32 = 10029714;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP: u32 = 10029715;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP: u32 = 10029716;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL: u32 = 10029717;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE: u32 = 10029718;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_QPEL: u32 = 10029719;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS: u32 = 10029812;
pub const V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4: u32 = 10029813;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES: u32 = 10029814;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL: u32 = 10029815;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS: u32 = 10029816;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD: u32 = 10029817;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL: u32 = 10029818;
pub const V4L2_CID_MPEG_VIDEO_VPX_MIN_QP: u32 = 10029819;
pub const V4L2_CID_MPEG_VIDEO_VPX_MAX_QP: u32 = 10029820;
pub const V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP: u32 = 10029821;
pub const V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP: u32 = 10029822;
pub const V4L2_CID_MPEG_VIDEO_VP8_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VPX_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VP9_PROFILE: u32 = 10029824;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP: u32 = 10029912;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP: u32 = 10029913;
pub const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP: u32 = 10029914;
pub const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP: u32 = 10029915;
pub const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP: u32 = 10029916;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP: u32 = 10029917;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE: u32 = 10029918;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER: u32 = 10029919;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP: u32 = 10029920;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP: u32 = 10029921;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP: u32 = 10029922;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP: u32 = 10029923;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP: u32 = 10029924;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP: u32 = 10029925;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP: u32 = 10029926;
pub const V4L2_CID_MPEG_VIDEO_HEVC_PROFILE: u32 = 10029927;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LEVEL: u32 = 10029928;
pub const V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION: u32 = 10029929;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TIER: u32 = 10029930;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH: u32 = 10029931;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE: u32 = 10029932;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2: u32 = 10029933;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2: u32 = 10029934;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE: u32 = 10029935;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD: u32 = 10029936;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU: u32 = 10029937;
pub const V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED: u32 = 10029938;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT: u32 = 10029939;
pub const V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB: u32 = 10029940;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID: u32 = 10029941;
pub const V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING: u32 = 10029942;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1: u32 = 10029943;
pub const V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT: u32 = 10029944;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION: u32 = 10029945;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE: u32 = 10029946;
pub const V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD: u32 = 10029947;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR: u32 = 10029948;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR: u32 = 10029949;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR: u32 = 10029950;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR: u32 = 10029951;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR: u32 = 10029952;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR: u32 = 10029953;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR: u32 = 10029954;
pub const V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES: u32 = 10029955;
pub const V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR: u32 = 10029956;
pub const V4L2_CID_MPEG_CX2341X_BASE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER: u32 = 10031105;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE: u32 = 10031106;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE: u32 = 10031107;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE: u32 = 10031108;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER: u32 = 10031109;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE: u32 = 10031110;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM: u32 = 10031111;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP: u32 = 10031112;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM: u32 = 10031113;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP: u32 = 10031114;
pub const V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS: u32 = 10031115;
pub const V4L2_CID_MPEG_MFC51_BASE: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE: u32 = 10031361;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE: u32 = 10031362;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE: u32 = 10031363;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING: u32 = 10031364;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV: u32 = 10031365;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT: u32 = 10031366;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF: u32 = 10031367;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY: u32 = 10031410;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK: u32 = 10031411;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH: u32 = 10031412;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC: u32 = 10031413;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P: u32 = 10031414;
pub const V4L2_CID_CAMERA_CLASS_BASE: u32 = 10094848;
pub const V4L2_CID_CAMERA_CLASS: u32 = 10092545;
pub const V4L2_CID_EXPOSURE_AUTO: u32 = 10094849;
pub const V4L2_CID_EXPOSURE_ABSOLUTE: u32 = 10094850;
pub const V4L2_CID_EXPOSURE_AUTO_PRIORITY: u32 = 10094851;
pub const V4L2_CID_PAN_RELATIVE: u32 = 10094852;
pub const V4L2_CID_TILT_RELATIVE: u32 = 10094853;
pub const V4L2_CID_PAN_RESET: u32 = 10094854;
pub const V4L2_CID_TILT_RESET: u32 = 10094855;
pub const V4L2_CID_PAN_ABSOLUTE: u32 = 10094856;
pub const V4L2_CID_TILT_ABSOLUTE: u32 = 10094857;
pub const V4L2_CID_FOCUS_ABSOLUTE: u32 = 10094858;
pub const V4L2_CID_FOCUS_RELATIVE: u32 = 10094859;
pub const V4L2_CID_FOCUS_AUTO: u32 = 10094860;
pub const V4L2_CID_ZOOM_ABSOLUTE: u32 = 10094861;
pub const V4L2_CID_ZOOM_RELATIVE: u32 = 10094862;
pub const V4L2_CID_ZOOM_CONTINUOUS: u32 = 10094863;
pub const V4L2_CID_PRIVACY: u32 = 10094864;
pub const V4L2_CID_IRIS_ABSOLUTE: u32 = 10094865;
pub const V4L2_CID_IRIS_RELATIVE: u32 = 10094866;
pub const V4L2_CID_AUTO_EXPOSURE_BIAS: u32 = 10094867;
pub const V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: u32 = 10094868;
pub const V4L2_CID_WIDE_DYNAMIC_RANGE: u32 = 10094869;
pub const V4L2_CID_IMAGE_STABILIZATION: u32 = 10094870;
pub const V4L2_CID_ISO_SENSITIVITY: u32 = 10094871;
pub const V4L2_CID_ISO_SENSITIVITY_AUTO: u32 = 10094872;
pub const V4L2_CID_EXPOSURE_METERING: u32 = 10094873;
pub const V4L2_CID_SCENE_MODE: u32 = 10094874;
pub const V4L2_CID_3A_LOCK: u32 = 10094875;
pub const V4L2_LOCK_EXPOSURE: u32 = 1;
pub const V4L2_LOCK_WHITE_BALANCE: u32 = 2;
pub const V4L2_LOCK_FOCUS: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_START: u32 = 10094876;
pub const V4L2_CID_AUTO_FOCUS_STOP: u32 = 10094877;
pub const V4L2_CID_AUTO_FOCUS_STATUS: u32 = 10094878;
pub const V4L2_AUTO_FOCUS_STATUS_IDLE: u32 = 0;
pub const V4L2_AUTO_FOCUS_STATUS_BUSY: u32 = 1;
pub const V4L2_AUTO_FOCUS_STATUS_REACHED: u32 = 2;
pub const V4L2_AUTO_FOCUS_STATUS_FAILED: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_RANGE: u32 = 10094879;
pub const V4L2_CID_PAN_SPEED: u32 = 10094880;
pub const V4L2_CID_TILT_SPEED: u32 = 10094881;
pub const V4L2_CID_FM_TX_CLASS_BASE: u32 = 10160384;
pub const V4L2_CID_FM_TX_CLASS: u32 = 10158081;
pub const V4L2_CID_RDS_TX_DEVIATION: u32 = 10160385;
pub const V4L2_CID_RDS_TX_PI: u32 = 10160386;
pub const V4L2_CID_RDS_TX_PTY: u32 = 10160387;
pub const V4L2_CID_RDS_TX_PS_NAME: u32 = 10160389;
pub const V4L2_CID_RDS_TX_RADIO_TEXT: u32 = 10160390;
pub const V4L2_CID_RDS_TX_MONO_STEREO: u32 = 10160391;
pub const V4L2_CID_RDS_TX_ARTIFICIAL_HEAD: u32 = 10160392;
pub const V4L2_CID_RDS_TX_COMPRESSED: u32 = 10160393;
pub const V4L2_CID_RDS_TX_DYNAMIC_PTY: u32 = 10160394;
pub const V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT: u32 = 10160395;
pub const V4L2_CID_RDS_TX_TRAFFIC_PROGRAM: u32 = 10160396;
pub const V4L2_CID_RDS_TX_MUSIC_SPEECH: u32 = 10160397;
pub const V4L2_CID_RDS_TX_ALT_FREQS_ENABLE: u32 = 10160398;
pub const V4L2_CID_RDS_TX_ALT_FREQS: u32 = 10160399;
pub const V4L2_CID_AUDIO_LIMITER_ENABLED: u32 = 10160448;
pub const V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: u32 = 10160449;
pub const V4L2_CID_AUDIO_LIMITER_DEVIATION: u32 = 10160450;
pub const V4L2_CID_AUDIO_COMPRESSION_ENABLED: u32 = 10160464;
pub const V4L2_CID_AUDIO_COMPRESSION_GAIN: u32 = 10160465;
pub const V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: u32 = 10160466;
pub const V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: u32 = 10160467;
pub const V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: u32 = 10160468;
pub const V4L2_CID_PILOT_TONE_ENABLED: u32 = 10160480;
pub const V4L2_CID_PILOT_TONE_DEVIATION: u32 = 10160481;
pub const V4L2_CID_PILOT_TONE_FREQUENCY: u32 = 10160482;
pub const V4L2_CID_TUNE_PREEMPHASIS: u32 = 10160496;
pub const V4L2_CID_TUNE_POWER_LEVEL: u32 = 10160497;
pub const V4L2_CID_TUNE_ANTENNA_CAPACITOR: u32 = 10160498;
pub const V4L2_CID_FLASH_CLASS_BASE: u32 = 10225920;
pub const V4L2_CID_FLASH_CLASS: u32 = 10223617;
pub const V4L2_CID_FLASH_LED_MODE: u32 = 10225921;
pub const V4L2_CID_FLASH_STROBE_SOURCE: u32 = 10225922;
pub const V4L2_CID_FLASH_STROBE: u32 = 10225923;
pub const V4L2_CID_FLASH_STROBE_STOP: u32 = 10225924;
pub const V4L2_CID_FLASH_STROBE_STATUS: u32 = 10225925;
pub const V4L2_CID_FLASH_TIMEOUT: u32 = 10225926;
pub const V4L2_CID_FLASH_INTENSITY: u32 = 10225927;
pub const V4L2_CID_FLASH_TORCH_INTENSITY: u32 = 10225928;
pub const V4L2_CID_FLASH_INDICATOR_INTENSITY: u32 = 10225929;
pub const V4L2_CID_FLASH_FAULT: u32 = 10225930;
pub const V4L2_FLASH_FAULT_OVER_VOLTAGE: u32 = 1;
pub const V4L2_FLASH_FAULT_TIMEOUT: u32 = 2;
pub const V4L2_FLASH_FAULT_OVER_TEMPERATURE: u32 = 4;
pub const V4L2_FLASH_FAULT_SHORT_CIRCUIT: u32 = 8;
pub const V4L2_FLASH_FAULT_OVER_CURRENT: u32 = 16;
pub const V4L2_FLASH_FAULT_INDICATOR: u32 = 32;
pub const V4L2_FLASH_FAULT_UNDER_VOLTAGE: u32 = 64;
pub const V4L2_FLASH_FAULT_INPUT_VOLTAGE: u32 = 128;
pub const V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE: u32 = 256;
pub const V4L2_CID_FLASH_CHARGE: u32 = 10225931;
pub const V4L2_CID_FLASH_READY: u32 = 10225932;
pub const V4L2_CID_JPEG_CLASS_BASE: u32 = 10291456;
pub const V4L2_CID_JPEG_CLASS: u32 = 10289153;
pub const V4L2_CID_JPEG_CHROMA_SUBSAMPLING: u32 = 10291457;
pub const V4L2_CID_JPEG_RESTART_INTERVAL: u32 = 10291458;
pub const V4L2_CID_JPEG_COMPRESSION_QUALITY: u32 = 10291459;
pub const V4L2_CID_JPEG_ACTIVE_MARKER: u32 = 10291460;
pub const V4L2_JPEG_ACTIVE_MARKER_APP0: u32 = 1;
pub const V4L2_JPEG_ACTIVE_MARKER_APP1: u32 = 2;
pub const V4L2_JPEG_ACTIVE_MARKER_COM: u32 = 65536;
pub const V4L2_JPEG_ACTIVE_MARKER_DQT: u32 = 131072;
pub const V4L2_JPEG_ACTIVE_MARKER_DHT: u32 = 262144;
pub const V4L2_CID_IMAGE_SOURCE_CLASS_BASE: u32 = 10356992;
pub const V4L2_CID_IMAGE_SOURCE_CLASS: u32 = 10354689;
pub const V4L2_CID_VBLANK: u32 = 10356993;
pub const V4L2_CID_HBLANK: u32 = 10356994;
pub const V4L2_CID_ANALOGUE_GAIN: u32 = 10356995;
pub const V4L2_CID_TEST_PATTERN_RED: u32 = 10356996;
pub const V4L2_CID_TEST_PATTERN_GREENR: u32 = 10356997;
pub const V4L2_CID_TEST_PATTERN_BLUE: u32 = 10356998;
pub const V4L2_CID_TEST_PATTERN_GREENB: u32 = 10356999;
pub const V4L2_CID_IMAGE_PROC_CLASS_BASE: u32 = 10422528;
pub const V4L2_CID_IMAGE_PROC_CLASS: u32 = 10420225;
pub const V4L2_CID_LINK_FREQ: u32 = 10422529;
pub const V4L2_CID_PIXEL_RATE: u32 = 10422530;
pub const V4L2_CID_TEST_PATTERN: u32 = 10422531;
pub const V4L2_CID_DEINTERLACING_MODE: u32 = 10422532;
pub const V4L2_CID_DIGITAL_GAIN: u32 = 10422533;
pub const V4L2_CID_DV_CLASS_BASE: u32 = 10488064;
pub const V4L2_CID_DV_CLASS: u32 = 10485761;
pub const V4L2_CID_DV_TX_HOTPLUG: u32 = 10488065;
pub const V4L2_CID_DV_TX_RXSENSE: u32 = 10488066;
pub const V4L2_CID_DV_TX_EDID_PRESENT: u32 = 10488067;
pub const V4L2_CID_DV_TX_MODE: u32 = 10488068;
pub const V4L2_CID_DV_TX_RGB_RANGE: u32 = 10488069;
pub const V4L2_CID_DV_TX_IT_CONTENT_TYPE: u32 = 10488070;
pub const V4L2_CID_DV_RX_POWER_PRESENT: u32 = 10488164;
pub const V4L2_CID_DV_RX_RGB_RANGE: u32 = 10488165;
pub const V4L2_CID_DV_RX_IT_CONTENT_TYPE: u32 = 10488166;
pub const V4L2_CID_FM_RX_CLASS_BASE: u32 = 10553600;
pub const V4L2_CID_FM_RX_CLASS: u32 = 10551297;
pub const V4L2_CID_TUNE_DEEMPHASIS: u32 = 10553601;
pub const V4L2_CID_RDS_RECEPTION: u32 = 10553602;
pub const V4L2_CID_RDS_RX_PTY: u32 = 10553603;
pub const V4L2_CID_RDS_RX_PS_NAME: u32 = 10553604;
pub const V4L2_CID_RDS_RX_RADIO_TEXT: u32 = 10553605;
pub const V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT: u32 = 10553606;
pub const V4L2_CID_RDS_RX_TRAFFIC_PROGRAM: u32 = 10553607;
pub const V4L2_CID_RDS_RX_MUSIC_SPEECH: u32 = 10553608;
pub const V4L2_CID_RF_TUNER_CLASS_BASE: u32 = 10619136;
pub const V4L2_CID_RF_TUNER_CLASS: u32 = 10616833;
pub const V4L2_CID_RF_TUNER_BANDWIDTH_AUTO: u32 = 10619147;
pub const V4L2_CID_RF_TUNER_BANDWIDTH: u32 = 10619148;
pub const V4L2_CID_RF_TUNER_RF_GAIN: u32 = 10619168;
pub const V4L2_CID_RF_TUNER_LNA_GAIN_AUTO: u32 = 10619177;
pub const V4L2_CID_RF_TUNER_LNA_GAIN: u32 = 10619178;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO: u32 = 10619187;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN: u32 = 10619188;
pub const V4L2_CID_RF_TUNER_IF_GAIN_AUTO: u32 = 10619197;
pub const V4L2_CID_RF_TUNER_IF_GAIN: u32 = 10619198;
pub const V4L2_CID_RF_TUNER_PLL_LOCK: u32 = 10619227;
pub const V4L2_CID_DETECT_CLASS_BASE: u32 = 10684672;
pub const V4L2_CID_DETECT_CLASS: u32 = 10682369;
pub const V4L2_CID_DETECT_MD_MODE: u32 = 10684673;
pub const V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD: u32 = 10684674;
pub const V4L2_CID_DETECT_MD_THRESHOLD_GRID: u32 = 10684675;
pub const V4L2_CID_DETECT_MD_REGION_GRID: u32 = 10684676;
pub const VIDEO_MAX_FRAME: u32 = 32;
pub const VIDEO_MAX_PLANES: u32 = 8;
pub const V4L2_CAP_VIDEO_CAPTURE: u32 = 1;
pub const V4L2_CAP_VIDEO_OUTPUT: u32 = 2;
pub const V4L2_CAP_VIDEO_OVERLAY: u32 = 4;
pub const V4L2_CAP_VBI_CAPTURE: u32 = 16;
pub const V4L2_CAP_VBI_OUTPUT: u32 = 32;
pub const V4L2_CAP_SLICED_VBI_CAPTURE: u32 = 64;
pub const V4L2_CAP_SLICED_VBI_OUTPUT: u32 = 128;
pub const V4L2_CAP_RDS_CAPTURE: u32 = 256;
pub const V4L2_CAP_VIDEO_OUTPUT_OVERLAY: u32 = 512;
pub const V4L2_CAP_HW_FREQ_SEEK: u32 = 1024;
pub const V4L2_CAP_RDS_OUTPUT: u32 = 2048;
pub const V4L2_CAP_VIDEO_CAPTURE_MPLANE: u32 = 4096;
pub const V4L2_CAP_VIDEO_OUTPUT_MPLANE: u32 = 8192;
pub const V4L2_CAP_VIDEO_M2M_MPLANE: u32 = 16384;
pub const V4L2_CAP_VIDEO_M2M: u32 = 32768;
pub const V4L2_CAP_TUNER: u32 = 65536;
pub const V4L2_CAP_AUDIO: u32 = 131072;
pub const V4L2_CAP_RADIO: u32 = 262144;
pub const V4L2_CAP_MODULATOR: u32 = 524288;
pub const V4L2_CAP_SDR_CAPTURE: u32 = 1048576;
pub const V4L2_CAP_EXT_PIX_FORMAT: u32 = 2097152;
pub const V4L2_CAP_SDR_OUTPUT: u32 = 4194304;
pub const V4L2_CAP_META_CAPTURE: u32 = 8388608;
pub const V4L2_CAP_READWRITE: u32 = 16777216;
pub const V4L2_CAP_ASYNCIO: u32 = 33554432;
pub const V4L2_CAP_STREAMING: u32 = 67108864;
pub const V4L2_CAP_META_OUTPUT: u32 = 134217728;
pub const V4L2_CAP_TOUCH: u32 = 268435456;
pub const V4L2_CAP_DEVICE_CAPS: u32 = 2147483648;
pub const V4L2_PIX_FMT_PRIV_MAGIC: u32 = 4276996862;
pub const V4L2_PIX_FMT_FLAG_PREMUL_ALPHA: u32 = 1;
pub const V4L2_FMT_FLAG_COMPRESSED: u32 = 1;
pub const V4L2_FMT_FLAG_EMULATED: u32 = 2;
pub const V4L2_TC_TYPE_24FPS: u32 = 1;
pub const V4L2_TC_TYPE_25FPS: u32 = 2;
pub const V4L2_TC_TYPE_30FPS: u32 = 3;
pub const V4L2_TC_TYPE_50FPS: u32 = 4;
pub const V4L2_TC_TYPE_60FPS: u32 = 5;
pub const V4L2_TC_FLAG_DROPFRAME: u32 = 1;
pub const V4L2_TC_FLAG_COLORFRAME: u32 = 2;
pub const V4L2_TC_USERBITS_field: u32 = 12;
pub const V4L2_TC_USERBITS_USERDEFINED: u32 = 0;
pub const V4L2_TC_USERBITS_8BITCHARS: u32 = 8;
pub const V4L2_JPEG_MARKER_DHT: u32 = 8;
pub const V4L2_JPEG_MARKER_DQT: u32 = 16;
pub const V4L2_JPEG_MARKER_DRI: u32 = 32;
pub const V4L2_JPEG_MARKER_COM: u32 = 64;
pub const V4L2_JPEG_MARKER_APP: u32 = 128;
pub const V4L2_BUF_CAP_SUPPORTS_MMAP: u32 = 1;
pub const V4L2_BUF_CAP_SUPPORTS_USERPTR: u32 = 2;
pub const V4L2_BUF_CAP_SUPPORTS_DMABUF: u32 = 4;
pub const V4L2_BUF_CAP_SUPPORTS_REQUESTS: u32 = 8;
pub const V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS: u32 = 16;
pub const V4L2_BUF_FLAG_MAPPED: u32 = 1;
pub const V4L2_BUF_FLAG_QUEUED: u32 = 2;
pub const V4L2_BUF_FLAG_DONE: u32 = 4;
pub const V4L2_BUF_FLAG_KEYFRAME: u32 = 8;
pub const V4L2_BUF_FLAG_PFRAME: u32 = 16;
pub const V4L2_BUF_FLAG_BFRAME: u32 = 32;
pub const V4L2_BUF_FLAG_ERROR: u32 = 64;
pub const V4L2_BUF_FLAG_IN_REQUEST: u32 = 128;
pub const V4L2_BUF_FLAG_TIMECODE: u32 = 256;
pub const V4L2_BUF_FLAG_PREPARED: u32 = 1024;
pub const V4L2_BUF_FLAG_NO_CACHE_INVALIDATE: u32 = 2048;
pub const V4L2_BUF_FLAG_NO_CACHE_CLEAN: u32 = 4096;
pub const V4L2_BUF_FLAG_TIMESTAMP_MASK: u32 = 57344;
pub const V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN: u32 = 0;
pub const V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC: u32 = 8192;
pub const V4L2_BUF_FLAG_TIMESTAMP_COPY: u32 = 16384;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_MASK: u32 = 458752;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_EOF: u32 = 0;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_SOE: u32 = 65536;
pub const V4L2_BUF_FLAG_LAST: u32 = 1048576;
pub const V4L2_BUF_FLAG_REQUEST_FD: u32 = 8388608;
pub const V4L2_FBUF_CAP_EXTERNOVERLAY: u32 = 1;
pub const V4L2_FBUF_CAP_CHROMAKEY: u32 = 2;
pub const V4L2_FBUF_CAP_LIST_CLIPPING: u32 = 4;
pub const V4L2_FBUF_CAP_BITMAP_CLIPPING: u32 = 8;
pub const V4L2_FBUF_CAP_LOCAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_CAP_GLOBAL_ALPHA: u32 = 32;
pub const V4L2_FBUF_CAP_LOCAL_INV_ALPHA: u32 = 64;
pub const V4L2_FBUF_CAP_SRC_CHROMAKEY: u32 = 128;
pub const V4L2_FBUF_FLAG_PRIMARY: u32 = 1;
pub const V4L2_FBUF_FLAG_OVERLAY: u32 = 2;
pub const V4L2_FBUF_FLAG_CHROMAKEY: u32 = 4;
pub const V4L2_FBUF_FLAG_LOCAL_ALPHA: u32 = 8;
pub const V4L2_FBUF_FLAG_GLOBAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_FLAG_LOCAL_INV_ALPHA: u32 = 32;
pub const V4L2_FBUF_FLAG_SRC_CHROMAKEY: u32 = 64;
pub const V4L2_MODE_HIGHQUALITY: u32 = 1;
pub const V4L2_CAP_TIMEPERFRAME: u32 = 4096;
pub const V4L2_STD_UNKNOWN: u32 = 0;
pub const V4L2_DV_PROGRESSIVE: u32 = 0;
pub const V4L2_DV_INTERLACED: u32 = 1;
pub const V4L2_DV_VSYNC_POS_POL: u32 = 1;
pub const V4L2_DV_HSYNC_POS_POL: u32 = 2;
pub const V4L2_DV_BT_STD_CEA861: u32 = 1;
pub const V4L2_DV_BT_STD_DMT: u32 = 2;
pub const V4L2_DV_BT_STD_CVT: u32 = 4;
pub const V4L2_DV_BT_STD_GTF: u32 = 8;
pub const V4L2_DV_BT_STD_SDI: u32 = 16;
pub const V4L2_DV_FL_REDUCED_BLANKING: u32 = 1;
pub const V4L2_DV_FL_CAN_REDUCE_FPS: u32 = 2;
pub const V4L2_DV_FL_REDUCED_FPS: u32 = 4;
pub const V4L2_DV_FL_HALF_LINE: u32 = 8;
pub const V4L2_DV_FL_IS_CE_VIDEO: u32 = 16;
pub const V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE: u32 = 32;
pub const V4L2_DV_FL_HAS_PICTURE_ASPECT: u32 = 64;
pub const V4L2_DV_FL_HAS_CEA861_VIC: u32 = 128;
pub const V4L2_DV_FL_HAS_HDMI_VIC: u32 = 256;
pub const V4L2_DV_FL_CAN_DETECT_REDUCED_FPS: u32 = 512;
pub const V4L2_DV_BT_656_1120: u32 = 0;
pub const V4L2_DV_BT_CAP_INTERLACED: u32 = 1;
pub const V4L2_DV_BT_CAP_PROGRESSIVE: u32 = 2;
pub const V4L2_DV_BT_CAP_REDUCED_BLANKING: u32 = 4;
pub const V4L2_DV_BT_CAP_CUSTOM: u32 = 8;
pub const V4L2_INPUT_TYPE_TUNER: u32 = 1;
pub const V4L2_INPUT_TYPE_CAMERA: u32 = 2;
pub const V4L2_INPUT_TYPE_TOUCH: u32 = 3;
pub const V4L2_IN_ST_NO_POWER: u32 = 1;
pub const V4L2_IN_ST_NO_SIGNAL: u32 = 2;
pub const V4L2_IN_ST_NO_COLOR: u32 = 4;
pub const V4L2_IN_ST_HFLIP: u32 = 16;
pub const V4L2_IN_ST_VFLIP: u32 = 32;
pub const V4L2_IN_ST_NO_H_LOCK: u32 = 256;
pub const V4L2_IN_ST_COLOR_KILL: u32 = 512;
pub const V4L2_IN_ST_NO_V_LOCK: u32 = 1024;
pub const V4L2_IN_ST_NO_STD_LOCK: u32 = 2048;
pub const V4L2_IN_ST_NO_SYNC: u32 = 65536;
pub const V4L2_IN_ST_NO_EQU: u32 = 131072;
pub const V4L2_IN_ST_NO_CARRIER: u32 = 262144;
pub const V4L2_IN_ST_MACROVISION: u32 = 16777216;
pub const V4L2_IN_ST_NO_ACCESS: u32 = 33554432;
pub const V4L2_IN_ST_VTR: u32 = 67108864;
pub const V4L2_IN_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_STD: u32 = 4;
pub const V4L2_IN_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_OUTPUT_TYPE_MODULATOR: u32 = 1;
pub const V4L2_OUTPUT_TYPE_ANALOG: u32 = 2;
pub const V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY: u32 = 3;
pub const V4L2_OUT_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_STD: u32 = 4;
pub const V4L2_OUT_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_CTRL_ID_MASK: u32 = 268435455;
pub const V4L2_CTRL_MAX_DIMS: u32 = 4;
pub const V4L2_CTRL_WHICH_CUR_VAL: u32 = 0;
pub const V4L2_CTRL_WHICH_DEF_VAL: u32 = 251658240;
pub const V4L2_CTRL_WHICH_REQUEST_VAL: u32 = 251723776;
pub const V4L2_CTRL_FLAG_DISABLED: u32 = 1;
pub const V4L2_CTRL_FLAG_GRABBED: u32 = 2;
pub const V4L2_CTRL_FLAG_READ_ONLY: u32 = 4;
pub const V4L2_CTRL_FLAG_UPDATE: u32 = 8;
pub const V4L2_CTRL_FLAG_INACTIVE: u32 = 16;
pub const V4L2_CTRL_FLAG_SLIDER: u32 = 32;
pub const V4L2_CTRL_FLAG_WRITE_ONLY: u32 = 64;
pub const V4L2_CTRL_FLAG_VOLATILE: u32 = 128;
pub const V4L2_CTRL_FLAG_HAS_PAYLOAD: u32 = 256;
pub const V4L2_CTRL_FLAG_EXECUTE_ON_WRITE: u32 = 512;
pub const V4L2_CTRL_FLAG_MODIFY_LAYOUT: u32 = 1024;
pub const V4L2_CTRL_FLAG_NEXT_CTRL: u32 = 2147483648;
pub const V4L2_CTRL_FLAG_NEXT_COMPOUND: u32 = 1073741824;
pub const V4L2_CID_MAX_CTRLS: u32 = 1024;
pub const V4L2_CID_PRIVATE_BASE: u32 = 134217728;
pub const V4L2_TUNER_CAP_LOW: u32 = 1;
pub const V4L2_TUNER_CAP_NORM: u32 = 2;
pub const V4L2_TUNER_CAP_HWSEEK_BOUNDED: u32 = 4;
pub const V4L2_TUNER_CAP_HWSEEK_WRAP: u32 = 8;
pub const V4L2_TUNER_CAP_STEREO: u32 = 16;
pub const V4L2_TUNER_CAP_LANG2: u32 = 32;
pub const V4L2_TUNER_CAP_SAP: u32 = 32;
pub const V4L2_TUNER_CAP_LANG1: u32 = 64;
pub const V4L2_TUNER_CAP_RDS: u32 = 128;
pub const V4L2_TUNER_CAP_RDS_BLOCK_IO: u32 = 256;
pub const V4L2_TUNER_CAP_RDS_CONTROLS: u32 = 512;
pub const V4L2_TUNER_CAP_FREQ_BANDS: u32 = 1024;
pub const V4L2_TUNER_CAP_HWSEEK_PROG_LIM: u32 = 2048;
pub const V4L2_TUNER_CAP_1HZ: u32 = 4096;
pub const V4L2_TUNER_SUB_MONO: u32 = 1;
pub const V4L2_TUNER_SUB_STEREO: u32 = 2;
pub const V4L2_TUNER_SUB_LANG2: u32 = 4;
pub const V4L2_TUNER_SUB_SAP: u32 = 4;
pub const V4L2_TUNER_SUB_LANG1: u32 = 8;
pub const V4L2_TUNER_SUB_RDS: u32 = 16;
pub const V4L2_TUNER_MODE_MONO: u32 = 0;
pub const V4L2_TUNER_MODE_STEREO: u32 = 1;
pub const V4L2_TUNER_MODE_LANG2: u32 = 2;
pub const V4L2_TUNER_MODE_SAP: u32 = 2;
pub const V4L2_TUNER_MODE_LANG1: u32 = 3;
pub const V4L2_TUNER_MODE_LANG1_LANG2: u32 = 4;
pub const V4L2_BAND_MODULATION_VSB: u32 = 2;
pub const V4L2_BAND_MODULATION_FM: u32 = 4;
pub const V4L2_BAND_MODULATION_AM: u32 = 8;
pub const V4L2_RDS_BLOCK_MSK: u32 = 7;
pub const V4L2_RDS_BLOCK_A: u32 = 0;
pub const V4L2_RDS_BLOCK_B: u32 = 1;
pub const V4L2_RDS_BLOCK_C: u32 = 2;
pub const V4L2_RDS_BLOCK_D: u32 = 3;
pub const V4L2_RDS_BLOCK_C_ALT: u32 = 4;
pub const V4L2_RDS_BLOCK_INVALID: u32 = 7;
pub const V4L2_RDS_BLOCK_CORRECTED: u32 = 64;
pub const V4L2_RDS_BLOCK_ERROR: u32 = 128;
pub const V4L2_AUDCAP_STEREO: u32 = 1;
pub const V4L2_AUDCAP_AVL: u32 = 2;
pub const V4L2_AUDMODE_AVL: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_I: u32 = 0;
pub const V4L2_ENC_IDX_FRAME_P: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_B: u32 = 2;
pub const V4L2_ENC_IDX_FRAME_MASK: u32 = 15;
pub const V4L2_ENC_IDX_ENTRIES: u32 = 64;
pub const V4L2_ENC_CMD_START: u32 = 0;
pub const V4L2_ENC_CMD_STOP: u32 = 1;
pub const V4L2_ENC_CMD_PAUSE: u32 = 2;
pub const V4L2_ENC_CMD_RESUME: u32 = 3;
pub const V4L2_ENC_CMD_STOP_AT_GOP_END: u32 = 1;
pub const V4L2_DEC_CMD_START: u32 = 0;
pub const V4L2_DEC_CMD_STOP: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE: u32 = 2;
pub const V4L2_DEC_CMD_RESUME: u32 = 3;
pub const V4L2_DEC_CMD_START_MUTE_AUDIO: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_IMMEDIATELY: u32 = 2;
pub const V4L2_DEC_START_FMT_NONE: u32 = 0;
pub const V4L2_DEC_START_FMT_GOP: u32 = 1;
pub const V4L2_VBI_UNSYNC: u32 = 1;
pub const V4L2_VBI_INTERLACED: u32 = 2;
pub const V4L2_VBI_ITU_525_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_525_F2_START: u32 = 264;
pub const V4L2_VBI_ITU_625_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_625_F2_START: u32 = 314;
pub const V4L2_SLICED_TELETEXT_B: u32 = 1;
pub const V4L2_SLICED_VPS: u32 = 1024;
pub const V4L2_SLICED_CAPTION_525: u32 = 4096;
pub const V4L2_SLICED_WSS_625: u32 = 16384;
pub const V4L2_SLICED_VBI_525: u32 = 4096;
pub const V4L2_SLICED_VBI_625: u32 = 17409;
pub const V4L2_MPEG_VBI_IVTV_TELETEXT_B: u32 = 1;
pub const V4L2_MPEG_VBI_IVTV_CAPTION_525: u32 = 4;
pub const V4L2_MPEG_VBI_IVTV_WSS_625: u32 = 5;
pub const V4L2_MPEG_VBI_IVTV_VPS: u32 = 7;
pub const V4L2_MPEG_VBI_IVTV_MAGIC0: &[u8; 5] = b"itv0\0";
pub const V4L2_MPEG_VBI_IVTV_MAGIC1: &[u8; 5] = b"ITV0\0";
pub const V4L2_EVENT_ALL: u32 = 0;
pub const V4L2_EVENT_VSYNC: u32 = 1;
pub const V4L2_EVENT_EOS: u32 = 2;
pub const V4L2_EVENT_CTRL: u32 = 3;
pub const V4L2_EVENT_FRAME_SYNC: u32 = 4;
pub const V4L2_EVENT_SOURCE_CHANGE: u32 = 5;
pub const V4L2_EVENT_MOTION_DET: u32 = 6;
pub const V4L2_EVENT_PRIVATE_START: u32 = 134217728;
pub const V4L2_EVENT_CTRL_CH_VALUE: u32 = 1;
pub const V4L2_EVENT_CTRL_CH_FLAGS: u32 = 2;
pub const V4L2_EVENT_CTRL_CH_RANGE: u32 = 4;
pub const V4L2_EVENT_SRC_CH_RESOLUTION: u32 = 1;
pub const V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ: u32 = 1;
pub const V4L2_EVENT_SUB_FL_SEND_INITIAL: u32 = 1;
pub const V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK: u32 = 2;
pub const V4L2_CHIP_MATCH_BRIDGE: u32 = 0;
pub const V4L2_CHIP_MATCH_SUBDEV: u32 = 4;
pub const V4L2_CHIP_MATCH_HOST: u32 = 0;
pub const V4L2_CHIP_MATCH_I2C_DRIVER: u32 = 1;
pub const V4L2_CHIP_MATCH_I2C_ADDR: u32 = 2;
pub const V4L2_CHIP_MATCH_AC97: u32 = 3;
pub const V4L2_CHIP_FL_READABLE: u32 = 1;
pub const V4L2_CHIP_FL_WRITABLE: u32 = 2;
pub const BASE_VIDIOC_PRIVATE: u32 = 192;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const IMP_IVS_DEFAULT_TIMEOUTMS: i32 = -1;
pub const IMP_LOG_OUT_STDOUT: u32 = 0;
pub const IMP_LOG_OUT_LOCAL_FILE: u32 = 1;
pub const IMP_LOG_OUT_SERVER: u32 = 2;
pub const IMP_LOG_OUT_DEFAULT: u32 = 0;
pub const IMP_LOG_OP_PID_SHIFT: u32 = 0;
pub const IMP_LOG_OP_USTIME_SHIFT: u32 = 1;
pub const IMP_LOG_OP_MODULE_SHIFT: u32 = 2;
pub const IMP_LOG_OP_FILE_SHIFT: u32 = 3;
pub const IMP_LOG_OP_FUNC_SHIFT: u32 = 4;
pub const IMP_LOG_OP_LINE_SHIFT: u32 = 5;
pub const IMP_LOG_OP_PID: u32 = 1;
pub const IMP_LOG_OP_USTIME: u32 = 2;
pub const IMP_LOG_OP_MODULE: u32 = 4;
pub const IMP_LOG_OP_FILE: u32 = 8;
pub const IMP_LOG_OP_FUNC: u32 = 16;
pub const IMP_LOG_OP_LINE: u32 = 32;
pub const IMP_LOG_OP_NONE: u32 = 0;
pub const IMP_LOG_OP_ALL: u32 = 63;
pub const IMP_LOG_OP_DEFAULT: u32 = 63;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _SEMAPHORE_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 16;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 0;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 0;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 0;
pub const __FP_LOGBNAN_IS_MIN: u32 = 0;
pub const FP_ILOGB0: i32 = -2147483647;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: u32 = 1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: u32 = 1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 43] = b"-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_LINUX_OLD: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 1;
pub const _STAT_VER_SVR4: u32 = 2;
pub const _STAT_VER_LINUX: u32 = 3;
pub const _STAT_VER: u32 = 3;
pub const _MKNOD_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_SVR4: u32 = 2;
pub const _MKNOD_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _FCNTL_H: u32 = 1;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 16400;
pub const O_NONBLOCK: u32 = 128;
pub const O_CREAT: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_EXCL: u32 = 1024;
pub const O_NOCTTY: u32 = 2048;
pub const O_ASYNC: u32 = 4096;
pub const __O_DIRECT: u32 = 32768;
pub const __O_DSYNC: u32 = 16;
pub const __O_LARGEFILE: u32 = 8192;
pub const F_GETLK: u32 = 14;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_GETLK64: u32 = 33;
pub const F_SETLK64: u32 = 34;
pub const F_SETLKW64: u32 = 35;
pub const __F_SETOWN: u32 = 24;
pub const __F_GETOWN: u32 = 23;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_NDELAY: u32 = 128;
pub const O_FSYNC: u32 = 16400;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4259840;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 16;
pub const O_RSYNC: u32 = 16400;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_SETOWN: u32 = 24;
pub const F_GETOWN: u32 = 23;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 8;
pub const FFSYNC: u32 = 16400;
pub const FASYNC: u32 = 4096;
pub const FNONBLOCK: u32 = 128;
pub const FNDELAY: u32 = 128;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const MAXSUPCHNMUN: u32 = 2;
pub const MAXISPOSDPIC: u32 = 8;
pub const INVHANDLE: i32 = -1;
pub const MAX_AUDIO_FRAME_NUM: u32 = 50;
pub const REINIT: i32 = -10;
pub const INIT_FAILED: i32 = -11;
pub const FAILED_GETHANDLE: i32 = -12;
pub const INVALID_PARA: i32 = -13;
pub const SET_PARA_FAILED: i32 = -14;
pub const FAILURE: i32 = -15;
pub const SET_DATALEN_ERR: i32 = -16;
pub const EXIT_ERR: i32 = -17;
pub const UNINIT: i32 = -18;
pub const FAILED_DESHANDLE: i32 = -19;
pub const DEVICE_ID_MAGIC: &[u8; 5] = b"53ef\0";
pub const DEVICE_ID_MAGIC_LEN: u32 = 4;
pub const DEVICE_ID_LEN: u32 = 32;
pub const MAX_INFO_LEN: u32 = 64;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_longlong;
pub type __u_quad_t = libc::c_ulonglong;
pub type __intmax_t = libc::c_longlong;
pub type __uintmax_t = libc::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = libc::c_int;
pub type __ssize_t = libc::c_int;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_int;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type __time64_t = __int64_t;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_int;
pub type int_fast32_t = libc::c_int;
pub type int_fast64_t = libc::c_longlong;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_uint;
pub type uint_fast32_t = libc::c_uint;
pub type uint_fast64_t = libc::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitmapinfo {
    pub width: u32,
    pub pdata: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bitmapinfo"][::core::mem::size_of::<bitmapinfo>() - 8usize];
    ["Alignment of bitmapinfo"][::core::mem::align_of::<bitmapinfo>() - 4usize];
    ["Offset of field: bitmapinfo::width"][::core::mem::offset_of!(bitmapinfo, width) - 0usize];
    ["Offset of field: bitmapinfo::pdata"][::core::mem::offset_of!(bitmapinfo, pdata) - 4usize];
};
impl Default for bitmapinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bitmapinfo_t = bitmapinfo;
pub const gBgramapHight: libc::c_int = 34;
pub const gBgramapWidthMax: libc::c_int = 32;
extern "C" {
    pub static mut num0_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num1_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num2_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num3_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num4_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num5_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num6_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num7_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num8_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut num9_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut minus_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut blank_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut colon_bgra: [u32; 544usize];
}
extern "C" {
    pub static mut gBgramap: [bitmapinfo_t; 13usize];
}
pub const gBgramapHight_sec: libc::c_int = 18;
pub const gBgramapWidthMax_sec: libc::c_int = 16;
extern "C" {
    pub static mut num0_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num1_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num2_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num3_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num4_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num5_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num6_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num7_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num8_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut num9_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut minus_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut blank_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut colon_sec_bgra: [u32; 144usize];
}
extern "C" {
    pub static mut gBgramap_sec: [bitmapinfo_t; 13usize];
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 8usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 4usize];
    ["Offset of field: timespec::tv_sec"][::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::core::mem::offset_of!(timespec, tv_nsec) - 4usize];
};
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::core::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::core::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::core::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
pub type __cpu_mask = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::core::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::core::mem::align_of::<cpu_set_t>() - 4usize];
    ["Offset of field: cpu_set_t::__bits"][::core::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> libc::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn sched_yield() -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> libc::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::core::mem::size_of::<tm>() - 44usize];
    ["Alignment of tm"][::core::mem::align_of::<tm>() - 4usize];
    ["Offset of field: tm::tm_sec"][::core::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::core::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::core::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::core::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::core::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::core::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::core::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::core::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::core::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::core::mem::offset_of!(tm, tm_gmtoff) - 36usize];
    ["Offset of field: tm::tm_zone"][::core::mem::offset_of!(tm, tm_zone) - 40usize];
};
impl Default for tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::core::mem::size_of::<itimerspec>() - 16usize];
    ["Alignment of itimerspec"][::core::mem::align_of::<itimerspec>() - 4usize];
    ["Offset of field: itimerspec::it_interval"]
        [::core::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::core::mem::offset_of!(itimerspec, it_value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::core::mem::size_of::<__locale_struct>() - 116usize];
    ["Alignment of __locale_struct"][::core::mem::align_of::<__locale_struct>() - 4usize];
    ["Offset of field: __locale_struct::__locales"]
        [::core::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::core::mem::offset_of!(__locale_struct, __ctype_b) - 52usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::core::mem::offset_of!(__locale_struct, __ctype_tolower) - 56usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::core::mem::offset_of!(__locale_struct, __ctype_toupper) - 60usize];
    ["Offset of field: __locale_struct::__names"]
        [::core::mem::offset_of!(__locale_struct, __names) - 64usize];
};
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut libc::c_char,
        __maxsize: usize,
        __format: *const libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> libc::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __flags: libc::c_uchar,
    pub __shared: libc::c_uchar,
    pub __pad1: libc::c_uchar,
    pub __pad2: libc::c_uchar,
    pub __cur_writer: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"]
        [::core::mem::size_of::<__pthread_rwlock_arch_t>() - 32usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::core::mem::align_of::<__pthread_rwlock_arch_t>() - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 25usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 26usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 27usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::core::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::core::mem::size_of::<__pthread_internal_slist>() - 4usize];
    ["Alignment of __pthread_internal_slist"]
        [::core::mem::align_of::<__pthread_internal_slist>() - 4usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::core::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __kind: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __anon1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __spins: libc::c_int,
    pub __list: __pthread_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_mutex_s__bindgen_ty_1>() - 4usize];
    ["Alignment of __pthread_mutex_s__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_mutex_s__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_mutex_s__bindgen_ty_1::__spins"]
        [::core::mem::offset_of!(__pthread_mutex_s__bindgen_ty_1, __spins) - 0usize];
    ["Offset of field: __pthread_mutex_s__bindgen_ty_1::__list"]
        [::core::mem::offset_of!(__pthread_mutex_s__bindgen_ty_1, __list) - 0usize];
};
impl Default for __pthread_mutex_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::core::mem::size_of::<__pthread_mutex_s>() - 24usize];
    ["Alignment of __pthread_mutex_s"][::core::mem::align_of::<__pthread_mutex_s>() - 4usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::core::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::core::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::core::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::core::mem::offset_of!(__pthread_mutex_s, __kind) - 12usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::core::mem::offset_of!(__pthread_mutex_s, __nusers) - 16usize];
};
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __anon1: __pthread_cond_s__bindgen_ty_1,
    pub __anon2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__low"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1::__high"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_1::__wseq32"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_1, __wseq32) - 0usize];
};
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__low"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1::__high"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s__bindgen_ty_2"]
        [::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Alignment of __pthread_cond_s__bindgen_ty_2"]
        [::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() - 8usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start) - 0usize];
    ["Offset of field: __pthread_cond_s__bindgen_ty_2::__g1_start32"]
        [::core::mem::offset_of!(__pthread_cond_s__bindgen_ty_2, __g1_start32) - 0usize];
};
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::core::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::core::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::core::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::core::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::core::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::core::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::core::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::core::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::core::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::core::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::core::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::core::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::core::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 36usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::core::mem::size_of::<pthread_attr_t>() - 36usize];
    ["Alignment of pthread_attr_t"][::core::mem::align_of::<pthread_attr_t>() - 4usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::core::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::core::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 24usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::core::mem::size_of::<pthread_mutex_t>() - 24usize];
    ["Alignment of pthread_mutex_t"][::core::mem::align_of::<pthread_mutex_t>() - 4usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::core::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::core::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::core::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::core::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::core::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::core::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::core::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::core::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::core::mem::size_of::<pthread_rwlock_t>() - 32usize];
    ["Alignment of pthread_rwlock_t"][::core::mem::align_of::<pthread_rwlock_t>() - 4usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::core::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::core::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::core::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::core::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::core::mem::align_of::<pthread_rwlockattr_t>() - 4usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::core::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::core::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 20usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::core::mem::size_of::<pthread_barrier_t>() - 20usize];
    ["Alignment of pthread_barrier_t"][::core::mem::align_of::<pthread_barrier_t>() - 4usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::core::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::core::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::core::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::core::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::core::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::core::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_internal_tag {
    pub __pc: *mut libc::c_void,
    pub __sp: *mut libc::c_void,
    pub __regs: [libc::c_int; 8usize],
    pub __fp: *mut libc::c_void,
    pub __gp: *mut libc::c_void,
    pub __glibc_reserved1: libc::c_int,
    pub __fpregs: [f64; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_internal_tag"][::core::mem::size_of::<__jmp_buf_internal_tag>() - 104usize];
    ["Alignment of __jmp_buf_internal_tag"]
        [::core::mem::align_of::<__jmp_buf_internal_tag>() - 8usize];
    ["Offset of field: __jmp_buf_internal_tag::__pc"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __pc) - 0usize];
    ["Offset of field: __jmp_buf_internal_tag::__sp"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __sp) - 4usize];
    ["Offset of field: __jmp_buf_internal_tag::__regs"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __regs) - 8usize];
    ["Offset of field: __jmp_buf_internal_tag::__fp"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __fp) - 40usize];
    ["Offset of field: __jmp_buf_internal_tag::__gp"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __gp) - 44usize];
    ["Offset of field: __jmp_buf_internal_tag::__glibc_reserved1"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __glibc_reserved1) - 48usize];
    ["Offset of field: __jmp_buf_internal_tag::__fpregs"]
        [::core::mem::offset_of!(__jmp_buf_internal_tag, __fpregs) - 56usize];
};
impl Default for __jmp_buf_internal_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __jmp_buf = [__jmp_buf_internal_tag; 1usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = _bindgen_ty_1::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = _bindgen_ty_1::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = _bindgen_ty_6::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = _bindgen_ty_6::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = _bindgen_ty_7::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = _bindgen_ty_7::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = _bindgen_ty_8::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = _bindgen_ty_8::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __canceltype: libc::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"]
        [::core::mem::size_of::<_pthread_cleanup_buffer>() - 16usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::core::mem::align_of::<_pthread_cleanup_buffer>() - 4usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 4usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::core::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 12usize];
};
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = _bindgen_ty_9::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = _bindgen_ty_9::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_9 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = _bindgen_ty_10::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = _bindgen_ty_10::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_10 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void) -> *mut libc::c_void,
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut libc::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t, __scope: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut libc::c_void,
        __stacksize: *mut usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut libc::c_void,
        __stacksize: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: libc::c_int,
        __param: *const sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut libc::c_int,
        __param: *mut sched_param,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: libc::c_int,
        __oldstate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: libc::c_int, __oldtype: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut libc::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t__bindgen_ty_1"]
        [::core::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() - 112usize];
    ["Alignment of __pthread_unwind_buf_t__bindgen_ty_1"]
        [::core::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t__bindgen_ty_1::__cancel_jmp_buf"]
        [::core::mem::offset_of!(__pthread_unwind_buf_t__bindgen_ty_1, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t__bindgen_ty_1::__mask_was_saved"][::core::mem::offset_of!(
        __pthread_unwind_buf_t__bindgen_ty_1,
        __mask_was_saved
    ) - 104usize];
};
impl Default for __pthread_unwind_buf_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::core::mem::size_of::<__pthread_unwind_buf_t>() - 128usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::core::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::core::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::core::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 112usize];
};
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __cancel_arg: *mut libc::c_void,
    pub __do_it: libc::c_int,
    pub __cancel_type: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"]
        [::core::mem::size_of::<__pthread_cleanup_frame>() - 16usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::core::mem::align_of::<__pthread_cleanup_frame>() - 4usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 4usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::core::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 12usize];
};
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: libc::c_int,
        __old_ceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t, __pointer: *const libc::c_void)
        -> libc::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::core::mem::size_of::<timeval>() - 8usize];
    ["Alignment of timeval"][::core::mem::align_of::<timeval>() - 4usize];
    ["Offset of field: timeval::tv_sec"][::core::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::core::mem::offset_of!(timeval, tv_usec) - 4usize];
};
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::core::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::core::mem::align_of::<__sigset_t>() - 4usize];
    ["Offset of field: __sigset_t::__val"][::core::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::core::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::core::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::__fds_bits"][::core::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timezone"][::core::mem::size_of::<timezone>() - 8usize];
    ["Alignment of timezone"][::core::mem::align_of::<timezone>() - 4usize];
    ["Offset of field: timezone::tz_minuteswest"]
        [::core::mem::offset_of!(timezone, tz_minuteswest) - 0usize];
    ["Offset of field: timezone::tz_dsttime"]
        [::core::mem::offset_of!(timezone, tz_dsttime) - 4usize];
};
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerval"][::core::mem::size_of::<itimerval>() - 16usize];
    ["Alignment of itimerval"][::core::mem::align_of::<itimerval>() - 4usize];
    ["Offset of field: itimerval::it_interval"]
        [::core::mem::offset_of!(itimerval, it_interval) - 0usize];
    ["Offset of field: itimerval::it_value"][::core::mem::offset_of!(itimerval, it_value) - 8usize];
};
pub type __itimer_which_t = libc::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: libc::c_int, __tvp: *const timeval) -> libc::c_int;
}
pub type __s8 = libc::c_schar;
pub type __u8 = libc::c_uchar;
pub type __s16 = libc::c_short;
pub type __u16 = libc::c_ushort;
pub type __s32 = libc::c_int;
pub type __u32 = libc::c_uint;
pub type __s64 = libc::c_longlong;
pub type __u64 = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [libc::c_ulong; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::core::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::core::mem::align_of::<__kernel_fd_set>() - 4usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::core::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
pub type __kernel_key_t = libc::c_int;
pub type __kernel_mqd_t = libc::c_int;
pub type __kernel_daddr_t = libc::c_long;
pub type __kernel_long_t = libc::c_long;
pub type __kernel_ulong_t = libc::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = libc::c_uint;
pub type __kernel_pid_t = libc::c_int;
pub type __kernel_ipc_pid_t = libc::c_int;
pub type __kernel_uid_t = libc::c_uint;
pub type __kernel_gid_t = libc::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_uid32_t = libc::c_uint;
pub type __kernel_gid32_t = libc::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_old_dev_t = libc::c_uint;
pub type __kernel_size_t = libc::c_uint;
pub type __kernel_ssize_t = libc::c_int;
pub type __kernel_ptrdiff_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::core::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::core::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::core::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = libc::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = libc::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = libc::c_int;
pub type __kernel_clockid_t = libc::c_int;
pub type __kernel_caddr_t = *mut libc::c_char;
pub type __kernel_uid16_t = libc::c_ushort;
pub type __kernel_gid16_t = libc::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_edid {
    pub pad: __u32,
    pub start_block: __u32,
    pub blocks: __u32,
    pub reserved: [__u32; 5usize],
    pub edid: *mut __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_edid"][::core::mem::size_of::<v4l2_edid>() - 36usize];
    ["Alignment of v4l2_edid"][::core::mem::align_of::<v4l2_edid>() - 4usize];
    ["Offset of field: v4l2_edid::pad"][::core::mem::offset_of!(v4l2_edid, pad) - 0usize];
    ["Offset of field: v4l2_edid::start_block"]
        [::core::mem::offset_of!(v4l2_edid, start_block) - 4usize];
    ["Offset of field: v4l2_edid::blocks"][::core::mem::offset_of!(v4l2_edid, blocks) - 8usize];
    ["Offset of field: v4l2_edid::reserved"]
        [::core::mem::offset_of!(v4l2_edid, reserved) - 12usize];
    ["Offset of field: v4l2_edid::edid"][::core::mem::offset_of!(v4l2_edid, edid) - 32usize];
};
impl Default for v4l2_edid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_power_line_frequency {
    V4L2_CID_POWER_LINE_FREQUENCY_DISABLED = 0,
    V4L2_CID_POWER_LINE_FREQUENCY_50HZ = 1,
    V4L2_CID_POWER_LINE_FREQUENCY_60HZ = 2,
    V4L2_CID_POWER_LINE_FREQUENCY_AUTO = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_colorfx {
    V4L2_COLORFX_NONE = 0,
    V4L2_COLORFX_BW = 1,
    V4L2_COLORFX_SEPIA = 2,
    V4L2_COLORFX_NEGATIVE = 3,
    V4L2_COLORFX_EMBOSS = 4,
    V4L2_COLORFX_SKETCH = 5,
    V4L2_COLORFX_SKY_BLUE = 6,
    V4L2_COLORFX_GRASS_GREEN = 7,
    V4L2_COLORFX_SKIN_WHITEN = 8,
    V4L2_COLORFX_VIVID = 9,
    V4L2_COLORFX_AQUA = 10,
    V4L2_COLORFX_ART_FREEZE = 11,
    V4L2_COLORFX_SILHOUETTE = 12,
    V4L2_COLORFX_SOLARIZATION = 13,
    V4L2_COLORFX_ANTIQUE = 14,
    V4L2_COLORFX_SET_CBCR = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_stream_type {
    V4L2_MPEG_STREAM_TYPE_MPEG2_PS = 0,
    V4L2_MPEG_STREAM_TYPE_MPEG2_TS = 1,
    V4L2_MPEG_STREAM_TYPE_MPEG1_SS = 2,
    V4L2_MPEG_STREAM_TYPE_MPEG2_DVD = 3,
    V4L2_MPEG_STREAM_TYPE_MPEG1_VCD = 4,
    V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_stream_vbi_fmt {
    V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,
    V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_sampling_freq {
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
    V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_encoding {
    V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
    V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
    V4L2_MPEG_AUDIO_ENCODING_AAC = 3,
    V4L2_MPEG_AUDIO_ENCODING_AC3 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_l1_bitrate {
    V4L2_MPEG_AUDIO_L1_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L1_BITRATE_64K = 1,
    V4L2_MPEG_AUDIO_L1_BITRATE_96K = 2,
    V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
    V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
    V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
    V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
    V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
    V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
    V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
    V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
    V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
    V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
    V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_l2_bitrate {
    V4L2_MPEG_AUDIO_L2_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L2_BITRATE_48K = 1,
    V4L2_MPEG_AUDIO_L2_BITRATE_56K = 2,
    V4L2_MPEG_AUDIO_L2_BITRATE_64K = 3,
    V4L2_MPEG_AUDIO_L2_BITRATE_80K = 4,
    V4L2_MPEG_AUDIO_L2_BITRATE_96K = 5,
    V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
    V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
    V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
    V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
    V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
    V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
    V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
    V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_l3_bitrate {
    V4L2_MPEG_AUDIO_L3_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_L3_BITRATE_40K = 1,
    V4L2_MPEG_AUDIO_L3_BITRATE_48K = 2,
    V4L2_MPEG_AUDIO_L3_BITRATE_56K = 3,
    V4L2_MPEG_AUDIO_L3_BITRATE_64K = 4,
    V4L2_MPEG_AUDIO_L3_BITRATE_80K = 5,
    V4L2_MPEG_AUDIO_L3_BITRATE_96K = 6,
    V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
    V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
    V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
    V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
    V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
    V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
    V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_mode {
    V4L2_MPEG_AUDIO_MODE_STEREO = 0,
    V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
    V4L2_MPEG_AUDIO_MODE_DUAL = 2,
    V4L2_MPEG_AUDIO_MODE_MONO = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_mode_extension {
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4 = 0,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8 = 1,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
    V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_emphasis {
    V4L2_MPEG_AUDIO_EMPHASIS_NONE = 0,
    V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
    V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_crc {
    V4L2_MPEG_AUDIO_CRC_NONE = 0,
    V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_ac3_bitrate {
    V4L2_MPEG_AUDIO_AC3_BITRATE_32K = 0,
    V4L2_MPEG_AUDIO_AC3_BITRATE_40K = 1,
    V4L2_MPEG_AUDIO_AC3_BITRATE_48K = 2,
    V4L2_MPEG_AUDIO_AC3_BITRATE_56K = 3,
    V4L2_MPEG_AUDIO_AC3_BITRATE_64K = 4,
    V4L2_MPEG_AUDIO_AC3_BITRATE_80K = 5,
    V4L2_MPEG_AUDIO_AC3_BITRATE_96K = 6,
    V4L2_MPEG_AUDIO_AC3_BITRATE_112K = 7,
    V4L2_MPEG_AUDIO_AC3_BITRATE_128K = 8,
    V4L2_MPEG_AUDIO_AC3_BITRATE_160K = 9,
    V4L2_MPEG_AUDIO_AC3_BITRATE_192K = 10,
    V4L2_MPEG_AUDIO_AC3_BITRATE_224K = 11,
    V4L2_MPEG_AUDIO_AC3_BITRATE_256K = 12,
    V4L2_MPEG_AUDIO_AC3_BITRATE_320K = 13,
    V4L2_MPEG_AUDIO_AC3_BITRATE_384K = 14,
    V4L2_MPEG_AUDIO_AC3_BITRATE_448K = 15,
    V4L2_MPEG_AUDIO_AC3_BITRATE_512K = 16,
    V4L2_MPEG_AUDIO_AC3_BITRATE_576K = 17,
    V4L2_MPEG_AUDIO_AC3_BITRATE_640K = 18,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_audio_dec_playback {
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO = 0,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO = 1,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT = 2,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT = 3,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO = 4,
    V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_encoding {
    V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1,
    V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_aspect {
    V4L2_MPEG_VIDEO_ASPECT_1x1 = 0,
    V4L2_MPEG_VIDEO_ASPECT_4x3 = 1,
    V4L2_MPEG_VIDEO_ASPECT_16x9 = 2,
    V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_bitrate_mode {
    V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
    V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_header_mode {
    V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE = 0,
    V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME = 1,
}
impl v4l2_mpeg_video_multi_slice_mode {
    pub const V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB: v4l2_mpeg_video_multi_slice_mode =
        v4l2_mpeg_video_multi_slice_mode::V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB;
}
impl v4l2_mpeg_video_multi_slice_mode {
    pub const V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES: v4l2_mpeg_video_multi_slice_mode =
        v4l2_mpeg_video_multi_slice_mode::V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_multi_slice_mode {
    V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE = 0,
    V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB = 1,
    V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg2_level {
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_LOW = 0,
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_MAIN = 1,
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH_1440 = 2,
    V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg2_profile {
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_SIMPLE = 0,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_MAIN = 1,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_SNR_SCALABLE = 2,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_SPATIALLY_SCALABLE = 3,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH = 4,
    V4L2_MPEG_VIDEO_MPEG2_PROFILE_MULTIVIEW = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_entropy_mode {
    V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC = 0,
    V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_level {
    V4L2_MPEG_VIDEO_H264_LEVEL_1_0 = 0,
    V4L2_MPEG_VIDEO_H264_LEVEL_1B = 1,
    V4L2_MPEG_VIDEO_H264_LEVEL_1_1 = 2,
    V4L2_MPEG_VIDEO_H264_LEVEL_1_2 = 3,
    V4L2_MPEG_VIDEO_H264_LEVEL_1_3 = 4,
    V4L2_MPEG_VIDEO_H264_LEVEL_2_0 = 5,
    V4L2_MPEG_VIDEO_H264_LEVEL_2_1 = 6,
    V4L2_MPEG_VIDEO_H264_LEVEL_2_2 = 7,
    V4L2_MPEG_VIDEO_H264_LEVEL_3_0 = 8,
    V4L2_MPEG_VIDEO_H264_LEVEL_3_1 = 9,
    V4L2_MPEG_VIDEO_H264_LEVEL_3_2 = 10,
    V4L2_MPEG_VIDEO_H264_LEVEL_4_0 = 11,
    V4L2_MPEG_VIDEO_H264_LEVEL_4_1 = 12,
    V4L2_MPEG_VIDEO_H264_LEVEL_4_2 = 13,
    V4L2_MPEG_VIDEO_H264_LEVEL_5_0 = 14,
    V4L2_MPEG_VIDEO_H264_LEVEL_5_1 = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_loop_filter_mode {
    V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED = 0,
    V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED = 1,
    V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_profile {
    V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE = 0,
    V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE = 1,
    V4L2_MPEG_VIDEO_H264_PROFILE_MAIN = 2,
    V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED = 3,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH = 4,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10 = 5,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422 = 6,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE = 7,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA = 8,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA = 9,
    V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA = 10,
    V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA = 11,
    V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE = 12,
    V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH = 13,
    V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA = 14,
    V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH = 15,
    V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_vui_sar_idc {
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED = 0,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1 = 1,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11 = 2,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11 = 3,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11 = 4,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33 = 5,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11 = 6,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11 = 7,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11 = 8,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33 = 9,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11 = 10,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11 = 11,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33 = 12,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99 = 13,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3 = 14,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2 = 15,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1 = 16,
    V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED = 17,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_sei_fp_arrangement_type {
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHECKERBOARD = 0,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN = 1,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW = 2,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE = 3,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM = 4,
    V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_fmo_map_type {
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES = 0,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES = 1,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER = 2,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT = 3,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN = 4,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN = 5,
    V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_fmo_change_dir {
    V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT = 0,
    V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_h264_hierarchical_coding_type {
    V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B = 0,
    V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg4_level {
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_0 = 0,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B = 1,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_1 = 2,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_2 = 3,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_3 = 4,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_3B = 5,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_4 = 6,
    V4L2_MPEG_VIDEO_MPEG4_LEVEL_5 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_mpeg4_profile {
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE = 0,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE = 1,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_CORE = 2,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE = 3,
    V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_vp8_num_partitions {
    V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION = 0,
    V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS = 1,
    V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS = 2,
    V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_vp8_num_ref_frames {
    V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME = 0,
    V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME = 1,
    V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_vp8_golden_frame_sel {
    V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV = 0,
    V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_vp8_profile {
    V4L2_MPEG_VIDEO_VP8_PROFILE_0 = 0,
    V4L2_MPEG_VIDEO_VP8_PROFILE_1 = 1,
    V4L2_MPEG_VIDEO_VP8_PROFILE_2 = 2,
    V4L2_MPEG_VIDEO_VP8_PROFILE_3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_vp9_profile {
    V4L2_MPEG_VIDEO_VP9_PROFILE_0 = 0,
    V4L2_MPEG_VIDEO_VP9_PROFILE_1 = 1,
    V4L2_MPEG_VIDEO_VP9_PROFILE_2 = 2,
    V4L2_MPEG_VIDEO_VP9_PROFILE_3 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_hier_coding_type {
    V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B = 0,
    V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_P = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_profile {
    V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN = 0,
    V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE = 1,
    V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_level {
    V4L2_MPEG_VIDEO_HEVC_LEVEL_1 = 0,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_2 = 1,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1 = 2,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_3 = 3,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1 = 4,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_4 = 5,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1 = 6,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_5 = 7,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1 = 8,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2 = 9,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_6 = 10,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1 = 11,
    V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2 = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_video_hevc_tier {
    V4L2_MPEG_VIDEO_HEVC_TIER_MAIN = 0,
    V4L2_MPEG_VIDEO_HEVC_TIER_HIGH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_cid_mpeg_video_hevc_loop_filter_mode {
    V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED = 0,
    V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED = 1,
    V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_cid_mpeg_video_hevc_refresh_type {
    V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE = 0,
    V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA = 1,
    V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_cid_mpeg_video_hevc_size_of_length_field {
    V4L2_MPEG_VIDEO_HEVC_SIZE_0 = 0,
    V4L2_MPEG_VIDEO_HEVC_SIZE_1 = 1,
    V4L2_MPEG_VIDEO_HEVC_SIZE_2 = 2,
    V4L2_MPEG_VIDEO_HEVC_SIZE_4 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_spatial_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE = 3,
    V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_temporal_filter_mode {
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
    V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_cx2341x_video_median_filter_type {
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF = 0,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR = 1,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT = 2,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
    V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_mfc51_video_frame_skip_mode {
    V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED = 0,
    V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT = 1,
    V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_mpeg_mfc51_video_force_frame_type {
    V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED = 0,
    V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME = 1,
    V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_exposure_auto_type {
    V4L2_EXPOSURE_AUTO = 0,
    V4L2_EXPOSURE_MANUAL = 1,
    V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
    V4L2_EXPOSURE_APERTURE_PRIORITY = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_auto_n_preset_white_balance {
    V4L2_WHITE_BALANCE_MANUAL = 0,
    V4L2_WHITE_BALANCE_AUTO = 1,
    V4L2_WHITE_BALANCE_INCANDESCENT = 2,
    V4L2_WHITE_BALANCE_FLUORESCENT = 3,
    V4L2_WHITE_BALANCE_FLUORESCENT_H = 4,
    V4L2_WHITE_BALANCE_HORIZON = 5,
    V4L2_WHITE_BALANCE_DAYLIGHT = 6,
    V4L2_WHITE_BALANCE_FLASH = 7,
    V4L2_WHITE_BALANCE_CLOUDY = 8,
    V4L2_WHITE_BALANCE_SHADE = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_iso_sensitivity_auto_type {
    V4L2_ISO_SENSITIVITY_MANUAL = 0,
    V4L2_ISO_SENSITIVITY_AUTO = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_exposure_metering {
    V4L2_EXPOSURE_METERING_AVERAGE = 0,
    V4L2_EXPOSURE_METERING_CENTER_WEIGHTED = 1,
    V4L2_EXPOSURE_METERING_SPOT = 2,
    V4L2_EXPOSURE_METERING_MATRIX = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_scene_mode {
    V4L2_SCENE_MODE_NONE = 0,
    V4L2_SCENE_MODE_BACKLIGHT = 1,
    V4L2_SCENE_MODE_BEACH_SNOW = 2,
    V4L2_SCENE_MODE_CANDLE_LIGHT = 3,
    V4L2_SCENE_MODE_DAWN_DUSK = 4,
    V4L2_SCENE_MODE_FALL_COLORS = 5,
    V4L2_SCENE_MODE_FIREWORKS = 6,
    V4L2_SCENE_MODE_LANDSCAPE = 7,
    V4L2_SCENE_MODE_NIGHT = 8,
    V4L2_SCENE_MODE_PARTY_INDOOR = 9,
    V4L2_SCENE_MODE_PORTRAIT = 10,
    V4L2_SCENE_MODE_SPORTS = 11,
    V4L2_SCENE_MODE_SUNSET = 12,
    V4L2_SCENE_MODE_TEXT = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_auto_focus_range {
    V4L2_AUTO_FOCUS_RANGE_AUTO = 0,
    V4L2_AUTO_FOCUS_RANGE_NORMAL = 1,
    V4L2_AUTO_FOCUS_RANGE_MACRO = 2,
    V4L2_AUTO_FOCUS_RANGE_INFINITY = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_preemphasis {
    V4L2_PREEMPHASIS_DISABLED = 0,
    V4L2_PREEMPHASIS_50_uS = 1,
    V4L2_PREEMPHASIS_75_uS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_flash_led_mode {
    V4L2_FLASH_LED_MODE_NONE = 0,
    V4L2_FLASH_LED_MODE_FLASH = 1,
    V4L2_FLASH_LED_MODE_TORCH = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_flash_strobe_source {
    V4L2_FLASH_STROBE_SOURCE_SOFTWARE = 0,
    V4L2_FLASH_STROBE_SOURCE_EXTERNAL = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_jpeg_chroma_subsampling {
    V4L2_JPEG_CHROMA_SUBSAMPLING_444 = 0,
    V4L2_JPEG_CHROMA_SUBSAMPLING_422 = 1,
    V4L2_JPEG_CHROMA_SUBSAMPLING_420 = 2,
    V4L2_JPEG_CHROMA_SUBSAMPLING_411 = 3,
    V4L2_JPEG_CHROMA_SUBSAMPLING_410 = 4,
    V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_dv_tx_mode {
    V4L2_DV_TX_MODE_DVI_D = 0,
    V4L2_DV_TX_MODE_HDMI = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_dv_rgb_range {
    V4L2_DV_RGB_RANGE_AUTO = 0,
    V4L2_DV_RGB_RANGE_LIMITED = 1,
    V4L2_DV_RGB_RANGE_FULL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_dv_it_content_type {
    V4L2_DV_IT_CONTENT_TYPE_GRAPHICS = 0,
    V4L2_DV_IT_CONTENT_TYPE_PHOTO = 1,
    V4L2_DV_IT_CONTENT_TYPE_CINEMA = 2,
    V4L2_DV_IT_CONTENT_TYPE_GAME = 3,
    V4L2_DV_IT_CONTENT_TYPE_NO_ITC = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_deemphasis {
    V4L2_DEEMPHASIS_DISABLED = 0,
    V4L2_DEEMPHASIS_50_uS = 1,
    V4L2_DEEMPHASIS_75_uS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_detect_md_mode {
    V4L2_DETECT_MD_MODE_DISABLED = 0,
    V4L2_DETECT_MD_MODE_GLOBAL = 1,
    V4L2_DETECT_MD_MODE_THRESHOLD_GRID = 2,
    V4L2_DETECT_MD_MODE_REGION_GRID = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_field {
    V4L2_FIELD_ANY = 0,
    V4L2_FIELD_NONE = 1,
    V4L2_FIELD_TOP = 2,
    V4L2_FIELD_BOTTOM = 3,
    V4L2_FIELD_INTERLACED = 4,
    V4L2_FIELD_SEQ_TB = 5,
    V4L2_FIELD_SEQ_BT = 6,
    V4L2_FIELD_ALTERNATE = 7,
    V4L2_FIELD_INTERLACED_TB = 8,
    V4L2_FIELD_INTERLACED_BT = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_SDR_OUTPUT = 12,
    V4L2_BUF_TYPE_META_CAPTURE = 13,
    V4L2_BUF_TYPE_META_OUTPUT = 14,
    V4L2_BUF_TYPE_PRIVATE = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_tuner_type {
    V4L2_TUNER_RADIO = 1,
    V4L2_TUNER_ANALOG_TV = 2,
    V4L2_TUNER_DIGITAL_TV = 3,
    V4L2_TUNER_SDR = 4,
    V4L2_TUNER_RF = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3,
    V4L2_MEMORY_DMABUF = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_colorspace {
    V4L2_COLORSPACE_DEFAULT = 0,
    V4L2_COLORSPACE_SMPTE170M = 1,
    V4L2_COLORSPACE_SMPTE240M = 2,
    V4L2_COLORSPACE_REC709 = 3,
    V4L2_COLORSPACE_BT878 = 4,
    V4L2_COLORSPACE_470_SYSTEM_M = 5,
    V4L2_COLORSPACE_470_SYSTEM_BG = 6,
    V4L2_COLORSPACE_JPEG = 7,
    V4L2_COLORSPACE_SRGB = 8,
    V4L2_COLORSPACE_OPRGB = 9,
    V4L2_COLORSPACE_BT2020 = 10,
    V4L2_COLORSPACE_RAW = 11,
    V4L2_COLORSPACE_DCI_P3 = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_xfer_func {
    V4L2_XFER_FUNC_DEFAULT = 0,
    V4L2_XFER_FUNC_709 = 1,
    V4L2_XFER_FUNC_SRGB = 2,
    V4L2_XFER_FUNC_OPRGB = 3,
    V4L2_XFER_FUNC_SMPTE240M = 4,
    V4L2_XFER_FUNC_NONE = 5,
    V4L2_XFER_FUNC_DCI_P3 = 6,
    V4L2_XFER_FUNC_SMPTE2084 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_ycbcr_encoding {
    V4L2_YCBCR_ENC_DEFAULT = 0,
    V4L2_YCBCR_ENC_601 = 1,
    V4L2_YCBCR_ENC_709 = 2,
    V4L2_YCBCR_ENC_XV601 = 3,
    V4L2_YCBCR_ENC_XV709 = 4,
    V4L2_YCBCR_ENC_SYCC = 5,
    V4L2_YCBCR_ENC_BT2020 = 6,
    V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
    V4L2_YCBCR_ENC_SMPTE240M = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_hsv_encoding {
    V4L2_HSV_ENC_180 = 128,
    V4L2_HSV_ENC_256 = 129,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_quantization {
    V4L2_QUANTIZATION_DEFAULT = 0,
    V4L2_QUANTIZATION_FULL_RANGE = 1,
    V4L2_QUANTIZATION_LIM_RANGE = 2,
}
impl v4l2_priority {
    pub const V4L2_PRIORITY_DEFAULT: v4l2_priority = v4l2_priority::V4L2_PRIORITY_INTERACTIVE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_rect {
    pub left: __s32,
    pub top: __s32,
    pub width: __u32,
    pub height: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_rect"][::core::mem::size_of::<v4l2_rect>() - 16usize];
    ["Alignment of v4l2_rect"][::core::mem::align_of::<v4l2_rect>() - 4usize];
    ["Offset of field: v4l2_rect::left"][::core::mem::offset_of!(v4l2_rect, left) - 0usize];
    ["Offset of field: v4l2_rect::top"][::core::mem::offset_of!(v4l2_rect, top) - 4usize];
    ["Offset of field: v4l2_rect::width"][::core::mem::offset_of!(v4l2_rect, width) - 8usize];
    ["Offset of field: v4l2_rect::height"][::core::mem::offset_of!(v4l2_rect, height) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_fract"][::core::mem::size_of::<v4l2_fract>() - 8usize];
    ["Alignment of v4l2_fract"][::core::mem::align_of::<v4l2_fract>() - 4usize];
    ["Offset of field: v4l2_fract::numerator"]
        [::core::mem::offset_of!(v4l2_fract, numerator) - 0usize];
    ["Offset of field: v4l2_fract::denominator"]
        [::core::mem::offset_of!(v4l2_fract, denominator) - 4usize];
};
#[doc = " struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP\n\n @driver:\t   name of the driver module (e.g. \"bttv\")\n @card:\t   name of the card (e.g. \"Hauppauge WinTV\")\n @bus_info:\t   name of the bus (e.g. \"PCI:\" + pci_name(pci_dev) )\n @version:\t   KERNEL_VERSION\n @capabilities: capabilities of the physical device as a whole\n @device_caps:  capabilities accessed via this particular device (node)\n @reserved:\t   reserved fields for future extensions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_capability {
    pub driver: [__u8; 16usize],
    pub card: [__u8; 32usize],
    pub bus_info: [__u8; 32usize],
    pub version: __u32,
    pub capabilities: __u32,
    pub device_caps: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_capability"][::core::mem::size_of::<v4l2_capability>() - 104usize];
    ["Alignment of v4l2_capability"][::core::mem::align_of::<v4l2_capability>() - 4usize];
    ["Offset of field: v4l2_capability::driver"]
        [::core::mem::offset_of!(v4l2_capability, driver) - 0usize];
    ["Offset of field: v4l2_capability::card"]
        [::core::mem::offset_of!(v4l2_capability, card) - 16usize];
    ["Offset of field: v4l2_capability::bus_info"]
        [::core::mem::offset_of!(v4l2_capability, bus_info) - 48usize];
    ["Offset of field: v4l2_capability::version"]
        [::core::mem::offset_of!(v4l2_capability, version) - 80usize];
    ["Offset of field: v4l2_capability::capabilities"]
        [::core::mem::offset_of!(v4l2_capability, capabilities) - 84usize];
    ["Offset of field: v4l2_capability::device_caps"]
        [::core::mem::offset_of!(v4l2_capability, device_caps) - 88usize];
    ["Offset of field: v4l2_capability::reserved"]
        [::core::mem::offset_of!(v4l2_capability, reserved) - 92usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
    pub flags: __u32,
    pub __anon1: v4l2_pix_format__bindgen_ty_1,
    pub quantization: __u32,
    pub xfer_func: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format__bindgen_ty_1 {
    pub ycbcr_enc: __u32,
    pub hsv_enc: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_pix_format__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_pix_format__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_pix_format__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_pix_format__bindgen_ty_1::ycbcr_enc"]
        [::core::mem::offset_of!(v4l2_pix_format__bindgen_ty_1, ycbcr_enc) - 0usize];
    ["Offset of field: v4l2_pix_format__bindgen_ty_1::hsv_enc"]
        [::core::mem::offset_of!(v4l2_pix_format__bindgen_ty_1, hsv_enc) - 0usize];
};
impl Default for v4l2_pix_format__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format"][::core::mem::size_of::<v4l2_pix_format>() - 48usize];
    ["Alignment of v4l2_pix_format"][::core::mem::align_of::<v4l2_pix_format>() - 4usize];
    ["Offset of field: v4l2_pix_format::width"]
        [::core::mem::offset_of!(v4l2_pix_format, width) - 0usize];
    ["Offset of field: v4l2_pix_format::height"]
        [::core::mem::offset_of!(v4l2_pix_format, height) - 4usize];
    ["Offset of field: v4l2_pix_format::pixelformat"]
        [::core::mem::offset_of!(v4l2_pix_format, pixelformat) - 8usize];
    ["Offset of field: v4l2_pix_format::field"]
        [::core::mem::offset_of!(v4l2_pix_format, field) - 12usize];
    ["Offset of field: v4l2_pix_format::bytesperline"]
        [::core::mem::offset_of!(v4l2_pix_format, bytesperline) - 16usize];
    ["Offset of field: v4l2_pix_format::sizeimage"]
        [::core::mem::offset_of!(v4l2_pix_format, sizeimage) - 20usize];
    ["Offset of field: v4l2_pix_format::colorspace"]
        [::core::mem::offset_of!(v4l2_pix_format, colorspace) - 24usize];
    ["Offset of field: v4l2_pix_format::priv_"]
        [::core::mem::offset_of!(v4l2_pix_format, priv_) - 28usize];
    ["Offset of field: v4l2_pix_format::flags"]
        [::core::mem::offset_of!(v4l2_pix_format, flags) - 32usize];
    ["Offset of field: v4l2_pix_format::quantization"]
        [::core::mem::offset_of!(v4l2_pix_format, quantization) - 40usize];
    ["Offset of field: v4l2_pix_format::xfer_func"]
        [::core::mem::offset_of!(v4l2_pix_format, xfer_func) - 44usize];
};
impl Default for v4l2_pix_format {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_fmtdesc {
    pub index: __u32,
    pub type_: __u32,
    pub flags: __u32,
    pub description: [__u8; 32usize],
    pub pixelformat: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_fmtdesc"][::core::mem::size_of::<v4l2_fmtdesc>() - 64usize];
    ["Alignment of v4l2_fmtdesc"][::core::mem::align_of::<v4l2_fmtdesc>() - 4usize];
    ["Offset of field: v4l2_fmtdesc::index"][::core::mem::offset_of!(v4l2_fmtdesc, index) - 0usize];
    ["Offset of field: v4l2_fmtdesc::type_"][::core::mem::offset_of!(v4l2_fmtdesc, type_) - 4usize];
    ["Offset of field: v4l2_fmtdesc::flags"][::core::mem::offset_of!(v4l2_fmtdesc, flags) - 8usize];
    ["Offset of field: v4l2_fmtdesc::description"]
        [::core::mem::offset_of!(v4l2_fmtdesc, description) - 12usize];
    ["Offset of field: v4l2_fmtdesc::pixelformat"]
        [::core::mem::offset_of!(v4l2_fmtdesc, pixelformat) - 44usize];
    ["Offset of field: v4l2_fmtdesc::reserved"]
        [::core::mem::offset_of!(v4l2_fmtdesc, reserved) - 48usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_frmsizetypes {
    V4L2_FRMSIZE_TYPE_DISCRETE = 1,
    V4L2_FRMSIZE_TYPE_CONTINUOUS = 2,
    V4L2_FRMSIZE_TYPE_STEPWISE = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frmsize_discrete {
    pub width: __u32,
    pub height: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsize_discrete"][::core::mem::size_of::<v4l2_frmsize_discrete>() - 8usize];
    ["Alignment of v4l2_frmsize_discrete"]
        [::core::mem::align_of::<v4l2_frmsize_discrete>() - 4usize];
    ["Offset of field: v4l2_frmsize_discrete::width"]
        [::core::mem::offset_of!(v4l2_frmsize_discrete, width) - 0usize];
    ["Offset of field: v4l2_frmsize_discrete::height"]
        [::core::mem::offset_of!(v4l2_frmsize_discrete, height) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frmsize_stepwise {
    pub min_width: __u32,
    pub max_width: __u32,
    pub step_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub step_height: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsize_stepwise"][::core::mem::size_of::<v4l2_frmsize_stepwise>() - 24usize];
    ["Alignment of v4l2_frmsize_stepwise"]
        [::core::mem::align_of::<v4l2_frmsize_stepwise>() - 4usize];
    ["Offset of field: v4l2_frmsize_stepwise::min_width"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, min_width) - 0usize];
    ["Offset of field: v4l2_frmsize_stepwise::max_width"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, max_width) - 4usize];
    ["Offset of field: v4l2_frmsize_stepwise::step_width"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, step_width) - 8usize];
    ["Offset of field: v4l2_frmsize_stepwise::min_height"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, min_height) - 12usize];
    ["Offset of field: v4l2_frmsize_stepwise::max_height"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, max_height) - 16usize];
    ["Offset of field: v4l2_frmsize_stepwise::step_height"]
        [::core::mem::offset_of!(v4l2_frmsize_stepwise, step_height) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmsizeenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub type_: __u32,
    pub __anon1: v4l2_frmsizeenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmsizeenum__bindgen_ty_1 {
    pub discrete: v4l2_frmsize_discrete,
    pub stepwise: v4l2_frmsize_stepwise,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsizeenum__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_frmsizeenum__bindgen_ty_1>() - 24usize];
    ["Alignment of v4l2_frmsizeenum__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_frmsizeenum__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_frmsizeenum__bindgen_ty_1::discrete"]
        [::core::mem::offset_of!(v4l2_frmsizeenum__bindgen_ty_1, discrete) - 0usize];
    ["Offset of field: v4l2_frmsizeenum__bindgen_ty_1::stepwise"]
        [::core::mem::offset_of!(v4l2_frmsizeenum__bindgen_ty_1, stepwise) - 0usize];
};
impl Default for v4l2_frmsizeenum__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmsizeenum"][::core::mem::size_of::<v4l2_frmsizeenum>() - 44usize];
    ["Alignment of v4l2_frmsizeenum"][::core::mem::align_of::<v4l2_frmsizeenum>() - 4usize];
    ["Offset of field: v4l2_frmsizeenum::index"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, index) - 0usize];
    ["Offset of field: v4l2_frmsizeenum::pixel_format"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, pixel_format) - 4usize];
    ["Offset of field: v4l2_frmsizeenum::type_"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, type_) - 8usize];
    ["Offset of field: v4l2_frmsizeenum::reserved"]
        [::core::mem::offset_of!(v4l2_frmsizeenum, reserved) - 36usize];
};
impl Default for v4l2_frmsizeenum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_frmivaltypes {
    V4L2_FRMIVAL_TYPE_DISCRETE = 1,
    V4L2_FRMIVAL_TYPE_CONTINUOUS = 2,
    V4L2_FRMIVAL_TYPE_STEPWISE = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frmival_stepwise {
    pub min: v4l2_fract,
    pub max: v4l2_fract,
    pub step: v4l2_fract,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmival_stepwise"][::core::mem::size_of::<v4l2_frmival_stepwise>() - 24usize];
    ["Alignment of v4l2_frmival_stepwise"]
        [::core::mem::align_of::<v4l2_frmival_stepwise>() - 4usize];
    ["Offset of field: v4l2_frmival_stepwise::min"]
        [::core::mem::offset_of!(v4l2_frmival_stepwise, min) - 0usize];
    ["Offset of field: v4l2_frmival_stepwise::max"]
        [::core::mem::offset_of!(v4l2_frmival_stepwise, max) - 8usize];
    ["Offset of field: v4l2_frmival_stepwise::step"]
        [::core::mem::offset_of!(v4l2_frmival_stepwise, step) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmivalenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub width: __u32,
    pub height: __u32,
    pub type_: __u32,
    pub __anon1: v4l2_frmivalenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmivalenum__bindgen_ty_1 {
    pub discrete: v4l2_fract,
    pub stepwise: v4l2_frmival_stepwise,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmivalenum__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_frmivalenum__bindgen_ty_1>() - 24usize];
    ["Alignment of v4l2_frmivalenum__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_frmivalenum__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_frmivalenum__bindgen_ty_1::discrete"]
        [::core::mem::offset_of!(v4l2_frmivalenum__bindgen_ty_1, discrete) - 0usize];
    ["Offset of field: v4l2_frmivalenum__bindgen_ty_1::stepwise"]
        [::core::mem::offset_of!(v4l2_frmivalenum__bindgen_ty_1, stepwise) - 0usize];
};
impl Default for v4l2_frmivalenum__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frmivalenum"][::core::mem::size_of::<v4l2_frmivalenum>() - 52usize];
    ["Alignment of v4l2_frmivalenum"][::core::mem::align_of::<v4l2_frmivalenum>() - 4usize];
    ["Offset of field: v4l2_frmivalenum::index"]
        [::core::mem::offset_of!(v4l2_frmivalenum, index) - 0usize];
    ["Offset of field: v4l2_frmivalenum::pixel_format"]
        [::core::mem::offset_of!(v4l2_frmivalenum, pixel_format) - 4usize];
    ["Offset of field: v4l2_frmivalenum::width"]
        [::core::mem::offset_of!(v4l2_frmivalenum, width) - 8usize];
    ["Offset of field: v4l2_frmivalenum::height"]
        [::core::mem::offset_of!(v4l2_frmivalenum, height) - 12usize];
    ["Offset of field: v4l2_frmivalenum::type_"]
        [::core::mem::offset_of!(v4l2_frmivalenum, type_) - 16usize];
    ["Offset of field: v4l2_frmivalenum::reserved"]
        [::core::mem::offset_of!(v4l2_frmivalenum, reserved) - 44usize];
};
impl Default for v4l2_frmivalenum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_timecode {
    pub type_: __u32,
    pub flags: __u32,
    pub frames: __u8,
    pub seconds: __u8,
    pub minutes: __u8,
    pub hours: __u8,
    pub userbits: [__u8; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_timecode"][::core::mem::size_of::<v4l2_timecode>() - 16usize];
    ["Alignment of v4l2_timecode"][::core::mem::align_of::<v4l2_timecode>() - 4usize];
    ["Offset of field: v4l2_timecode::type_"]
        [::core::mem::offset_of!(v4l2_timecode, type_) - 0usize];
    ["Offset of field: v4l2_timecode::flags"]
        [::core::mem::offset_of!(v4l2_timecode, flags) - 4usize];
    ["Offset of field: v4l2_timecode::frames"]
        [::core::mem::offset_of!(v4l2_timecode, frames) - 8usize];
    ["Offset of field: v4l2_timecode::seconds"]
        [::core::mem::offset_of!(v4l2_timecode, seconds) - 9usize];
    ["Offset of field: v4l2_timecode::minutes"]
        [::core::mem::offset_of!(v4l2_timecode, minutes) - 10usize];
    ["Offset of field: v4l2_timecode::hours"]
        [::core::mem::offset_of!(v4l2_timecode, hours) - 11usize];
    ["Offset of field: v4l2_timecode::userbits"]
        [::core::mem::offset_of!(v4l2_timecode, userbits) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_jpegcompression {
    pub quality: libc::c_int,
    pub APPn: libc::c_int,
    pub APP_len: libc::c_int,
    pub APP_data: [libc::c_char; 60usize],
    pub COM_len: libc::c_int,
    pub COM_data: [libc::c_char; 60usize],
    pub jpeg_markers: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_jpegcompression"][::core::mem::size_of::<v4l2_jpegcompression>() - 140usize];
    ["Alignment of v4l2_jpegcompression"][::core::mem::align_of::<v4l2_jpegcompression>() - 4usize];
    ["Offset of field: v4l2_jpegcompression::quality"]
        [::core::mem::offset_of!(v4l2_jpegcompression, quality) - 0usize];
    ["Offset of field: v4l2_jpegcompression::APPn"]
        [::core::mem::offset_of!(v4l2_jpegcompression, APPn) - 4usize];
    ["Offset of field: v4l2_jpegcompression::APP_len"]
        [::core::mem::offset_of!(v4l2_jpegcompression, APP_len) - 8usize];
    ["Offset of field: v4l2_jpegcompression::APP_data"]
        [::core::mem::offset_of!(v4l2_jpegcompression, APP_data) - 12usize];
    ["Offset of field: v4l2_jpegcompression::COM_len"]
        [::core::mem::offset_of!(v4l2_jpegcompression, COM_len) - 72usize];
    ["Offset of field: v4l2_jpegcompression::COM_data"]
        [::core::mem::offset_of!(v4l2_jpegcompression, COM_data) - 76usize];
    ["Offset of field: v4l2_jpegcompression::jpeg_markers"]
        [::core::mem::offset_of!(v4l2_jpegcompression, jpeg_markers) - 136usize];
};
impl Default for v4l2_jpegcompression {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_requestbuffers {
    pub count: __u32,
    pub type_: __u32,
    pub memory: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_requestbuffers"][::core::mem::size_of::<v4l2_requestbuffers>() - 20usize];
    ["Alignment of v4l2_requestbuffers"][::core::mem::align_of::<v4l2_requestbuffers>() - 4usize];
    ["Offset of field: v4l2_requestbuffers::count"]
        [::core::mem::offset_of!(v4l2_requestbuffers, count) - 0usize];
    ["Offset of field: v4l2_requestbuffers::type_"]
        [::core::mem::offset_of!(v4l2_requestbuffers, type_) - 4usize];
    ["Offset of field: v4l2_requestbuffers::memory"]
        [::core::mem::offset_of!(v4l2_requestbuffers, memory) - 8usize];
    ["Offset of field: v4l2_requestbuffers::capabilities"]
        [::core::mem::offset_of!(v4l2_requestbuffers, capabilities) - 12usize];
    ["Offset of field: v4l2_requestbuffers::reserved"]
        [::core::mem::offset_of!(v4l2_requestbuffers, reserved) - 16usize];
};
#[doc = " struct v4l2_plane - plane info for multi-planar buffers\n @bytesused:\t\tnumber of bytes occupied by data in the plane (payload)\n @length:\t\tsize of this plane (NOT the payload) in bytes\n @mem_offset:\t\twhen memory in the associated struct v4l2_buffer is\n\t\t\tV4L2_MEMORY_MMAP, equals the offset from the start of\n\t\t\tthe device memory for this plane (or is a \"cookie\" that\n\t\t\tshould be passed to mmap() called on the video node)\n @userptr:\t\twhen memory is V4L2_MEMORY_USERPTR, a userspace pointer\n\t\t\tpointing to this plane\n @fd:\t\t\twhen memory is V4L2_MEMORY_DMABUF, a userspace file\n\t\t\tdescriptor associated with this plane\n @data_offset:\toffset in the plane to the start of data; usually 0,\n\t\t\tunless there is a header in front of the data\n\n Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer\n with two planes can have one plane for Y, and another for interleaved CbCr\n components. Each plane can reside in a separate memory buffer, or even in\n a completely separate memory node (e.g. in embedded devices)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_plane {
    pub bytesused: __u32,
    pub length: __u32,
    pub m: v4l2_plane__bindgen_ty_1,
    pub data_offset: __u32,
    pub reserved: [__u32; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_plane__bindgen_ty_1 {
    pub mem_offset: __u32,
    pub userptr: libc::c_ulong,
    pub fd: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_plane__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_plane__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_plane__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_plane__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_plane__bindgen_ty_1::mem_offset"]
        [::core::mem::offset_of!(v4l2_plane__bindgen_ty_1, mem_offset) - 0usize];
    ["Offset of field: v4l2_plane__bindgen_ty_1::userptr"]
        [::core::mem::offset_of!(v4l2_plane__bindgen_ty_1, userptr) - 0usize];
    ["Offset of field: v4l2_plane__bindgen_ty_1::fd"]
        [::core::mem::offset_of!(v4l2_plane__bindgen_ty_1, fd) - 0usize];
};
impl Default for v4l2_plane__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_plane"][::core::mem::size_of::<v4l2_plane>() - 60usize];
    ["Alignment of v4l2_plane"][::core::mem::align_of::<v4l2_plane>() - 4usize];
    ["Offset of field: v4l2_plane::bytesused"]
        [::core::mem::offset_of!(v4l2_plane, bytesused) - 0usize];
    ["Offset of field: v4l2_plane::length"][::core::mem::offset_of!(v4l2_plane, length) - 4usize];
    ["Offset of field: v4l2_plane::m"][::core::mem::offset_of!(v4l2_plane, m) - 8usize];
    ["Offset of field: v4l2_plane::data_offset"]
        [::core::mem::offset_of!(v4l2_plane, data_offset) - 12usize];
    ["Offset of field: v4l2_plane::reserved"]
        [::core::mem::offset_of!(v4l2_plane, reserved) - 16usize];
};
impl Default for v4l2_plane {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_buffer - video buffer info\n @index:\tid number of the buffer\n @type:\tenum v4l2_buf_type; buffer type (type == *_MPLANE for\n\t\tmultiplanar buffers);\n @bytesused:\tnumber of bytes occupied by data in the buffer (payload);\n\t\tunused (set to 0) for multiplanar buffers\n @flags:\tbuffer informational flags\n @field:\tenum v4l2_field; field order of the image in the buffer\n @timestamp:\tframe timestamp\n @timecode:\tframe timecode\n @sequence:\tsequence count of this frame\n @memory:\tenum v4l2_memory; the method, in which the actual video data is\n\t\tpassed\n @offset:\tfor non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;\n\t\toffset from the start of the device memory for this plane,\n\t\t(or a \"cookie\" that should be passed to mmap() as offset)\n @userptr:\tfor non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;\n\t\ta userspace pointer pointing to this buffer\n @fd:\t\tfor non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;\n\t\ta userspace file descriptor associated with this buffer\n @planes:\tfor multiplanar buffers; userspace pointer to the array of plane\n\t\tinfo structs for this buffer\n @length:\tsize in bytes of the buffer (NOT its payload) for single-plane\n\t\tbuffers (when type != *_MPLANE); number of elements in the\n\t\tplanes array for multi-plane buffers\n @request_fd: fd of the request that this buffer should use\n\n Contains data exchanged by application and driver using one of the Streaming\n I/O methods."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_buffer {
    pub index: __u32,
    pub type_: __u32,
    pub bytesused: __u32,
    pub flags: __u32,
    pub field: __u32,
    pub timestamp: timeval,
    pub timecode: v4l2_timecode,
    pub sequence: __u32,
    pub memory: __u32,
    pub m: v4l2_buffer__bindgen_ty_1,
    pub length: __u32,
    pub reserved2: __u32,
    pub __anon1: v4l2_buffer__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_1 {
    pub offset: __u32,
    pub userptr: libc::c_ulong,
    pub planes: *mut v4l2_plane,
    pub fd: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_buffer__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_buffer__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_buffer__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_buffer__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::offset"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, offset) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::userptr"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, userptr) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::planes"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, planes) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_1::fd"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_1, fd) - 0usize];
};
impl Default for v4l2_buffer__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_2 {
    pub request_fd: __s32,
    pub reserved: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_buffer__bindgen_ty_2"]
        [::core::mem::size_of::<v4l2_buffer__bindgen_ty_2>() - 4usize];
    ["Alignment of v4l2_buffer__bindgen_ty_2"]
        [::core::mem::align_of::<v4l2_buffer__bindgen_ty_2>() - 4usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_2::request_fd"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_2, request_fd) - 0usize];
    ["Offset of field: v4l2_buffer__bindgen_ty_2::reserved"]
        [::core::mem::offset_of!(v4l2_buffer__bindgen_ty_2, reserved) - 0usize];
};
impl Default for v4l2_buffer__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_buffer"][::core::mem::size_of::<v4l2_buffer>() - 68usize];
    ["Alignment of v4l2_buffer"][::core::mem::align_of::<v4l2_buffer>() - 4usize];
    ["Offset of field: v4l2_buffer::index"][::core::mem::offset_of!(v4l2_buffer, index) - 0usize];
    ["Offset of field: v4l2_buffer::type_"][::core::mem::offset_of!(v4l2_buffer, type_) - 4usize];
    ["Offset of field: v4l2_buffer::bytesused"]
        [::core::mem::offset_of!(v4l2_buffer, bytesused) - 8usize];
    ["Offset of field: v4l2_buffer::flags"][::core::mem::offset_of!(v4l2_buffer, flags) - 12usize];
    ["Offset of field: v4l2_buffer::field"][::core::mem::offset_of!(v4l2_buffer, field) - 16usize];
    ["Offset of field: v4l2_buffer::timestamp"]
        [::core::mem::offset_of!(v4l2_buffer, timestamp) - 20usize];
    ["Offset of field: v4l2_buffer::timecode"]
        [::core::mem::offset_of!(v4l2_buffer, timecode) - 28usize];
    ["Offset of field: v4l2_buffer::sequence"]
        [::core::mem::offset_of!(v4l2_buffer, sequence) - 44usize];
    ["Offset of field: v4l2_buffer::memory"]
        [::core::mem::offset_of!(v4l2_buffer, memory) - 48usize];
    ["Offset of field: v4l2_buffer::m"][::core::mem::offset_of!(v4l2_buffer, m) - 52usize];
    ["Offset of field: v4l2_buffer::length"]
        [::core::mem::offset_of!(v4l2_buffer, length) - 56usize];
    ["Offset of field: v4l2_buffer::reserved2"]
        [::core::mem::offset_of!(v4l2_buffer, reserved2) - 60usize];
};
impl Default for v4l2_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor\n\n @index:\tid number of the buffer\n @type:\tenum v4l2_buf_type; buffer type (type == *_MPLANE for\n\t\tmultiplanar buffers);\n @plane:\tindex of the plane to be exported, 0 for single plane queues\n @flags:\tflags for newly created file, currently only O_CLOEXEC is\n\t\tsupported, refer to manual of open syscall for more details\n @fd:\t\tfile descriptor associated with DMABUF (set by driver)\n\n Contains data used for exporting a video buffer as DMABUF file descriptor.\n The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF\n (identical to the cookie used to mmap() the buffer to userspace). All\n reserved fields must be set to zero. The field reserved0 is expected to\n become a structure 'type' allowing an alternative layout of the structure\n content. Therefore this field should not be used for any other extensions."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_exportbuffer {
    pub type_: __u32,
    pub index: __u32,
    pub plane: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub reserved: [__u32; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_exportbuffer"][::core::mem::size_of::<v4l2_exportbuffer>() - 64usize];
    ["Alignment of v4l2_exportbuffer"][::core::mem::align_of::<v4l2_exportbuffer>() - 4usize];
    ["Offset of field: v4l2_exportbuffer::type_"]
        [::core::mem::offset_of!(v4l2_exportbuffer, type_) - 0usize];
    ["Offset of field: v4l2_exportbuffer::index"]
        [::core::mem::offset_of!(v4l2_exportbuffer, index) - 4usize];
    ["Offset of field: v4l2_exportbuffer::plane"]
        [::core::mem::offset_of!(v4l2_exportbuffer, plane) - 8usize];
    ["Offset of field: v4l2_exportbuffer::flags"]
        [::core::mem::offset_of!(v4l2_exportbuffer, flags) - 12usize];
    ["Offset of field: v4l2_exportbuffer::fd"]
        [::core::mem::offset_of!(v4l2_exportbuffer, fd) - 16usize];
    ["Offset of field: v4l2_exportbuffer::reserved"]
        [::core::mem::offset_of!(v4l2_exportbuffer, reserved) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_framebuffer {
    pub capability: __u32,
    pub flags: __u32,
    pub base: *mut libc::c_void,
    pub fmt: v4l2_framebuffer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_framebuffer__bindgen_ty_1 {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_framebuffer__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_framebuffer__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_framebuffer__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_framebuffer__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::width"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, width) - 0usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::height"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, height) - 4usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::pixelformat"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, pixelformat) - 8usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::field"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, field) - 12usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::bytesperline"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, bytesperline) - 16usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::sizeimage"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, sizeimage) - 20usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::colorspace"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, colorspace) - 24usize];
    ["Offset of field: v4l2_framebuffer__bindgen_ty_1::priv_"]
        [::core::mem::offset_of!(v4l2_framebuffer__bindgen_ty_1, priv_) - 28usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_framebuffer"][::core::mem::size_of::<v4l2_framebuffer>() - 44usize];
    ["Alignment of v4l2_framebuffer"][::core::mem::align_of::<v4l2_framebuffer>() - 4usize];
    ["Offset of field: v4l2_framebuffer::capability"]
        [::core::mem::offset_of!(v4l2_framebuffer, capability) - 0usize];
    ["Offset of field: v4l2_framebuffer::flags"]
        [::core::mem::offset_of!(v4l2_framebuffer, flags) - 4usize];
    ["Offset of field: v4l2_framebuffer::base"]
        [::core::mem::offset_of!(v4l2_framebuffer, base) - 8usize];
    ["Offset of field: v4l2_framebuffer::fmt"]
        [::core::mem::offset_of!(v4l2_framebuffer, fmt) - 12usize];
};
impl Default for v4l2_framebuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_clip {
    pub c: v4l2_rect,
    pub next: *mut v4l2_clip,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_clip"][::core::mem::size_of::<v4l2_clip>() - 20usize];
    ["Alignment of v4l2_clip"][::core::mem::align_of::<v4l2_clip>() - 4usize];
    ["Offset of field: v4l2_clip::c"][::core::mem::offset_of!(v4l2_clip, c) - 0usize];
    ["Offset of field: v4l2_clip::next"][::core::mem::offset_of!(v4l2_clip, next) - 16usize];
};
impl Default for v4l2_clip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_window {
    pub w: v4l2_rect,
    pub field: __u32,
    pub chromakey: __u32,
    pub clips: *mut v4l2_clip,
    pub clipcount: __u32,
    pub bitmap: *mut libc::c_void,
    pub global_alpha: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_window"][::core::mem::size_of::<v4l2_window>() - 40usize];
    ["Alignment of v4l2_window"][::core::mem::align_of::<v4l2_window>() - 4usize];
    ["Offset of field: v4l2_window::w"][::core::mem::offset_of!(v4l2_window, w) - 0usize];
    ["Offset of field: v4l2_window::field"][::core::mem::offset_of!(v4l2_window, field) - 16usize];
    ["Offset of field: v4l2_window::chromakey"]
        [::core::mem::offset_of!(v4l2_window, chromakey) - 20usize];
    ["Offset of field: v4l2_window::clips"][::core::mem::offset_of!(v4l2_window, clips) - 24usize];
    ["Offset of field: v4l2_window::clipcount"]
        [::core::mem::offset_of!(v4l2_window, clipcount) - 28usize];
    ["Offset of field: v4l2_window::bitmap"]
        [::core::mem::offset_of!(v4l2_window, bitmap) - 32usize];
    ["Offset of field: v4l2_window::global_alpha"]
        [::core::mem::offset_of!(v4l2_window, global_alpha) - 36usize];
};
impl Default for v4l2_window {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_captureparm {
    pub capability: __u32,
    pub capturemode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub readbuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_captureparm"][::core::mem::size_of::<v4l2_captureparm>() - 40usize];
    ["Alignment of v4l2_captureparm"][::core::mem::align_of::<v4l2_captureparm>() - 4usize];
    ["Offset of field: v4l2_captureparm::capability"]
        [::core::mem::offset_of!(v4l2_captureparm, capability) - 0usize];
    ["Offset of field: v4l2_captureparm::capturemode"]
        [::core::mem::offset_of!(v4l2_captureparm, capturemode) - 4usize];
    ["Offset of field: v4l2_captureparm::timeperframe"]
        [::core::mem::offset_of!(v4l2_captureparm, timeperframe) - 8usize];
    ["Offset of field: v4l2_captureparm::extendedmode"]
        [::core::mem::offset_of!(v4l2_captureparm, extendedmode) - 16usize];
    ["Offset of field: v4l2_captureparm::readbuffers"]
        [::core::mem::offset_of!(v4l2_captureparm, readbuffers) - 20usize];
    ["Offset of field: v4l2_captureparm::reserved"]
        [::core::mem::offset_of!(v4l2_captureparm, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_outputparm {
    pub capability: __u32,
    pub outputmode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub writebuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_outputparm"][::core::mem::size_of::<v4l2_outputparm>() - 40usize];
    ["Alignment of v4l2_outputparm"][::core::mem::align_of::<v4l2_outputparm>() - 4usize];
    ["Offset of field: v4l2_outputparm::capability"]
        [::core::mem::offset_of!(v4l2_outputparm, capability) - 0usize];
    ["Offset of field: v4l2_outputparm::outputmode"]
        [::core::mem::offset_of!(v4l2_outputparm, outputmode) - 4usize];
    ["Offset of field: v4l2_outputparm::timeperframe"]
        [::core::mem::offset_of!(v4l2_outputparm, timeperframe) - 8usize];
    ["Offset of field: v4l2_outputparm::extendedmode"]
        [::core::mem::offset_of!(v4l2_outputparm, extendedmode) - 16usize];
    ["Offset of field: v4l2_outputparm::writebuffers"]
        [::core::mem::offset_of!(v4l2_outputparm, writebuffers) - 20usize];
    ["Offset of field: v4l2_outputparm::reserved"]
        [::core::mem::offset_of!(v4l2_outputparm, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_cropcap {
    pub type_: __u32,
    pub bounds: v4l2_rect,
    pub defrect: v4l2_rect,
    pub pixelaspect: v4l2_fract,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_cropcap"][::core::mem::size_of::<v4l2_cropcap>() - 44usize];
    ["Alignment of v4l2_cropcap"][::core::mem::align_of::<v4l2_cropcap>() - 4usize];
    ["Offset of field: v4l2_cropcap::type_"][::core::mem::offset_of!(v4l2_cropcap, type_) - 0usize];
    ["Offset of field: v4l2_cropcap::bounds"]
        [::core::mem::offset_of!(v4l2_cropcap, bounds) - 4usize];
    ["Offset of field: v4l2_cropcap::defrect"]
        [::core::mem::offset_of!(v4l2_cropcap, defrect) - 20usize];
    ["Offset of field: v4l2_cropcap::pixelaspect"]
        [::core::mem::offset_of!(v4l2_cropcap, pixelaspect) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_crop {
    pub type_: __u32,
    pub c: v4l2_rect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_crop"][::core::mem::size_of::<v4l2_crop>() - 20usize];
    ["Alignment of v4l2_crop"][::core::mem::align_of::<v4l2_crop>() - 4usize];
    ["Offset of field: v4l2_crop::type_"][::core::mem::offset_of!(v4l2_crop, type_) - 0usize];
    ["Offset of field: v4l2_crop::c"][::core::mem::offset_of!(v4l2_crop, c) - 4usize];
};
#[doc = " struct v4l2_selection - selection info\n @type:\tbuffer type (do not use *_MPLANE types)\n @target:\tSelection target, used to choose one of possible rectangles;\n\t\tdefined in v4l2-common.h; V4L2_SEL_TGT_* .\n @flags:\tconstraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.\n @r:\t\tcoordinates of selection window\n @reserved:\tfor future use, rounds structure size to 64 bytes, set to zero\n\n Hardware may use multiple helper windows to process a video stream.\n The structure is used to exchange this selection areas between\n an application and a driver."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_selection {
    pub type_: __u32,
    pub target: __u32,
    pub flags: __u32,
    pub r: v4l2_rect,
    pub reserved: [__u32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_selection"][::core::mem::size_of::<v4l2_selection>() - 64usize];
    ["Alignment of v4l2_selection"][::core::mem::align_of::<v4l2_selection>() - 4usize];
    ["Offset of field: v4l2_selection::type_"]
        [::core::mem::offset_of!(v4l2_selection, type_) - 0usize];
    ["Offset of field: v4l2_selection::target"]
        [::core::mem::offset_of!(v4l2_selection, target) - 4usize];
    ["Offset of field: v4l2_selection::flags"]
        [::core::mem::offset_of!(v4l2_selection, flags) - 8usize];
    ["Offset of field: v4l2_selection::r"][::core::mem::offset_of!(v4l2_selection, r) - 12usize];
    ["Offset of field: v4l2_selection::reserved"]
        [::core::mem::offset_of!(v4l2_selection, reserved) - 28usize];
};
pub type v4l2_std_id = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_standard {
    pub index: __u32,
    pub id: v4l2_std_id,
    pub name: [__u8; 24usize],
    pub frameperiod: v4l2_fract,
    pub framelines: __u32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_standard"][::core::mem::size_of::<v4l2_standard>() - 72usize];
    ["Alignment of v4l2_standard"][::core::mem::align_of::<v4l2_standard>() - 8usize];
    ["Offset of field: v4l2_standard::index"]
        [::core::mem::offset_of!(v4l2_standard, index) - 0usize];
    ["Offset of field: v4l2_standard::id"][::core::mem::offset_of!(v4l2_standard, id) - 8usize];
    ["Offset of field: v4l2_standard::name"]
        [::core::mem::offset_of!(v4l2_standard, name) - 16usize];
    ["Offset of field: v4l2_standard::frameperiod"]
        [::core::mem::offset_of!(v4l2_standard, frameperiod) - 40usize];
    ["Offset of field: v4l2_standard::framelines"]
        [::core::mem::offset_of!(v4l2_standard, framelines) - 48usize];
    ["Offset of field: v4l2_standard::reserved"]
        [::core::mem::offset_of!(v4l2_standard, reserved) - 52usize];
};
#[doc = " struct v4l2_bt_timings - BT.656/BT.1120 timing data\n @width:\ttotal width of the active video in pixels\n @height:\ttotal height of the active video in lines\n @interlaced:\tInterlaced or progressive\n @polarities:\tPositive or negative polarities\n @pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000\n @hfrontporch:Horizontal front porch in pixels\n @hsync:\tHorizontal Sync length in pixels\n @hbackporch:\tHorizontal back porch in pixels\n @vfrontporch:Vertical front porch in lines\n @vsync:\tVertical Sync length in lines\n @vbackporch:\tVertical back porch in lines\n @il_vfrontporch:Vertical front porch for the even field\n\t\t(aka field 2) of interlaced field formats\n @il_vsync:\tVertical Sync length for the even field\n\t\t(aka field 2) of interlaced field formats\n @il_vbackporch:Vertical back porch for the even field\n\t\t(aka field 2) of interlaced field formats\n @standards:\tStandards the timing belongs to\n @flags:\tFlags\n @picture_aspect: The picture aspect ratio (hor/vert).\n @cea861_vic:\tVIC code as per the CEA-861 standard.\n @hdmi_vic:\tVIC code as per the HDMI standard.\n @reserved:\tReserved fields, must be zeroed.\n\n A note regarding vertical interlaced timings: height refers to the total\n height of the active video frame (= two fields). The blanking timings refer\n to the blanking of each field. So the height of the total frame is\n calculated as follows:\n\n tot_height = height + vfrontporch + vsync + vbackporch +\n                       il_vfrontporch + il_vsync + il_vbackporch\n\n The active height of each field is height / 2."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_bt_timings {
    pub width: __u32,
    pub height: __u32,
    pub interlaced: __u32,
    pub polarities: __u32,
    pub pixelclock: __u64,
    pub hfrontporch: __u32,
    pub hsync: __u32,
    pub hbackporch: __u32,
    pub vfrontporch: __u32,
    pub vsync: __u32,
    pub vbackporch: __u32,
    pub il_vfrontporch: __u32,
    pub il_vsync: __u32,
    pub il_vbackporch: __u32,
    pub standards: __u32,
    pub flags: __u32,
    pub picture_aspect: v4l2_fract,
    pub cea861_vic: __u8,
    pub hdmi_vic: __u8,
    pub reserved: [__u8; 46usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_bt_timings"][::core::mem::size_of::<v4l2_bt_timings>() - 124usize];
    ["Alignment of v4l2_bt_timings"][::core::mem::align_of::<v4l2_bt_timings>() - 1usize];
    ["Offset of field: v4l2_bt_timings::width"]
        [::core::mem::offset_of!(v4l2_bt_timings, width) - 0usize];
    ["Offset of field: v4l2_bt_timings::height"]
        [::core::mem::offset_of!(v4l2_bt_timings, height) - 4usize];
    ["Offset of field: v4l2_bt_timings::interlaced"]
        [::core::mem::offset_of!(v4l2_bt_timings, interlaced) - 8usize];
    ["Offset of field: v4l2_bt_timings::polarities"]
        [::core::mem::offset_of!(v4l2_bt_timings, polarities) - 12usize];
    ["Offset of field: v4l2_bt_timings::pixelclock"]
        [::core::mem::offset_of!(v4l2_bt_timings, pixelclock) - 16usize];
    ["Offset of field: v4l2_bt_timings::hfrontporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, hfrontporch) - 24usize];
    ["Offset of field: v4l2_bt_timings::hsync"]
        [::core::mem::offset_of!(v4l2_bt_timings, hsync) - 28usize];
    ["Offset of field: v4l2_bt_timings::hbackporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, hbackporch) - 32usize];
    ["Offset of field: v4l2_bt_timings::vfrontporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, vfrontporch) - 36usize];
    ["Offset of field: v4l2_bt_timings::vsync"]
        [::core::mem::offset_of!(v4l2_bt_timings, vsync) - 40usize];
    ["Offset of field: v4l2_bt_timings::vbackporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, vbackporch) - 44usize];
    ["Offset of field: v4l2_bt_timings::il_vfrontporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, il_vfrontporch) - 48usize];
    ["Offset of field: v4l2_bt_timings::il_vsync"]
        [::core::mem::offset_of!(v4l2_bt_timings, il_vsync) - 52usize];
    ["Offset of field: v4l2_bt_timings::il_vbackporch"]
        [::core::mem::offset_of!(v4l2_bt_timings, il_vbackporch) - 56usize];
    ["Offset of field: v4l2_bt_timings::standards"]
        [::core::mem::offset_of!(v4l2_bt_timings, standards) - 60usize];
    ["Offset of field: v4l2_bt_timings::flags"]
        [::core::mem::offset_of!(v4l2_bt_timings, flags) - 64usize];
    ["Offset of field: v4l2_bt_timings::picture_aspect"]
        [::core::mem::offset_of!(v4l2_bt_timings, picture_aspect) - 68usize];
    ["Offset of field: v4l2_bt_timings::cea861_vic"]
        [::core::mem::offset_of!(v4l2_bt_timings, cea861_vic) - 76usize];
    ["Offset of field: v4l2_bt_timings::hdmi_vic"]
        [::core::mem::offset_of!(v4l2_bt_timings, hdmi_vic) - 77usize];
    ["Offset of field: v4l2_bt_timings::reserved"]
        [::core::mem::offset_of!(v4l2_bt_timings, reserved) - 78usize];
};
impl Default for v4l2_bt_timings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_dv_timings - DV timings\n @type:\tthe type of the timings\n @bt:\tBT656/1120 timings"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings {
    pub type_: __u32,
    pub __anon1: v4l2_dv_timings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings__bindgen_ty_1 {
    pub bt: v4l2_bt_timings,
    pub reserved: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_dv_timings__bindgen_ty_1>() - 128usize];
    ["Alignment of v4l2_dv_timings__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_dv_timings__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_dv_timings__bindgen_ty_1::bt"]
        [::core::mem::offset_of!(v4l2_dv_timings__bindgen_ty_1, bt) - 0usize];
    ["Offset of field: v4l2_dv_timings__bindgen_ty_1::reserved"]
        [::core::mem::offset_of!(v4l2_dv_timings__bindgen_ty_1, reserved) - 0usize];
};
impl Default for v4l2_dv_timings__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings"][::core::mem::size_of::<v4l2_dv_timings>() - 132usize];
    ["Alignment of v4l2_dv_timings"][::core::mem::align_of::<v4l2_dv_timings>() - 1usize];
    ["Offset of field: v4l2_dv_timings::type_"]
        [::core::mem::offset_of!(v4l2_dv_timings, type_) - 0usize];
};
impl Default for v4l2_dv_timings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_enum_dv_timings - DV timings enumeration\n @index:\tenumeration index\n @pad:\tthe pad number for which to enumerate timings (used with\n\t\tv4l-subdev nodes only)\n @reserved:\tmust be zeroed\n @timings:\tthe timings for the given index"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_enum_dv_timings {
    pub index: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub timings: v4l2_dv_timings,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_enum_dv_timings"][::core::mem::size_of::<v4l2_enum_dv_timings>() - 148usize];
    ["Alignment of v4l2_enum_dv_timings"][::core::mem::align_of::<v4l2_enum_dv_timings>() - 4usize];
    ["Offset of field: v4l2_enum_dv_timings::index"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, index) - 0usize];
    ["Offset of field: v4l2_enum_dv_timings::pad"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, pad) - 4usize];
    ["Offset of field: v4l2_enum_dv_timings::reserved"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, reserved) - 8usize];
    ["Offset of field: v4l2_enum_dv_timings::timings"]
        [::core::mem::offset_of!(v4l2_enum_dv_timings, timings) - 16usize];
};
impl Default for v4l2_enum_dv_timings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities\n @min_width:\t\twidth in pixels\n @max_width:\t\twidth in pixels\n @min_height:\t\theight in lines\n @max_height:\t\theight in lines\n @min_pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000\n @max_pixelclock:\tPixel clock in HZ. Ex. 74.25MHz->74250000\n @standards:\t\tSupported standards\n @capabilities:\tSupported capabilities\n @reserved:\t\tMust be zeroed"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_bt_timings_cap {
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub min_pixelclock: __u64,
    pub max_pixelclock: __u64,
    pub standards: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_bt_timings_cap"][::core::mem::size_of::<v4l2_bt_timings_cap>() - 104usize];
    ["Alignment of v4l2_bt_timings_cap"][::core::mem::align_of::<v4l2_bt_timings_cap>() - 1usize];
    ["Offset of field: v4l2_bt_timings_cap::min_width"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, min_width) - 0usize];
    ["Offset of field: v4l2_bt_timings_cap::max_width"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, max_width) - 4usize];
    ["Offset of field: v4l2_bt_timings_cap::min_height"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, min_height) - 8usize];
    ["Offset of field: v4l2_bt_timings_cap::max_height"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, max_height) - 12usize];
    ["Offset of field: v4l2_bt_timings_cap::min_pixelclock"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, min_pixelclock) - 16usize];
    ["Offset of field: v4l2_bt_timings_cap::max_pixelclock"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, max_pixelclock) - 24usize];
    ["Offset of field: v4l2_bt_timings_cap::standards"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, standards) - 32usize];
    ["Offset of field: v4l2_bt_timings_cap::capabilities"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, capabilities) - 36usize];
    ["Offset of field: v4l2_bt_timings_cap::reserved"]
        [::core::mem::offset_of!(v4l2_bt_timings_cap, reserved) - 40usize];
};
#[doc = " struct v4l2_dv_timings_cap - DV timings capabilities\n @type:\tthe type of the timings (same as in struct v4l2_dv_timings)\n @pad:\tthe pad number for which to query capabilities (used with\n\t\tv4l-subdev nodes only)\n @bt:\t\tthe BT656/1120 timings capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings_cap {
    pub type_: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub __anon1: v4l2_dv_timings_cap__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings_cap__bindgen_ty_1 {
    pub bt: v4l2_bt_timings_cap,
    pub raw_data: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings_cap__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_dv_timings_cap__bindgen_ty_1>() - 128usize];
    ["Alignment of v4l2_dv_timings_cap__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_dv_timings_cap__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_dv_timings_cap__bindgen_ty_1::bt"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap__bindgen_ty_1, bt) - 0usize];
    ["Offset of field: v4l2_dv_timings_cap__bindgen_ty_1::raw_data"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap__bindgen_ty_1, raw_data) - 0usize];
};
impl Default for v4l2_dv_timings_cap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dv_timings_cap"][::core::mem::size_of::<v4l2_dv_timings_cap>() - 144usize];
    ["Alignment of v4l2_dv_timings_cap"][::core::mem::align_of::<v4l2_dv_timings_cap>() - 4usize];
    ["Offset of field: v4l2_dv_timings_cap::type_"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap, type_) - 0usize];
    ["Offset of field: v4l2_dv_timings_cap::pad"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap, pad) - 4usize];
    ["Offset of field: v4l2_dv_timings_cap::reserved"]
        [::core::mem::offset_of!(v4l2_dv_timings_cap, reserved) - 8usize];
};
impl Default for v4l2_dv_timings_cap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_input {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub tuner: __u32,
    pub std: v4l2_std_id,
    pub status: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_input"][::core::mem::size_of::<v4l2_input>() - 80usize];
    ["Alignment of v4l2_input"][::core::mem::align_of::<v4l2_input>() - 8usize];
    ["Offset of field: v4l2_input::index"][::core::mem::offset_of!(v4l2_input, index) - 0usize];
    ["Offset of field: v4l2_input::name"][::core::mem::offset_of!(v4l2_input, name) - 4usize];
    ["Offset of field: v4l2_input::type_"][::core::mem::offset_of!(v4l2_input, type_) - 36usize];
    ["Offset of field: v4l2_input::audioset"]
        [::core::mem::offset_of!(v4l2_input, audioset) - 40usize];
    ["Offset of field: v4l2_input::tuner"][::core::mem::offset_of!(v4l2_input, tuner) - 44usize];
    ["Offset of field: v4l2_input::std"][::core::mem::offset_of!(v4l2_input, std) - 48usize];
    ["Offset of field: v4l2_input::status"][::core::mem::offset_of!(v4l2_input, status) - 56usize];
    ["Offset of field: v4l2_input::capabilities"]
        [::core::mem::offset_of!(v4l2_input, capabilities) - 60usize];
    ["Offset of field: v4l2_input::reserved"]
        [::core::mem::offset_of!(v4l2_input, reserved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_output {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub modulator: __u32,
    pub std: v4l2_std_id,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_output"][::core::mem::size_of::<v4l2_output>() - 72usize];
    ["Alignment of v4l2_output"][::core::mem::align_of::<v4l2_output>() - 8usize];
    ["Offset of field: v4l2_output::index"][::core::mem::offset_of!(v4l2_output, index) - 0usize];
    ["Offset of field: v4l2_output::name"][::core::mem::offset_of!(v4l2_output, name) - 4usize];
    ["Offset of field: v4l2_output::type_"][::core::mem::offset_of!(v4l2_output, type_) - 36usize];
    ["Offset of field: v4l2_output::audioset"]
        [::core::mem::offset_of!(v4l2_output, audioset) - 40usize];
    ["Offset of field: v4l2_output::modulator"]
        [::core::mem::offset_of!(v4l2_output, modulator) - 44usize];
    ["Offset of field: v4l2_output::std"][::core::mem::offset_of!(v4l2_output, std) - 48usize];
    ["Offset of field: v4l2_output::capabilities"]
        [::core::mem::offset_of!(v4l2_output, capabilities) - 56usize];
    ["Offset of field: v4l2_output::reserved"]
        [::core::mem::offset_of!(v4l2_output, reserved) - 60usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_control {
    pub id: __u32,
    pub value: __s32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_control"][::core::mem::size_of::<v4l2_control>() - 8usize];
    ["Alignment of v4l2_control"][::core::mem::align_of::<v4l2_control>() - 4usize];
    ["Offset of field: v4l2_control::id"][::core::mem::offset_of!(v4l2_control, id) - 0usize];
    ["Offset of field: v4l2_control::value"][::core::mem::offset_of!(v4l2_control, value) - 4usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_control {
    pub id: __u32,
    pub size: __u32,
    pub reserved2: [__u32; 1usize],
    pub __anon1: v4l2_ext_control__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_control__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
    pub string: *mut libc::c_char,
    pub p_u8: *mut __u8,
    pub p_u16: *mut __u16,
    pub p_u32: *mut __u32,
    pub ptr: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_control__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_ext_control__bindgen_ty_1>() - 8usize];
    ["Alignment of v4l2_ext_control__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_ext_control__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::value"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, value) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::value64"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, value64) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::string"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, string) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::p_u8"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, p_u8) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::p_u16"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, p_u16) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::p_u32"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, p_u32) - 0usize];
    ["Offset of field: v4l2_ext_control__bindgen_ty_1::ptr"]
        [::core::mem::offset_of!(v4l2_ext_control__bindgen_ty_1, ptr) - 0usize];
};
impl Default for v4l2_ext_control__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_control"][::core::mem::size_of::<v4l2_ext_control>() - 20usize];
    ["Alignment of v4l2_ext_control"][::core::mem::align_of::<v4l2_ext_control>() - 1usize];
    ["Offset of field: v4l2_ext_control::id"]
        [::core::mem::offset_of!(v4l2_ext_control, id) - 0usize];
    ["Offset of field: v4l2_ext_control::size"]
        [::core::mem::offset_of!(v4l2_ext_control, size) - 4usize];
    ["Offset of field: v4l2_ext_control::reserved2"]
        [::core::mem::offset_of!(v4l2_ext_control, reserved2) - 8usize];
};
impl Default for v4l2_ext_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_controls {
    pub __anon1: v4l2_ext_controls__bindgen_ty_1,
    pub count: __u32,
    pub error_idx: __u32,
    pub request_fd: __s32,
    pub reserved: [__u32; 1usize],
    pub controls: *mut v4l2_ext_control,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_controls__bindgen_ty_1 {
    pub ctrl_class: __u32,
    pub which: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_controls__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_ext_controls__bindgen_ty_1>() - 4usize];
    ["Alignment of v4l2_ext_controls__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_ext_controls__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_ext_controls__bindgen_ty_1::ctrl_class"]
        [::core::mem::offset_of!(v4l2_ext_controls__bindgen_ty_1, ctrl_class) - 0usize];
    ["Offset of field: v4l2_ext_controls__bindgen_ty_1::which"]
        [::core::mem::offset_of!(v4l2_ext_controls__bindgen_ty_1, which) - 0usize];
};
impl Default for v4l2_ext_controls__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_ext_controls"][::core::mem::size_of::<v4l2_ext_controls>() - 24usize];
    ["Alignment of v4l2_ext_controls"][::core::mem::align_of::<v4l2_ext_controls>() - 4usize];
    ["Offset of field: v4l2_ext_controls::count"]
        [::core::mem::offset_of!(v4l2_ext_controls, count) - 4usize];
    ["Offset of field: v4l2_ext_controls::error_idx"]
        [::core::mem::offset_of!(v4l2_ext_controls, error_idx) - 8usize];
    ["Offset of field: v4l2_ext_controls::request_fd"]
        [::core::mem::offset_of!(v4l2_ext_controls, request_fd) - 12usize];
    ["Offset of field: v4l2_ext_controls::reserved"]
        [::core::mem::offset_of!(v4l2_ext_controls, reserved) - 16usize];
    ["Offset of field: v4l2_ext_controls::controls"]
        [::core::mem::offset_of!(v4l2_ext_controls, controls) - 20usize];
};
impl Default for v4l2_ext_controls {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl v4l2_ctrl_type {
    pub const V4L2_CTRL_TYPE_U8: v4l2_ctrl_type = v4l2_ctrl_type::V4L2_CTRL_COMPOUND_TYPES;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_queryctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [__u8; 32usize],
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_queryctrl"][::core::mem::size_of::<v4l2_queryctrl>() - 68usize];
    ["Alignment of v4l2_queryctrl"][::core::mem::align_of::<v4l2_queryctrl>() - 4usize];
    ["Offset of field: v4l2_queryctrl::id"][::core::mem::offset_of!(v4l2_queryctrl, id) - 0usize];
    ["Offset of field: v4l2_queryctrl::type_"]
        [::core::mem::offset_of!(v4l2_queryctrl, type_) - 4usize];
    ["Offset of field: v4l2_queryctrl::name"]
        [::core::mem::offset_of!(v4l2_queryctrl, name) - 8usize];
    ["Offset of field: v4l2_queryctrl::minimum"]
        [::core::mem::offset_of!(v4l2_queryctrl, minimum) - 40usize];
    ["Offset of field: v4l2_queryctrl::maximum"]
        [::core::mem::offset_of!(v4l2_queryctrl, maximum) - 44usize];
    ["Offset of field: v4l2_queryctrl::step"]
        [::core::mem::offset_of!(v4l2_queryctrl, step) - 48usize];
    ["Offset of field: v4l2_queryctrl::default_value"]
        [::core::mem::offset_of!(v4l2_queryctrl, default_value) - 52usize];
    ["Offset of field: v4l2_queryctrl::flags"]
        [::core::mem::offset_of!(v4l2_queryctrl, flags) - 56usize];
    ["Offset of field: v4l2_queryctrl::reserved"]
        [::core::mem::offset_of!(v4l2_queryctrl, reserved) - 60usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_query_ext_ctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [libc::c_char; 32usize],
    pub minimum: __s64,
    pub maximum: __s64,
    pub step: __u64,
    pub default_value: __s64,
    pub flags: __u32,
    pub elem_size: __u32,
    pub elems: __u32,
    pub nr_of_dims: __u32,
    pub dims: [__u32; 4usize],
    pub reserved: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_query_ext_ctrl"][::core::mem::size_of::<v4l2_query_ext_ctrl>() - 232usize];
    ["Alignment of v4l2_query_ext_ctrl"][::core::mem::align_of::<v4l2_query_ext_ctrl>() - 8usize];
    ["Offset of field: v4l2_query_ext_ctrl::id"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, id) - 0usize];
    ["Offset of field: v4l2_query_ext_ctrl::type_"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, type_) - 4usize];
    ["Offset of field: v4l2_query_ext_ctrl::name"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, name) - 8usize];
    ["Offset of field: v4l2_query_ext_ctrl::minimum"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, minimum) - 40usize];
    ["Offset of field: v4l2_query_ext_ctrl::maximum"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, maximum) - 48usize];
    ["Offset of field: v4l2_query_ext_ctrl::step"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, step) - 56usize];
    ["Offset of field: v4l2_query_ext_ctrl::default_value"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, default_value) - 64usize];
    ["Offset of field: v4l2_query_ext_ctrl::flags"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, flags) - 72usize];
    ["Offset of field: v4l2_query_ext_ctrl::elem_size"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, elem_size) - 76usize];
    ["Offset of field: v4l2_query_ext_ctrl::elems"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, elems) - 80usize];
    ["Offset of field: v4l2_query_ext_ctrl::nr_of_dims"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, nr_of_dims) - 84usize];
    ["Offset of field: v4l2_query_ext_ctrl::dims"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, dims) - 88usize];
    ["Offset of field: v4l2_query_ext_ctrl::reserved"]
        [::core::mem::offset_of!(v4l2_query_ext_ctrl, reserved) - 104usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_querymenu {
    pub id: __u32,
    pub index: __u32,
    pub __anon1: v4l2_querymenu__bindgen_ty_1,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_querymenu__bindgen_ty_1 {
    pub name: [__u8; 32usize],
    pub value: __s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_querymenu__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_querymenu__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_querymenu__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_querymenu__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_querymenu__bindgen_ty_1::name"]
        [::core::mem::offset_of!(v4l2_querymenu__bindgen_ty_1, name) - 0usize];
    ["Offset of field: v4l2_querymenu__bindgen_ty_1::value"]
        [::core::mem::offset_of!(v4l2_querymenu__bindgen_ty_1, value) - 0usize];
};
impl Default for v4l2_querymenu__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_querymenu"][::core::mem::size_of::<v4l2_querymenu>() - 44usize];
    ["Alignment of v4l2_querymenu"][::core::mem::align_of::<v4l2_querymenu>() - 1usize];
    ["Offset of field: v4l2_querymenu::id"][::core::mem::offset_of!(v4l2_querymenu, id) - 0usize];
    ["Offset of field: v4l2_querymenu::index"]
        [::core::mem::offset_of!(v4l2_querymenu, index) - 4usize];
    ["Offset of field: v4l2_querymenu::reserved"]
        [::core::mem::offset_of!(v4l2_querymenu, reserved) - 40usize];
};
impl Default for v4l2_querymenu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_tuner {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub rxsubchans: __u32,
    pub audmode: __u32,
    pub signal: __s32,
    pub afc: __s32,
    pub reserved: [__u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_tuner"][::core::mem::size_of::<v4l2_tuner>() - 84usize];
    ["Alignment of v4l2_tuner"][::core::mem::align_of::<v4l2_tuner>() - 4usize];
    ["Offset of field: v4l2_tuner::index"][::core::mem::offset_of!(v4l2_tuner, index) - 0usize];
    ["Offset of field: v4l2_tuner::name"][::core::mem::offset_of!(v4l2_tuner, name) - 4usize];
    ["Offset of field: v4l2_tuner::type_"][::core::mem::offset_of!(v4l2_tuner, type_) - 36usize];
    ["Offset of field: v4l2_tuner::capability"]
        [::core::mem::offset_of!(v4l2_tuner, capability) - 40usize];
    ["Offset of field: v4l2_tuner::rangelow"]
        [::core::mem::offset_of!(v4l2_tuner, rangelow) - 44usize];
    ["Offset of field: v4l2_tuner::rangehigh"]
        [::core::mem::offset_of!(v4l2_tuner, rangehigh) - 48usize];
    ["Offset of field: v4l2_tuner::rxsubchans"]
        [::core::mem::offset_of!(v4l2_tuner, rxsubchans) - 52usize];
    ["Offset of field: v4l2_tuner::audmode"]
        [::core::mem::offset_of!(v4l2_tuner, audmode) - 56usize];
    ["Offset of field: v4l2_tuner::signal"][::core::mem::offset_of!(v4l2_tuner, signal) - 60usize];
    ["Offset of field: v4l2_tuner::afc"][::core::mem::offset_of!(v4l2_tuner, afc) - 64usize];
    ["Offset of field: v4l2_tuner::reserved"]
        [::core::mem::offset_of!(v4l2_tuner, reserved) - 68usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_modulator {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub txsubchans: __u32,
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_modulator"][::core::mem::size_of::<v4l2_modulator>() - 68usize];
    ["Alignment of v4l2_modulator"][::core::mem::align_of::<v4l2_modulator>() - 4usize];
    ["Offset of field: v4l2_modulator::index"]
        [::core::mem::offset_of!(v4l2_modulator, index) - 0usize];
    ["Offset of field: v4l2_modulator::name"]
        [::core::mem::offset_of!(v4l2_modulator, name) - 4usize];
    ["Offset of field: v4l2_modulator::capability"]
        [::core::mem::offset_of!(v4l2_modulator, capability) - 36usize];
    ["Offset of field: v4l2_modulator::rangelow"]
        [::core::mem::offset_of!(v4l2_modulator, rangelow) - 40usize];
    ["Offset of field: v4l2_modulator::rangehigh"]
        [::core::mem::offset_of!(v4l2_modulator, rangehigh) - 44usize];
    ["Offset of field: v4l2_modulator::txsubchans"]
        [::core::mem::offset_of!(v4l2_modulator, txsubchans) - 48usize];
    ["Offset of field: v4l2_modulator::type_"]
        [::core::mem::offset_of!(v4l2_modulator, type_) - 52usize];
    ["Offset of field: v4l2_modulator::reserved"]
        [::core::mem::offset_of!(v4l2_modulator, reserved) - 56usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frequency {
    pub tuner: __u32,
    pub type_: __u32,
    pub frequency: __u32,
    pub reserved: [__u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frequency"][::core::mem::size_of::<v4l2_frequency>() - 44usize];
    ["Alignment of v4l2_frequency"][::core::mem::align_of::<v4l2_frequency>() - 4usize];
    ["Offset of field: v4l2_frequency::tuner"]
        [::core::mem::offset_of!(v4l2_frequency, tuner) - 0usize];
    ["Offset of field: v4l2_frequency::type_"]
        [::core::mem::offset_of!(v4l2_frequency, type_) - 4usize];
    ["Offset of field: v4l2_frequency::frequency"]
        [::core::mem::offset_of!(v4l2_frequency, frequency) - 8usize];
    ["Offset of field: v4l2_frequency::reserved"]
        [::core::mem::offset_of!(v4l2_frequency, reserved) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_frequency_band {
    pub tuner: __u32,
    pub type_: __u32,
    pub index: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub modulation: __u32,
    pub reserved: [__u32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_frequency_band"][::core::mem::size_of::<v4l2_frequency_band>() - 64usize];
    ["Alignment of v4l2_frequency_band"][::core::mem::align_of::<v4l2_frequency_band>() - 4usize];
    ["Offset of field: v4l2_frequency_band::tuner"]
        [::core::mem::offset_of!(v4l2_frequency_band, tuner) - 0usize];
    ["Offset of field: v4l2_frequency_band::type_"]
        [::core::mem::offset_of!(v4l2_frequency_band, type_) - 4usize];
    ["Offset of field: v4l2_frequency_band::index"]
        [::core::mem::offset_of!(v4l2_frequency_band, index) - 8usize];
    ["Offset of field: v4l2_frequency_band::capability"]
        [::core::mem::offset_of!(v4l2_frequency_band, capability) - 12usize];
    ["Offset of field: v4l2_frequency_band::rangelow"]
        [::core::mem::offset_of!(v4l2_frequency_band, rangelow) - 16usize];
    ["Offset of field: v4l2_frequency_band::rangehigh"]
        [::core::mem::offset_of!(v4l2_frequency_band, rangehigh) - 20usize];
    ["Offset of field: v4l2_frequency_band::modulation"]
        [::core::mem::offset_of!(v4l2_frequency_band, modulation) - 24usize];
    ["Offset of field: v4l2_frequency_band::reserved"]
        [::core::mem::offset_of!(v4l2_frequency_band, reserved) - 28usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_hw_freq_seek {
    pub tuner: __u32,
    pub type_: __u32,
    pub seek_upward: __u32,
    pub wrap_around: __u32,
    pub spacing: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub reserved: [__u32; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_hw_freq_seek"][::core::mem::size_of::<v4l2_hw_freq_seek>() - 48usize];
    ["Alignment of v4l2_hw_freq_seek"][::core::mem::align_of::<v4l2_hw_freq_seek>() - 4usize];
    ["Offset of field: v4l2_hw_freq_seek::tuner"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, tuner) - 0usize];
    ["Offset of field: v4l2_hw_freq_seek::type_"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, type_) - 4usize];
    ["Offset of field: v4l2_hw_freq_seek::seek_upward"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, seek_upward) - 8usize];
    ["Offset of field: v4l2_hw_freq_seek::wrap_around"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, wrap_around) - 12usize];
    ["Offset of field: v4l2_hw_freq_seek::spacing"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, spacing) - 16usize];
    ["Offset of field: v4l2_hw_freq_seek::rangelow"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, rangelow) - 20usize];
    ["Offset of field: v4l2_hw_freq_seek::rangehigh"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, rangehigh) - 24usize];
    ["Offset of field: v4l2_hw_freq_seek::reserved"]
        [::core::mem::offset_of!(v4l2_hw_freq_seek, reserved) - 28usize];
};
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_rds_data {
    pub lsb: __u8,
    pub msb: __u8,
    pub block: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_rds_data"][::core::mem::size_of::<v4l2_rds_data>() - 3usize];
    ["Alignment of v4l2_rds_data"][::core::mem::align_of::<v4l2_rds_data>() - 1usize];
    ["Offset of field: v4l2_rds_data::lsb"][::core::mem::offset_of!(v4l2_rds_data, lsb) - 0usize];
    ["Offset of field: v4l2_rds_data::msb"][::core::mem::offset_of!(v4l2_rds_data, msb) - 1usize];
    ["Offset of field: v4l2_rds_data::block"]
        [::core::mem::offset_of!(v4l2_rds_data, block) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_audio {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_audio"][::core::mem::size_of::<v4l2_audio>() - 52usize];
    ["Alignment of v4l2_audio"][::core::mem::align_of::<v4l2_audio>() - 4usize];
    ["Offset of field: v4l2_audio::index"][::core::mem::offset_of!(v4l2_audio, index) - 0usize];
    ["Offset of field: v4l2_audio::name"][::core::mem::offset_of!(v4l2_audio, name) - 4usize];
    ["Offset of field: v4l2_audio::capability"]
        [::core::mem::offset_of!(v4l2_audio, capability) - 36usize];
    ["Offset of field: v4l2_audio::mode"][::core::mem::offset_of!(v4l2_audio, mode) - 40usize];
    ["Offset of field: v4l2_audio::reserved"]
        [::core::mem::offset_of!(v4l2_audio, reserved) - 44usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_audioout {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_audioout"][::core::mem::size_of::<v4l2_audioout>() - 52usize];
    ["Alignment of v4l2_audioout"][::core::mem::align_of::<v4l2_audioout>() - 4usize];
    ["Offset of field: v4l2_audioout::index"]
        [::core::mem::offset_of!(v4l2_audioout, index) - 0usize];
    ["Offset of field: v4l2_audioout::name"][::core::mem::offset_of!(v4l2_audioout, name) - 4usize];
    ["Offset of field: v4l2_audioout::capability"]
        [::core::mem::offset_of!(v4l2_audioout, capability) - 36usize];
    ["Offset of field: v4l2_audioout::mode"]
        [::core::mem::offset_of!(v4l2_audioout, mode) - 40usize];
    ["Offset of field: v4l2_audioout::reserved"]
        [::core::mem::offset_of!(v4l2_audioout, reserved) - 44usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_enc_idx_entry {
    pub offset: __u64,
    pub pts: __u64,
    pub length: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_enc_idx_entry"][::core::mem::size_of::<v4l2_enc_idx_entry>() - 32usize];
    ["Alignment of v4l2_enc_idx_entry"][::core::mem::align_of::<v4l2_enc_idx_entry>() - 8usize];
    ["Offset of field: v4l2_enc_idx_entry::offset"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, offset) - 0usize];
    ["Offset of field: v4l2_enc_idx_entry::pts"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, pts) - 8usize];
    ["Offset of field: v4l2_enc_idx_entry::length"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, length) - 16usize];
    ["Offset of field: v4l2_enc_idx_entry::flags"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, flags) - 20usize];
    ["Offset of field: v4l2_enc_idx_entry::reserved"]
        [::core::mem::offset_of!(v4l2_enc_idx_entry, reserved) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_enc_idx {
    pub entries: __u32,
    pub entries_cap: __u32,
    pub reserved: [__u32; 4usize],
    pub entry: [v4l2_enc_idx_entry; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_enc_idx"][::core::mem::size_of::<v4l2_enc_idx>() - 2072usize];
    ["Alignment of v4l2_enc_idx"][::core::mem::align_of::<v4l2_enc_idx>() - 8usize];
    ["Offset of field: v4l2_enc_idx::entries"]
        [::core::mem::offset_of!(v4l2_enc_idx, entries) - 0usize];
    ["Offset of field: v4l2_enc_idx::entries_cap"]
        [::core::mem::offset_of!(v4l2_enc_idx, entries_cap) - 4usize];
    ["Offset of field: v4l2_enc_idx::reserved"]
        [::core::mem::offset_of!(v4l2_enc_idx, reserved) - 8usize];
    ["Offset of field: v4l2_enc_idx::entry"]
        [::core::mem::offset_of!(v4l2_enc_idx, entry) - 24usize];
};
impl Default for v4l2_enc_idx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_encoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __anon1: v4l2_encoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_encoder_cmd__bindgen_ty_1 {
    pub raw: v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub data: [__u32; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1::data"]
        [::core::mem::offset_of!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1, data) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_encoder_cmd__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_encoder_cmd__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_encoder_cmd__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(v4l2_encoder_cmd__bindgen_ty_1, raw) - 0usize];
};
impl Default for v4l2_encoder_cmd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_encoder_cmd"][::core::mem::size_of::<v4l2_encoder_cmd>() - 40usize];
    ["Alignment of v4l2_encoder_cmd"][::core::mem::align_of::<v4l2_encoder_cmd>() - 4usize];
    ["Offset of field: v4l2_encoder_cmd::cmd"]
        [::core::mem::offset_of!(v4l2_encoder_cmd, cmd) - 0usize];
    ["Offset of field: v4l2_encoder_cmd::flags"]
        [::core::mem::offset_of!(v4l2_encoder_cmd, flags) - 4usize];
};
impl Default for v4l2_encoder_cmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_decoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __anon1: v4l2_decoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_decoder_cmd__bindgen_ty_1 {
    pub stop: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1,
    pub start: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2,
    pub raw: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub pts: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1::pts"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1, pts) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2 {
    pub speed: __s32,
    pub format: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2::speed"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2, speed) - 0usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2::format"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2, format) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3 {
    pub data: [__u32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>() - 64usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>() - 4usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3::data"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3, data) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1>() - 64usize];
    ["Alignment of v4l2_decoder_cmd__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1::stop"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1, stop) - 0usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1::start"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1, start) - 0usize];
    ["Offset of field: v4l2_decoder_cmd__bindgen_ty_1::raw"]
        [::core::mem::offset_of!(v4l2_decoder_cmd__bindgen_ty_1, raw) - 0usize];
};
impl Default for v4l2_decoder_cmd__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_decoder_cmd"][::core::mem::size_of::<v4l2_decoder_cmd>() - 72usize];
    ["Alignment of v4l2_decoder_cmd"][::core::mem::align_of::<v4l2_decoder_cmd>() - 8usize];
    ["Offset of field: v4l2_decoder_cmd::cmd"]
        [::core::mem::offset_of!(v4l2_decoder_cmd, cmd) - 0usize];
    ["Offset of field: v4l2_decoder_cmd::flags"]
        [::core::mem::offset_of!(v4l2_decoder_cmd, flags) - 4usize];
};
impl Default for v4l2_decoder_cmd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_vbi_format {
    pub sampling_rate: __u32,
    pub offset: __u32,
    pub samples_per_line: __u32,
    pub sample_format: __u32,
    pub start: [__s32; 2usize],
    pub count: [__u32; 2usize],
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_vbi_format"][::core::mem::size_of::<v4l2_vbi_format>() - 44usize];
    ["Alignment of v4l2_vbi_format"][::core::mem::align_of::<v4l2_vbi_format>() - 4usize];
    ["Offset of field: v4l2_vbi_format::sampling_rate"]
        [::core::mem::offset_of!(v4l2_vbi_format, sampling_rate) - 0usize];
    ["Offset of field: v4l2_vbi_format::offset"]
        [::core::mem::offset_of!(v4l2_vbi_format, offset) - 4usize];
    ["Offset of field: v4l2_vbi_format::samples_per_line"]
        [::core::mem::offset_of!(v4l2_vbi_format, samples_per_line) - 8usize];
    ["Offset of field: v4l2_vbi_format::sample_format"]
        [::core::mem::offset_of!(v4l2_vbi_format, sample_format) - 12usize];
    ["Offset of field: v4l2_vbi_format::start"]
        [::core::mem::offset_of!(v4l2_vbi_format, start) - 16usize];
    ["Offset of field: v4l2_vbi_format::count"]
        [::core::mem::offset_of!(v4l2_vbi_format, count) - 24usize];
    ["Offset of field: v4l2_vbi_format::flags"]
        [::core::mem::offset_of!(v4l2_vbi_format, flags) - 32usize];
    ["Offset of field: v4l2_vbi_format::reserved"]
        [::core::mem::offset_of!(v4l2_vbi_format, reserved) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_sliced_vbi_format {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub io_size: __u32,
    pub reserved: [__u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sliced_vbi_format"][::core::mem::size_of::<v4l2_sliced_vbi_format>() - 112usize];
    ["Alignment of v4l2_sliced_vbi_format"]
        [::core::mem::align_of::<v4l2_sliced_vbi_format>() - 4usize];
    ["Offset of field: v4l2_sliced_vbi_format::service_set"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, service_set) - 0usize];
    ["Offset of field: v4l2_sliced_vbi_format::service_lines"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, service_lines) - 2usize];
    ["Offset of field: v4l2_sliced_vbi_format::io_size"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, io_size) - 100usize];
    ["Offset of field: v4l2_sliced_vbi_format::reserved"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_format, reserved) - 104usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_sliced_vbi_cap {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sliced_vbi_cap"][::core::mem::size_of::<v4l2_sliced_vbi_cap>() - 116usize];
    ["Alignment of v4l2_sliced_vbi_cap"][::core::mem::align_of::<v4l2_sliced_vbi_cap>() - 4usize];
    ["Offset of field: v4l2_sliced_vbi_cap::service_set"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, service_set) - 0usize];
    ["Offset of field: v4l2_sliced_vbi_cap::service_lines"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, service_lines) - 2usize];
    ["Offset of field: v4l2_sliced_vbi_cap::type_"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, type_) - 100usize];
    ["Offset of field: v4l2_sliced_vbi_cap::reserved"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_cap, reserved) - 104usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_data {
    pub id: __u32,
    pub field: __u32,
    pub line: __u32,
    pub reserved: __u32,
    pub data: [__u8; 48usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sliced_vbi_data"][::core::mem::size_of::<v4l2_sliced_vbi_data>() - 64usize];
    ["Alignment of v4l2_sliced_vbi_data"][::core::mem::align_of::<v4l2_sliced_vbi_data>() - 4usize];
    ["Offset of field: v4l2_sliced_vbi_data::id"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, id) - 0usize];
    ["Offset of field: v4l2_sliced_vbi_data::field"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, field) - 4usize];
    ["Offset of field: v4l2_sliced_vbi_data::line"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, line) - 8usize];
    ["Offset of field: v4l2_sliced_vbi_data::reserved"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, reserved) - 12usize];
    ["Offset of field: v4l2_sliced_vbi_data::data"]
        [::core::mem::offset_of!(v4l2_sliced_vbi_data, data) - 16usize];
};
impl Default for v4l2_sliced_vbi_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0_line {
    pub id: __u8,
    pub data: [__u8; 42usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_itv0_line"]
        [::core::mem::size_of::<v4l2_mpeg_vbi_itv0_line>() - 43usize];
    ["Alignment of v4l2_mpeg_vbi_itv0_line"]
        [::core::mem::align_of::<v4l2_mpeg_vbi_itv0_line>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0_line::id"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0_line, id) - 0usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0_line::data"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0_line, data) - 1usize];
};
impl Default for v4l2_mpeg_vbi_itv0_line {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0 {
    pub linemask: [__le32; 2usize],
    pub line: [v4l2_mpeg_vbi_itv0_line; 35usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_itv0"][::core::mem::size_of::<v4l2_mpeg_vbi_itv0>() - 1513usize];
    ["Alignment of v4l2_mpeg_vbi_itv0"][::core::mem::align_of::<v4l2_mpeg_vbi_itv0>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0::linemask"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0, linemask) - 0usize];
    ["Offset of field: v4l2_mpeg_vbi_itv0::line"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_itv0, line) - 8usize];
};
impl Default for v4l2_mpeg_vbi_itv0 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_ITV0 {
    pub line: [v4l2_mpeg_vbi_itv0_line; 36usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_ITV0"][::core::mem::size_of::<v4l2_mpeg_vbi_ITV0>() - 1548usize];
    ["Alignment of v4l2_mpeg_vbi_ITV0"][::core::mem::align_of::<v4l2_mpeg_vbi_ITV0>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_ITV0::line"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_ITV0, line) - 0usize];
};
impl Default for v4l2_mpeg_vbi_ITV0 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_fmt_ivtv {
    pub magic: [__u8; 4usize],
    pub __anon1: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1 {
    pub itv0: v4l2_mpeg_vbi_itv0,
    pub ITV0: v4l2_mpeg_vbi_ITV0,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>() - 1548usize];
    ["Alignment of v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1::itv0"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1, itv0) - 0usize];
    ["Offset of field: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1::ITV0"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1, ITV0) - 0usize];
};
impl Default for v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_mpeg_vbi_fmt_ivtv"]
        [::core::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv>() - 1552usize];
    ["Alignment of v4l2_mpeg_vbi_fmt_ivtv"]
        [::core::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv>() - 1usize];
    ["Offset of field: v4l2_mpeg_vbi_fmt_ivtv::magic"]
        [::core::mem::offset_of!(v4l2_mpeg_vbi_fmt_ivtv, magic) - 0usize];
};
impl Default for v4l2_mpeg_vbi_fmt_ivtv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_plane_pix_format - additional, per-plane format definition\n @sizeimage:\t\tmaximum size in bytes required for data, for which\n\t\t\tthis plane will be used\n @bytesperline:\tdistance in bytes between the leftmost pixels in two\n\t\t\tadjacent lines"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_plane_pix_format {
    pub sizeimage: __u32,
    pub bytesperline: __u32,
    pub reserved: [__u16; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_plane_pix_format"][::core::mem::size_of::<v4l2_plane_pix_format>() - 20usize];
    ["Alignment of v4l2_plane_pix_format"]
        [::core::mem::align_of::<v4l2_plane_pix_format>() - 1usize];
    ["Offset of field: v4l2_plane_pix_format::sizeimage"]
        [::core::mem::offset_of!(v4l2_plane_pix_format, sizeimage) - 0usize];
    ["Offset of field: v4l2_plane_pix_format::bytesperline"]
        [::core::mem::offset_of!(v4l2_plane_pix_format, bytesperline) - 4usize];
    ["Offset of field: v4l2_plane_pix_format::reserved"]
        [::core::mem::offset_of!(v4l2_plane_pix_format, reserved) - 8usize];
};
#[doc = " struct v4l2_pix_format_mplane - multiplanar format definition\n @width:\t\timage width in pixels\n @height:\t\timage height in pixels\n @pixelformat:\tlittle endian four character code (fourcc)\n @field:\t\tenum v4l2_field; field order (for interlaced video)\n @colorspace:\t\tenum v4l2_colorspace; supplemental to pixelformat\n @plane_fmt:\t\tper-plane information\n @num_planes:\t\tnumber of planes for this format\n @flags:\t\tformat flags (V4L2_PIX_FMT_FLAG_*)\n @ycbcr_enc:\t\tenum v4l2_ycbcr_encoding, Y'CbCr encoding\n @quantization:\tenum v4l2_quantization, colorspace quantization\n @xfer_func:\t\tenum v4l2_xfer_func, colorspace transfer function"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format_mplane {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub colorspace: __u32,
    pub plane_fmt: [v4l2_plane_pix_format; 8usize],
    pub num_planes: __u8,
    pub flags: __u8,
    pub __anon1: v4l2_pix_format_mplane__bindgen_ty_1,
    pub quantization: __u8,
    pub xfer_func: __u8,
    pub reserved: [__u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format_mplane__bindgen_ty_1 {
    pub ycbcr_enc: __u8,
    pub hsv_enc: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format_mplane__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_pix_format_mplane__bindgen_ty_1>() - 1usize];
    ["Alignment of v4l2_pix_format_mplane__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_pix_format_mplane__bindgen_ty_1>() - 1usize];
    ["Offset of field: v4l2_pix_format_mplane__bindgen_ty_1::ycbcr_enc"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane__bindgen_ty_1, ycbcr_enc) - 0usize];
    ["Offset of field: v4l2_pix_format_mplane__bindgen_ty_1::hsv_enc"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane__bindgen_ty_1, hsv_enc) - 0usize];
};
impl Default for v4l2_pix_format_mplane__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_pix_format_mplane"][::core::mem::size_of::<v4l2_pix_format_mplane>() - 192usize];
    ["Alignment of v4l2_pix_format_mplane"]
        [::core::mem::align_of::<v4l2_pix_format_mplane>() - 1usize];
    ["Offset of field: v4l2_pix_format_mplane::width"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, width) - 0usize];
    ["Offset of field: v4l2_pix_format_mplane::height"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, height) - 4usize];
    ["Offset of field: v4l2_pix_format_mplane::pixelformat"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, pixelformat) - 8usize];
    ["Offset of field: v4l2_pix_format_mplane::field"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, field) - 12usize];
    ["Offset of field: v4l2_pix_format_mplane::colorspace"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, colorspace) - 16usize];
    ["Offset of field: v4l2_pix_format_mplane::plane_fmt"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, plane_fmt) - 20usize];
    ["Offset of field: v4l2_pix_format_mplane::num_planes"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, num_planes) - 180usize];
    ["Offset of field: v4l2_pix_format_mplane::flags"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, flags) - 181usize];
    ["Offset of field: v4l2_pix_format_mplane::quantization"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, quantization) - 183usize];
    ["Offset of field: v4l2_pix_format_mplane::xfer_func"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, xfer_func) - 184usize];
    ["Offset of field: v4l2_pix_format_mplane::reserved"]
        [::core::mem::offset_of!(v4l2_pix_format_mplane, reserved) - 185usize];
};
impl Default for v4l2_pix_format_mplane {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_sdr_format - SDR format definition\n @pixelformat:\tlittle endian four character code (fourcc)\n @buffersize:\t\tmaximum size in bytes required for data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_sdr_format {
    pub pixelformat: __u32,
    pub buffersize: __u32,
    pub reserved: [__u8; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_sdr_format"][::core::mem::size_of::<v4l2_sdr_format>() - 32usize];
    ["Alignment of v4l2_sdr_format"][::core::mem::align_of::<v4l2_sdr_format>() - 1usize];
    ["Offset of field: v4l2_sdr_format::pixelformat"]
        [::core::mem::offset_of!(v4l2_sdr_format, pixelformat) - 0usize];
    ["Offset of field: v4l2_sdr_format::buffersize"]
        [::core::mem::offset_of!(v4l2_sdr_format, buffersize) - 4usize];
    ["Offset of field: v4l2_sdr_format::reserved"]
        [::core::mem::offset_of!(v4l2_sdr_format, reserved) - 8usize];
};
#[doc = " struct v4l2_meta_format - metadata format definition\n @dataformat:\t\tlittle endian four character code (fourcc)\n @buffersize:\t\tmaximum size in bytes required for data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_meta_format {
    pub dataformat: __u32,
    pub buffersize: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_meta_format"][::core::mem::size_of::<v4l2_meta_format>() - 8usize];
    ["Alignment of v4l2_meta_format"][::core::mem::align_of::<v4l2_meta_format>() - 1usize];
    ["Offset of field: v4l2_meta_format::dataformat"]
        [::core::mem::offset_of!(v4l2_meta_format, dataformat) - 0usize];
    ["Offset of field: v4l2_meta_format::buffersize"]
        [::core::mem::offset_of!(v4l2_meta_format, buffersize) - 4usize];
};
#[doc = " struct v4l2_format - stream data format\n @type:\tenum v4l2_buf_type; type of the data stream\n @pix:\tdefinition of an image format\n @pix_mp:\tdefinition of a multiplanar image format\n @win:\tdefinition of an overlaid image\n @vbi:\traw VBI capture or output parameters\n @sliced:\tsliced VBI capture or output parameters\n @raw_data:\tplaceholder for future extensions and custom formats"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_format {
    pub type_: __u32,
    pub fmt: v4l2_format__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_format__bindgen_ty_1 {
    pub pix: v4l2_pix_format,
    pub pix_mp: v4l2_pix_format_mplane,
    pub win: v4l2_window,
    pub vbi: v4l2_vbi_format,
    pub sliced: v4l2_sliced_vbi_format,
    pub sdr: v4l2_sdr_format,
    pub meta: v4l2_meta_format,
    pub raw_data: [__u8; 200usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_format__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_format__bindgen_ty_1>() - 200usize];
    ["Alignment of v4l2_format__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_format__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::pix"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, pix) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::pix_mp"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, pix_mp) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::win"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, win) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::vbi"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, vbi) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::sliced"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, sliced) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::sdr"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, sdr) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::meta"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, meta) - 0usize];
    ["Offset of field: v4l2_format__bindgen_ty_1::raw_data"]
        [::core::mem::offset_of!(v4l2_format__bindgen_ty_1, raw_data) - 0usize];
};
impl Default for v4l2_format__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_format"][::core::mem::size_of::<v4l2_format>() - 204usize];
    ["Alignment of v4l2_format"][::core::mem::align_of::<v4l2_format>() - 4usize];
    ["Offset of field: v4l2_format::type_"][::core::mem::offset_of!(v4l2_format, type_) - 0usize];
    ["Offset of field: v4l2_format::fmt"][::core::mem::offset_of!(v4l2_format, fmt) - 4usize];
};
impl Default for v4l2_format {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_streamparm {
    pub type_: __u32,
    pub parm: v4l2_streamparm__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_streamparm__bindgen_ty_1 {
    pub capture: v4l2_captureparm,
    pub output: v4l2_outputparm,
    pub raw_data: [__u8; 200usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_streamparm__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_streamparm__bindgen_ty_1>() - 200usize];
    ["Alignment of v4l2_streamparm__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_streamparm__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_streamparm__bindgen_ty_1::capture"]
        [::core::mem::offset_of!(v4l2_streamparm__bindgen_ty_1, capture) - 0usize];
    ["Offset of field: v4l2_streamparm__bindgen_ty_1::output"]
        [::core::mem::offset_of!(v4l2_streamparm__bindgen_ty_1, output) - 0usize];
    ["Offset of field: v4l2_streamparm__bindgen_ty_1::raw_data"]
        [::core::mem::offset_of!(v4l2_streamparm__bindgen_ty_1, raw_data) - 0usize];
};
impl Default for v4l2_streamparm__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_streamparm"][::core::mem::size_of::<v4l2_streamparm>() - 204usize];
    ["Alignment of v4l2_streamparm"][::core::mem::align_of::<v4l2_streamparm>() - 4usize];
    ["Offset of field: v4l2_streamparm::type_"]
        [::core::mem::offset_of!(v4l2_streamparm, type_) - 0usize];
    ["Offset of field: v4l2_streamparm::parm"]
        [::core::mem::offset_of!(v4l2_streamparm, parm) - 4usize];
};
impl Default for v4l2_streamparm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_vsync {
    pub field: __u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_vsync"][::core::mem::size_of::<v4l2_event_vsync>() - 1usize];
    ["Alignment of v4l2_event_vsync"][::core::mem::align_of::<v4l2_event_vsync>() - 1usize];
    ["Offset of field: v4l2_event_vsync::field"]
        [::core::mem::offset_of!(v4l2_event_vsync, field) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event_ctrl {
    pub changes: __u32,
    pub type_: __u32,
    pub __anon1: v4l2_event_ctrl__bindgen_ty_1,
    pub flags: __u32,
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event_ctrl__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_ctrl__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_event_ctrl__bindgen_ty_1>() - 8usize];
    ["Alignment of v4l2_event_ctrl__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_event_ctrl__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_event_ctrl__bindgen_ty_1::value"]
        [::core::mem::offset_of!(v4l2_event_ctrl__bindgen_ty_1, value) - 0usize];
    ["Offset of field: v4l2_event_ctrl__bindgen_ty_1::value64"]
        [::core::mem::offset_of!(v4l2_event_ctrl__bindgen_ty_1, value64) - 0usize];
};
impl Default for v4l2_event_ctrl__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_ctrl"][::core::mem::size_of::<v4l2_event_ctrl>() - 40usize];
    ["Alignment of v4l2_event_ctrl"][::core::mem::align_of::<v4l2_event_ctrl>() - 8usize];
    ["Offset of field: v4l2_event_ctrl::changes"]
        [::core::mem::offset_of!(v4l2_event_ctrl, changes) - 0usize];
    ["Offset of field: v4l2_event_ctrl::type_"]
        [::core::mem::offset_of!(v4l2_event_ctrl, type_) - 4usize];
    ["Offset of field: v4l2_event_ctrl::flags"]
        [::core::mem::offset_of!(v4l2_event_ctrl, flags) - 16usize];
    ["Offset of field: v4l2_event_ctrl::minimum"]
        [::core::mem::offset_of!(v4l2_event_ctrl, minimum) - 20usize];
    ["Offset of field: v4l2_event_ctrl::maximum"]
        [::core::mem::offset_of!(v4l2_event_ctrl, maximum) - 24usize];
    ["Offset of field: v4l2_event_ctrl::step"]
        [::core::mem::offset_of!(v4l2_event_ctrl, step) - 28usize];
    ["Offset of field: v4l2_event_ctrl::default_value"]
        [::core::mem::offset_of!(v4l2_event_ctrl, default_value) - 32usize];
};
impl Default for v4l2_event_ctrl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_frame_sync {
    pub frame_sequence: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_frame_sync"][::core::mem::size_of::<v4l2_event_frame_sync>() - 4usize];
    ["Alignment of v4l2_event_frame_sync"]
        [::core::mem::align_of::<v4l2_event_frame_sync>() - 4usize];
    ["Offset of field: v4l2_event_frame_sync::frame_sequence"]
        [::core::mem::offset_of!(v4l2_event_frame_sync, frame_sequence) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_src_change {
    pub changes: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_src_change"][::core::mem::size_of::<v4l2_event_src_change>() - 4usize];
    ["Alignment of v4l2_event_src_change"]
        [::core::mem::align_of::<v4l2_event_src_change>() - 4usize];
    ["Offset of field: v4l2_event_src_change::changes"]
        [::core::mem::offset_of!(v4l2_event_src_change, changes) - 0usize];
};
#[doc = " struct v4l2_event_motion_det - motion detection event\n @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the\n                     frame_sequence field is valid.\n @frame_sequence:    the frame sequence number associated with this event.\n @region_mask:       which regions detected motion."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_motion_det {
    pub flags: __u32,
    pub frame_sequence: __u32,
    pub region_mask: __u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_motion_det"][::core::mem::size_of::<v4l2_event_motion_det>() - 12usize];
    ["Alignment of v4l2_event_motion_det"]
        [::core::mem::align_of::<v4l2_event_motion_det>() - 4usize];
    ["Offset of field: v4l2_event_motion_det::flags"]
        [::core::mem::offset_of!(v4l2_event_motion_det, flags) - 0usize];
    ["Offset of field: v4l2_event_motion_det::frame_sequence"]
        [::core::mem::offset_of!(v4l2_event_motion_det, frame_sequence) - 4usize];
    ["Offset of field: v4l2_event_motion_det::region_mask"]
        [::core::mem::offset_of!(v4l2_event_motion_det, region_mask) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event {
    pub type_: __u32,
    pub u: v4l2_event__bindgen_ty_1,
    pub pending: __u32,
    pub sequence: __u32,
    pub timestamp: timespec,
    pub id: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event__bindgen_ty_1 {
    pub vsync: v4l2_event_vsync,
    pub ctrl: v4l2_event_ctrl,
    pub frame_sync: v4l2_event_frame_sync,
    pub src_change: v4l2_event_src_change,
    pub motion_det: v4l2_event_motion_det,
    pub data: [__u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_event__bindgen_ty_1>() - 64usize];
    ["Alignment of v4l2_event__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_event__bindgen_ty_1>() - 8usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::vsync"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, vsync) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::ctrl"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, ctrl) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::frame_sync"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, frame_sync) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::src_change"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, src_change) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::motion_det"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, motion_det) - 0usize];
    ["Offset of field: v4l2_event__bindgen_ty_1::data"]
        [::core::mem::offset_of!(v4l2_event__bindgen_ty_1, data) - 0usize];
};
impl Default for v4l2_event__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event"][::core::mem::size_of::<v4l2_event>() - 128usize];
    ["Alignment of v4l2_event"][::core::mem::align_of::<v4l2_event>() - 8usize];
    ["Offset of field: v4l2_event::type_"][::core::mem::offset_of!(v4l2_event, type_) - 0usize];
    ["Offset of field: v4l2_event::u"][::core::mem::offset_of!(v4l2_event, u) - 8usize];
    ["Offset of field: v4l2_event::pending"]
        [::core::mem::offset_of!(v4l2_event, pending) - 72usize];
    ["Offset of field: v4l2_event::sequence"]
        [::core::mem::offset_of!(v4l2_event, sequence) - 76usize];
    ["Offset of field: v4l2_event::timestamp"]
        [::core::mem::offset_of!(v4l2_event, timestamp) - 80usize];
    ["Offset of field: v4l2_event::id"][::core::mem::offset_of!(v4l2_event, id) - 88usize];
    ["Offset of field: v4l2_event::reserved"]
        [::core::mem::offset_of!(v4l2_event, reserved) - 92usize];
};
impl Default for v4l2_event {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct v4l2_event_subscription {
    pub type_: __u32,
    pub id: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_event_subscription"]
        [::core::mem::size_of::<v4l2_event_subscription>() - 32usize];
    ["Alignment of v4l2_event_subscription"]
        [::core::mem::align_of::<v4l2_event_subscription>() - 4usize];
    ["Offset of field: v4l2_event_subscription::type_"]
        [::core::mem::offset_of!(v4l2_event_subscription, type_) - 0usize];
    ["Offset of field: v4l2_event_subscription::id"]
        [::core::mem::offset_of!(v4l2_event_subscription, id) - 4usize];
    ["Offset of field: v4l2_event_subscription::flags"]
        [::core::mem::offset_of!(v4l2_event_subscription, flags) - 8usize];
    ["Offset of field: v4l2_event_subscription::reserved"]
        [::core::mem::offset_of!(v4l2_event_subscription, reserved) - 12usize];
};
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_match {
    pub type_: __u32,
    pub __anon1: v4l2_dbg_match__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dbg_match__bindgen_ty_1 {
    pub addr: __u32,
    pub name: [libc::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_match__bindgen_ty_1"]
        [::core::mem::size_of::<v4l2_dbg_match__bindgen_ty_1>() - 32usize];
    ["Alignment of v4l2_dbg_match__bindgen_ty_1"]
        [::core::mem::align_of::<v4l2_dbg_match__bindgen_ty_1>() - 4usize];
    ["Offset of field: v4l2_dbg_match__bindgen_ty_1::addr"]
        [::core::mem::offset_of!(v4l2_dbg_match__bindgen_ty_1, addr) - 0usize];
    ["Offset of field: v4l2_dbg_match__bindgen_ty_1::name"]
        [::core::mem::offset_of!(v4l2_dbg_match__bindgen_ty_1, name) - 0usize];
};
impl Default for v4l2_dbg_match__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_match"][::core::mem::size_of::<v4l2_dbg_match>() - 36usize];
    ["Alignment of v4l2_dbg_match"][::core::mem::align_of::<v4l2_dbg_match>() - 1usize];
    ["Offset of field: v4l2_dbg_match::type_"]
        [::core::mem::offset_of!(v4l2_dbg_match, type_) - 0usize];
};
impl Default for v4l2_dbg_match {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_register {
    pub match_: v4l2_dbg_match,
    pub size: __u32,
    pub reg: __u64,
    pub val: __u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_register"][::core::mem::size_of::<v4l2_dbg_register>() - 56usize];
    ["Alignment of v4l2_dbg_register"][::core::mem::align_of::<v4l2_dbg_register>() - 1usize];
    ["Offset of field: v4l2_dbg_register::match_"]
        [::core::mem::offset_of!(v4l2_dbg_register, match_) - 0usize];
    ["Offset of field: v4l2_dbg_register::size"]
        [::core::mem::offset_of!(v4l2_dbg_register, size) - 36usize];
    ["Offset of field: v4l2_dbg_register::reg"]
        [::core::mem::offset_of!(v4l2_dbg_register, reg) - 40usize];
    ["Offset of field: v4l2_dbg_register::val"]
        [::core::mem::offset_of!(v4l2_dbg_register, val) - 48usize];
};
impl Default for v4l2_dbg_register {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_chip_info {
    pub match_: v4l2_dbg_match,
    pub name: [libc::c_char; 32usize],
    pub flags: __u32,
    pub reserved: [__u32; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_dbg_chip_info"][::core::mem::size_of::<v4l2_dbg_chip_info>() - 200usize];
    ["Alignment of v4l2_dbg_chip_info"][::core::mem::align_of::<v4l2_dbg_chip_info>() - 1usize];
    ["Offset of field: v4l2_dbg_chip_info::match_"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, match_) - 0usize];
    ["Offset of field: v4l2_dbg_chip_info::name"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, name) - 36usize];
    ["Offset of field: v4l2_dbg_chip_info::flags"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, flags) - 68usize];
    ["Offset of field: v4l2_dbg_chip_info::reserved"]
        [::core::mem::offset_of!(v4l2_dbg_chip_info, reserved) - 72usize];
};
impl Default for v4l2_dbg_chip_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument\n @index:\ton return, index of the first created buffer\n @count:\tentry: number of requested buffers,\n\t\treturn: number of created buffers\n @memory:\tenum v4l2_memory; buffer memory type\n @format:\tframe format, for which buffers are requested\n @capabilities: capabilities of this buffer type.\n @reserved:\tfuture extensions"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_create_buffers {
    pub index: __u32,
    pub count: __u32,
    pub memory: __u32,
    pub format: v4l2_format,
    pub capabilities: __u32,
    pub reserved: [__u32; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of v4l2_create_buffers"][::core::mem::size_of::<v4l2_create_buffers>() - 248usize];
    ["Alignment of v4l2_create_buffers"][::core::mem::align_of::<v4l2_create_buffers>() - 4usize];
    ["Offset of field: v4l2_create_buffers::index"]
        [::core::mem::offset_of!(v4l2_create_buffers, index) - 0usize];
    ["Offset of field: v4l2_create_buffers::count"]
        [::core::mem::offset_of!(v4l2_create_buffers, count) - 4usize];
    ["Offset of field: v4l2_create_buffers::memory"]
        [::core::mem::offset_of!(v4l2_create_buffers, memory) - 8usize];
    ["Offset of field: v4l2_create_buffers::format"]
        [::core::mem::offset_of!(v4l2_create_buffers, format) - 12usize];
    ["Offset of field: v4l2_create_buffers::capabilities"]
        [::core::mem::offset_of!(v4l2_create_buffers, capabilities) - 216usize];
    ["Offset of field: v4l2_create_buffers::reserved"]
        [::core::mem::offset_of!(v4l2_create_buffers, reserved) - 220usize];
};
impl Default for v4l2_create_buffers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::core::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::core::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::core::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::core::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::core::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::core::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::core::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::core::mem::size_of::<_G_fpos_t>() - 12usize];
    ["Alignment of _G_fpos_t"][::core::mem::align_of::<_G_fpos_t>() - 4usize];
    ["Offset of field: _G_fpos_t::__pos"][::core::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::core::mem::offset_of!(_G_fpos_t, __state) - 4usize];
};
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::core::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::core::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::core::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::core::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::core::mem::size_of::<_IO_FILE>() - 152usize];
    ["Alignment of _IO_FILE"][::core::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::core::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::core::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 4usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_read_end) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_read_base) - 12usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_write_base) - 16usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::core::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 20usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_write_end) - 24usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_buf_base) - 28usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_buf_end) - 32usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_save_base) - 36usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::core::mem::offset_of!(_IO_FILE, _IO_backup_base) - 40usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::core::mem::offset_of!(_IO_FILE, _IO_save_end) - 44usize];
    ["Offset of field: _IO_FILE::_markers"][::core::mem::offset_of!(_IO_FILE, _markers) - 48usize];
    ["Offset of field: _IO_FILE::_chain"][::core::mem::offset_of!(_IO_FILE, _chain) - 52usize];
    ["Offset of field: _IO_FILE::_fileno"][::core::mem::offset_of!(_IO_FILE, _fileno) - 56usize];
    ["Offset of field: _IO_FILE::_flags2"][::core::mem::offset_of!(_IO_FILE, _flags2) - 60usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::core::mem::offset_of!(_IO_FILE, _old_offset) - 64usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::core::mem::offset_of!(_IO_FILE, _cur_column) - 68usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::core::mem::offset_of!(_IO_FILE, _vtable_offset) - 70usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::core::mem::offset_of!(_IO_FILE, _shortbuf) - 71usize];
    ["Offset of field: _IO_FILE::_lock"][::core::mem::offset_of!(_IO_FILE, _lock) - 72usize];
    ["Offset of field: _IO_FILE::_offset"][::core::mem::offset_of!(_IO_FILE, _offset) - 80usize];
    ["Offset of field: _IO_FILE::_codecvt"][::core::mem::offset_of!(_IO_FILE, _codecvt) - 88usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::core::mem::offset_of!(_IO_FILE, _wide_data) - 92usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::core::mem::offset_of!(_IO_FILE, _freeres_list) - 96usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::core::mem::offset_of!(_IO_FILE, _freeres_buf) - 100usize];
    ["Offset of field: _IO_FILE::__pad5"][::core::mem::offset_of!(_IO_FILE, __pad5) - 104usize];
    ["Offset of field: _IO_FILE::_mode"][::core::mem::offset_of!(_IO_FILE, _mode) - 108usize];
    ["Offset of field: _IO_FILE::_unused2"][::core::mem::offset_of!(_IO_FILE, _unused2) - 112usize];
};
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: libc::c_int,
        __old: *const libc::c_char,
        __newfd: libc::c_int,
        __new: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __pfx: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const libc::c_char,
        __modes: *const libc::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut libc::c_void,
        __len: usize,
        __modes: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut libc::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const libc::c_char, __arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_uint,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_uint,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: libc::c_int,
        __fmt: *const libc::c_char,
        __arg: __gnuc_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(__s: *const libc::c_char, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, __arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const libc::c_char, __arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(__w: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut libc::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: libc::c_uint,
        __n: libc::c_uint,
        __stream: *mut FILE,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: libc::c_uint,
        __n: libc::c_uint,
        __s: *mut FILE,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const libc::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const libc::c_char);
}
extern "C" {
    pub static mut sys_nerr: libc::c_int;
}
extern "C" {
    pub static sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: libc::c_int) -> libc::c_int;
}
#[repr(u32)]
#[doc = " IMP ID."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPDeviceID {
    #[doc = "< "]
    DEV_ID_FS = 0,
    #[doc = "< "]
    DEV_ID_ENC = 1,
    #[doc = "< "]
    DEV_ID_DEC = 2,
    #[doc = "< "]
    DEV_ID_IVS = 3,
    #[doc = "< "]
    DEV_ID_OSD = 4,
    #[doc = "< FB FG1Direct"]
    DEV_ID_FG1DIRECT = 5,
    DEV_ID_RESERVED_START = 6,
    DEV_ID_RESERVED_END = 23,
    NR_MAX_DEVICES = 24,
}
#[doc = " IMPCell."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPCell {
    #[doc = "< ID"]
    pub deviceID: IMPDeviceID,
    #[doc = "< ID"]
    pub groupID: libc::c_int,
    #[doc = "< ID"]
    pub outputID: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPCell"][::core::mem::size_of::<IMPCell>() - 12usize];
    ["Alignment of IMPCell"][::core::mem::align_of::<IMPCell>() - 4usize];
    ["Offset of field: IMPCell::deviceID"][::core::mem::offset_of!(IMPCell, deviceID) - 0usize];
    ["Offset of field: IMPCell::groupID"][::core::mem::offset_of!(IMPCell, groupID) - 4usize];
    ["Offset of field: IMPCell::outputID"][::core::mem::offset_of!(IMPCell, outputID) - 8usize];
};
impl Default for IMPCell {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " IMP."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct IMPFrameInfo {
    #[doc = "< "]
    pub index: libc::c_int,
    #[doc = "< PoolID"]
    pub pool_idx: libc::c_int,
    #[doc = "< "]
    pub width: u32,
    #[doc = "< "]
    pub height: u32,
    #[doc = "< "]
    pub pixfmt: u32,
    #[doc = "< "]
    pub size: u32,
    #[doc = "< "]
    pub phyAddr: u32,
    #[doc = "< "]
    pub virAddr: u32,
    #[doc = "< "]
    pub direct_phyAddr: u32,
    #[doc = "< "]
    pub timeStamp: i64,
    #[doc = "< dq"]
    pub timeStamp_ivdc: i64,
    #[doc = "< "]
    pub priv_: __IncompleteArrayField<u32>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFrameInfo"][::core::mem::size_of::<IMPFrameInfo>() - 56usize];
    ["Alignment of IMPFrameInfo"][::core::mem::align_of::<IMPFrameInfo>() - 8usize];
    ["Offset of field: IMPFrameInfo::index"][::core::mem::offset_of!(IMPFrameInfo, index) - 0usize];
    ["Offset of field: IMPFrameInfo::pool_idx"]
        [::core::mem::offset_of!(IMPFrameInfo, pool_idx) - 4usize];
    ["Offset of field: IMPFrameInfo::width"][::core::mem::offset_of!(IMPFrameInfo, width) - 8usize];
    ["Offset of field: IMPFrameInfo::height"]
        [::core::mem::offset_of!(IMPFrameInfo, height) - 12usize];
    ["Offset of field: IMPFrameInfo::pixfmt"]
        [::core::mem::offset_of!(IMPFrameInfo, pixfmt) - 16usize];
    ["Offset of field: IMPFrameInfo::size"][::core::mem::offset_of!(IMPFrameInfo, size) - 20usize];
    ["Offset of field: IMPFrameInfo::phyAddr"]
        [::core::mem::offset_of!(IMPFrameInfo, phyAddr) - 24usize];
    ["Offset of field: IMPFrameInfo::virAddr"]
        [::core::mem::offset_of!(IMPFrameInfo, virAddr) - 28usize];
    ["Offset of field: IMPFrameInfo::direct_phyAddr"]
        [::core::mem::offset_of!(IMPFrameInfo, direct_phyAddr) - 32usize];
    ["Offset of field: IMPFrameInfo::timeStamp"]
        [::core::mem::offset_of!(IMPFrameInfo, timeStamp) - 40usize];
    ["Offset of field: IMPFrameInfo::timeStamp_ivdc"]
        [::core::mem::offset_of!(IMPFrameInfo, timeStamp_ivdc) - 48usize];
    ["Offset of field: IMPFrameInfo::priv_"]
        [::core::mem::offset_of!(IMPFrameInfo, priv_) - 56usize];
};
#[doc = " IMP."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPFrameTimestamp {
    #[doc = "< "]
    pub ts: u64,
    #[doc = "< "]
    pub minus: u64,
    #[doc = "< "]
    pub plus: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFrameTimestamp"][::core::mem::size_of::<IMPFrameTimestamp>() - 24usize];
    ["Alignment of IMPFrameTimestamp"][::core::mem::align_of::<IMPFrameTimestamp>() - 8usize];
    ["Offset of field: IMPFrameTimestamp::ts"]
        [::core::mem::offset_of!(IMPFrameTimestamp, ts) - 0usize];
    ["Offset of field: IMPFrameTimestamp::minus"]
        [::core::mem::offset_of!(IMPFrameTimestamp, minus) - 8usize];
    ["Offset of field: IMPFrameTimestamp::plus"]
        [::core::mem::offset_of!(IMPFrameTimestamp, plus) - 16usize];
};
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPPayloadType {
    #[doc = "< JPEG"]
    PT_JPEG = 0,
    #[doc = "< H264"]
    PT_H264 = 1,
    #[doc = "< H265"]
    PT_H265 = 2,
}
#[repr(u32)]
#[doc = " IMP."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPPixelFormat {
    #[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
    PIX_FMT_YUV420P = 0,
    #[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
    PIX_FMT_YUYV422 = 1,
    #[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
    PIX_FMT_UYVY422 = 2,
    #[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
    PIX_FMT_YUV422P = 3,
    #[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
    PIX_FMT_YUV444P = 4,
    #[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
    PIX_FMT_YUV410P = 5,
    #[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
    PIX_FMT_YUV411P = 6,
    #[doc = "<\t   Y\t    ,  8bpp"]
    PIX_FMT_GRAY8 = 7,
    #[doc = "<\t   Y\t    ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
    PIX_FMT_MONOWHITE = 8,
    #[doc = "<\t   Y\t    ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
    PIX_FMT_MONOBLACK = 9,
    #[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
    PIX_FMT_NV12 = 10,
    #[doc = "< as above, but U and V bytes are swapped"]
    PIX_FMT_NV21 = 11,
    #[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
    PIX_FMT_RGB24 = 12,
    #[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
    PIX_FMT_BGR24 = 13,
    #[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
    PIX_FMT_ARGB = 14,
    #[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
    PIX_FMT_RGBA = 15,
    #[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
    PIX_FMT_ABGR = 16,
    #[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
    PIX_FMT_BGRA = 17,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)\t  5R 6G 5B(lsb), big-endian"]
    PIX_FMT_RGB565BE = 18,
    #[doc = "< packed RGB 5:6:5, 16bpp, (msb)\t  5R 6G 5B(lsb), little-endian"]
    PIX_FMT_RGB565LE = 19,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0"]
    PIX_FMT_RGB555BE = 20,
    #[doc = "< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0"]
    PIX_FMT_RGB555LE = 21,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)\t 5B 6G 5R(lsb), big-endian"]
    PIX_FMT_BGR565BE = 22,
    #[doc = "< packed BGR 5:6:5, 16bpp, (msb)\t 5B 6G 5R(lsb), little-endian"]
    PIX_FMT_BGR565LE = 23,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1"]
    PIX_FMT_BGR555BE = 24,
    #[doc = "< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1"]
    PIX_FMT_BGR555LE = 25,
    #[doc = "< packed RGB 8:8:8, 32bpp, 0RGB0RGB..."]
    PIX_FMT_0RGB = 26,
    #[doc = "< packed RGB 8:8:8, 32bpp, RGB0RGB0..."]
    PIX_FMT_RGB0 = 27,
    #[doc = "< packed BGR 8:8:8, 32bpp, 0BGR0BGR..."]
    PIX_FMT_0BGR = 28,
    #[doc = "< packed BGR 8:8:8, 32bpp, BGR0BGR0..."]
    PIX_FMT_BGR0 = 29,
    #[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
    PIX_FMT_BAYER_BGGR8 = 30,
    #[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
    PIX_FMT_BAYER_RGGB8 = 31,
    #[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
    PIX_FMT_BAYER_GBRG8 = 32,
    #[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
    PIX_FMT_BAYER_GRBG8 = 33,
    PIX_FMT_RAW = 34,
    PIX_FMT_HSV = 35,
    #[doc = "< number of pixel formats."]
    PIX_FMT_NB = 36,
}
#[doc = " IMP."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPPoint {
    #[doc = "<"]
    pub x: libc::c_int,
    #[doc = "<"]
    pub y: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPPoint"][::core::mem::size_of::<IMPPoint>() - 8usize];
    ["Alignment of IMPPoint"][::core::mem::align_of::<IMPPoint>() - 4usize];
    ["Offset of field: IMPPoint::x"][::core::mem::offset_of!(IMPPoint, x) - 0usize];
    ["Offset of field: IMPPoint::y"][::core::mem::offset_of!(IMPPoint, y) - 4usize];
};
#[doc = " IMP .\n\n p0(100,100)widthheight100p1(199,199)\n width = abs(p1.x-p0.x)+1   height = abs(p1.y-p0.y)+1  +1\n p0(100,100) _____100______\n            |              |\n            |              |\n         100|              |\n            |              |\n            |______________|\n                           p1(199,199)\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPRect {
    #[doc = "<"]
    pub p0: IMPPoint,
    #[doc = "<"]
    pub p1: IMPPoint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPRect"][::core::mem::size_of::<IMPRect>() - 16usize];
    ["Alignment of IMPRect"][::core::mem::align_of::<IMPRect>() - 4usize];
    ["Offset of field: IMPRect::p0"][::core::mem::offset_of!(IMPRect, p0) - 0usize];
    ["Offset of field: IMPRect::p1"][::core::mem::offset_of!(IMPRect, p1) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPLine {
    #[doc = "< "]
    pub p0: IMPPoint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPLine"][::core::mem::size_of::<IMPLine>() - 8usize];
    ["Alignment of IMPLine"][::core::mem::align_of::<IMPLine>() - 4usize];
    ["Offset of field: IMPLine::p0"][::core::mem::offset_of!(IMPLine, p0) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPIVSInterface {
    #[doc = "< "]
    pub param: *mut libc::c_void,
    #[doc = "< "]
    pub paramSize: libc::c_int,
    #[doc = "< "]
    pub pixfmt: IMPPixelFormat,
    #[doc = "< "]
    pub init:
        ::core::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface) -> libc::c_int>,
    #[doc = "< "]
    pub exit: ::core::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface)>,
    #[doc = "< framefree frame>=0 <0"]
    pub preProcessSync: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, frame: *mut IMPFrameInfo) -> libc::c_int,
    >,
    #[doc = "< , SDK IVS frame framefree_data; ,;:0->,1->,-1->"]
    pub processAsync: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, frame: *mut IMPFrameInfo) -> libc::c_int,
    >,
    #[doc = "< "]
    pub getResult: ::core::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            result: *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    #[doc = "< "]
    pub releaseResult: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, result: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = "< "]
    pub getParam: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, param: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = "< "]
    pub setParam: ::core::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface, param: *mut libc::c_void) -> libc::c_int,
    >,
    #[doc = "< processAsyncframe"]
    pub flushFrame:
        ::core::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface) -> libc::c_int>,
    #[doc = "< "]
    pub priv_: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPIVSInterface"][::core::mem::size_of::<IMPIVSInterface>() - 52usize];
    ["Alignment of IMPIVSInterface"][::core::mem::align_of::<IMPIVSInterface>() - 4usize];
    ["Offset of field: IMPIVSInterface::param"]
        [::core::mem::offset_of!(IMPIVSInterface, param) - 0usize];
    ["Offset of field: IMPIVSInterface::paramSize"]
        [::core::mem::offset_of!(IMPIVSInterface, paramSize) - 4usize];
    ["Offset of field: IMPIVSInterface::pixfmt"]
        [::core::mem::offset_of!(IMPIVSInterface, pixfmt) - 8usize];
    ["Offset of field: IMPIVSInterface::init"]
        [::core::mem::offset_of!(IMPIVSInterface, init) - 12usize];
    ["Offset of field: IMPIVSInterface::exit"]
        [::core::mem::offset_of!(IMPIVSInterface, exit) - 16usize];
    ["Offset of field: IMPIVSInterface::preProcessSync"]
        [::core::mem::offset_of!(IMPIVSInterface, preProcessSync) - 20usize];
    ["Offset of field: IMPIVSInterface::processAsync"]
        [::core::mem::offset_of!(IMPIVSInterface, processAsync) - 24usize];
    ["Offset of field: IMPIVSInterface::getResult"]
        [::core::mem::offset_of!(IMPIVSInterface, getResult) - 28usize];
    ["Offset of field: IMPIVSInterface::releaseResult"]
        [::core::mem::offset_of!(IMPIVSInterface, releaseResult) - 32usize];
    ["Offset of field: IMPIVSInterface::getParam"]
        [::core::mem::offset_of!(IMPIVSInterface, getParam) - 36usize];
    ["Offset of field: IMPIVSInterface::setParam"]
        [::core::mem::offset_of!(IMPIVSInterface, setParam) - 40usize];
    ["Offset of field: IMPIVSInterface::flushFrame"]
        [::core::mem::offset_of!(IMPIVSInterface, flushFrame) - 44usize];
    ["Offset of field: IMPIVSInterface::priv_"]
        [::core::mem::offset_of!(IMPIVSInterface, priv_) - 48usize];
};
impl Default for IMPIVSInterface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_CreateGroup(int GrpNum);\n\n @param[in] GrpNum IVS\n\n @retval 0 \n @retval -1 \n\n @remark \n\n @attention "]
    pub fn IMP_IVS_CreateGroup(GrpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_DestroyGroup(int GrpNum);\n\n @param[in] GrpNum IVS\n\n @retval 0 \n @retval -1 \n\n @remark \n\n @attention "]
    pub fn IMP_IVS_DestroyGroup(GrpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " IVS\n\n @fn int IMP_IVS_CreateChn(int ChnNum, IMPIVSInterface *handler);\n\n @param[in] ChnNum \n\n @param[in] handler IVS\n\n @retval 0 \n @retval -1 \n\n @remark .\n\n @attention "]
    pub fn IMP_IVS_CreateChn(ChnNum: libc::c_int, handler: *mut IMPIVSInterface) -> libc::c_int;
}
extern "C" {
    #[doc = " IVS\n\n @fn int IMP_IVS_DestroyChn(int ChnNum);\n\n @param[in] ChnNum \n\n @retval 0 \n @retval -1 \n\n @remark \n\n @attention "]
    pub fn IMP_IVS_DestroyChn(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_RegisterChn(int GrpNum, int ChnNum);\n\n @param[in] GrpNum IVS\n @param[in] ChnNum IVS\n\n @retval 0 \n @retval -1 \n\n @remark ChnnumGrpnum\n\n @attention "]
    pub fn IMP_IVS_RegisterChn(GrpNum: libc::c_int, ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_UnRegisterChn(int ChnNum);\n\n @param[in] ChnNum IVS\n\n @retval 0 \n @retval -1 \n\n @remark GrpnumChnnum\n\n @attention "]
    pub fn IMP_IVS_UnRegisterChn(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_StartRecvPic(int ChnNum);\n\n @param[in] ChnNum \n\n @retval 0 \n @retval -1 \n\n @remark ChnnumIVS\n\n @attention "]
    pub fn IMP_IVS_StartRecvPic(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_StopRecvPic(int ChnNum);\n\n @param[in] ChnNum \n\n @retval 0 \n @retval -1 \n\n @remark ChnnumIVS\n\n @attention "]
    pub fn IMP_IVS_StopRecvPic(ChnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " IVS\n\n @fn int IMP_IVS_PollingResult(int ChnNum, int timeoutMs);\n\n @param[in] ChnNum IVS\n @param[in] timeout ms; IMP_IVS_DEFAULT_TIMEOUTMS:,0:,>0:\n\n @retval 0 \n @retval -1 \n\n @remark IMPIVSInterfaceProcessAsync0Polling\n\n @attention "]
    pub fn IMP_IVS_PollingResult(ChnNum: libc::c_int, timeoutMs: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " IVS\n\n @fn int IMP_IVS_GetResult(int ChnNum, void **result);\n\n @param[in] ChnNum IVS\n @param[in] result IVS\n\n @retval 0 \n @retval -1 \n\n @remark IVS,.\n\n @attention "]
    pub fn IMP_IVS_GetResult(ChnNum: libc::c_int, result: *mut *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " IVS\n\n @fn int IMP_IVS_ReleaseResult(int ChnNum, void *result);\n\n @param[in] GrpNum \n @param[in] ChnNum IVS\n @param[in] result IVS\n\n @retval 0 \n @retval -1 \n\n @remark IVS,.\n\n @attention "]
    pub fn IMP_IVS_ReleaseResult(ChnNum: libc::c_int, result: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " Datacallbackframe\n\n @fn int IMP_IVS_ReleaseData(void *vaddr);\n\n @param[in] vaddr \n\n @retval 0 \n @retval -1 \n\n @remark Datacallbackframe\n @remark \n\n @attention "]
    pub fn IMP_IVS_ReleaseData(vaddr: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_GetParam(int chnNum, void *param);\n\n @param[in] ChnNum IVS\n @param[in] param \n\n @retval 0 \n @retval -1 \n\n @attention "]
    pub fn IMP_IVS_GetParam(chnNum: libc::c_int, param: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    #[doc = " \n\n @fn int IMP_IVS_SetParam(int chnNum, void *param);\n\n @param[in] ChnNum IVS\n @param[in] param \n\n @retval 0 \n @retval -1 \n\n @attention "]
    pub fn IMP_IVS_SetParam(chnNum: libc::c_int, param: *mut libc::c_void) -> libc::c_int;
}
#[doc = " "]
#[repr(C)]
#[derive(Debug)]
pub struct IMP_IVS_MoveParam {
    #[doc = "< , 0-40-8"]
    pub sense: [libc::c_int; 52usize],
    pub skipFrameCnt: libc::c_int,
    #[doc = "< ,widthheight"]
    pub frameInfo: IMPFrameInfo,
    pub roiRect: [IMPRect; 52usize],
    pub roiRectCnt: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_MoveParam"][::core::mem::size_of::<IMP_IVS_MoveParam>() - 1112usize];
    ["Alignment of IMP_IVS_MoveParam"][::core::mem::align_of::<IMP_IVS_MoveParam>() - 8usize];
    ["Offset of field: IMP_IVS_MoveParam::sense"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, sense) - 0usize];
    ["Offset of field: IMP_IVS_MoveParam::skipFrameCnt"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, skipFrameCnt) - 208usize];
    ["Offset of field: IMP_IVS_MoveParam::frameInfo"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, frameInfo) - 216usize];
    ["Offset of field: IMP_IVS_MoveParam::roiRect"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, roiRect) - 272usize];
    ["Offset of field: IMP_IVS_MoveParam::roiRectCnt"]
        [::core::mem::offset_of!(IMP_IVS_MoveParam, roiRectCnt) - 1104usize];
};
impl Default for IMP_IVS_MoveParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMP_IVS_MoveOutput {
    pub retRoi: [libc::c_int; 52usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_MoveOutput"][::core::mem::size_of::<IMP_IVS_MoveOutput>() - 208usize];
    ["Alignment of IMP_IVS_MoveOutput"][::core::mem::align_of::<IMP_IVS_MoveOutput>() - 4usize];
    ["Offset of field: IMP_IVS_MoveOutput::retRoi"]
        [::core::mem::offset_of!(IMP_IVS_MoveOutput, retRoi) - 0usize];
};
impl Default for IMP_IVS_MoveOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \n\n @fn IMPIVSInterface *IMP_IVS_CreateMoveInterface(IMP_IVS_MoveParam *param);\n\n @param[in] param \n\n @retval NULL ,\n @retval NULL \n\n @attention "]
    pub fn IMP_IVS_CreateMoveInterface(param: *mut IMP_IVS_MoveParam) -> *mut IMPIVSInterface;
}
extern "C" {
    #[doc = " \n\n @fn void IMP_IVS_DestroyMoveInterface(IMPIVSInterface *moveInterface);\n\n @param[in] moveInterface \n\n @retval \n\n @attention "]
    pub fn IMP_IVS_DestroyMoveInterface(moveInterface: *mut IMPIVSInterface);
}
#[doc = " IMP."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPVersion {
    #[doc = "< IMP"]
    pub aVersion: [libc::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPVersion"][::core::mem::size_of::<IMPVersion>() - 64usize];
    ["Alignment of IMPVersion"][::core::mem::align_of::<IMPVersion>() - 1usize];
    ["Offset of field: IMPVersion::aVersion"]
        [::core::mem::offset_of!(IMPVersion, aVersion) - 0usize];
};
impl Default for IMPVersion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_System_Init(void)\n\n IMP.\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remark API.\n\n @attention IMP."]
    pub fn IMP_System_Init() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_Exit(void)\n\n IMP.\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remark IMP.\n\n @attention APIIMPIMP."]
    pub fn IMP_System_Exit() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int64_t IMP_System_GetTimeStamp(void)\n\n IMP\n\n @param \n\n @retval (usec)\n\n @remark \n\n @attention "]
    pub fn IMP_System_GetTimeStamp() -> i64;
}
extern "C" {
    #[doc = " @fn int IMP_System_RebaseTimeStamp(int64_t basets)\n\n IMP\n\n @param[in] basets \n\n @retval 0 .\n @retval 0 .\n\n @remark \n\n @attention "]
    pub fn IMP_System_RebaseTimeStamp(basets: i64) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn uint32_t IMP_System_ReadReg32(uint32_t u32Addr)\n\n 32\n\n @param[in] regAddr \n\n @retval 32\n\n @remark \n\n @attention "]
    pub fn IMP_System_ReadReg32(regAddr: u32) -> u32;
}
extern "C" {
    #[doc = " @fn void IMP_System_WriteReg32(uint32_t regAddr, uint32_t value)\n\n 32\n\n @param[in] regAddr \n @param[in] value \n\n @retval \n\n @remark \n\n @attention API"]
    pub fn IMP_System_WriteReg32(regAddr: u32, value: u32);
}
extern "C" {
    #[doc = " @fn int IMP_System_GetVersion(IMPVersion *pstVersion)\n\n IMP.\n\n @param[out] pstVersion IMP.\n\n @retval 0 .\n @retval 0 .\n\n @remark .\n\n @attention ."]
    pub fn IMP_System_GetVersion(pstVersion: *mut IMPVersion) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn const char* IMP_System_GetCPUInfo(void)\n\n CPU.\n\n @param .\n\n @retval CPU.\n\n @remark CPU,T10,\"T10\"\"T10-Lite\".\n\n @attention ."]
    pub fn IMP_System_GetCPUInfo() -> *const libc::c_char;
}
extern "C" {
    #[doc = " @fn int IMP_System_Bind(IMPCell *srcCell, IMPCell *dstCell)\n\n CellCell.\n\n @param[in] srcCell Cell.\n @param[in] dstCell Cell.\n\n @retval 0 .\n @retval 0 .\n\n @remark DeviceGroupOutputDeviceGroupGroupOutput\\n\n GroupDeviceOutputDevice.Device \\n\n OutputDeviceGroup.\n @remark Cell(Output)Cell(Group).\n\n @attention "]
    pub fn IMP_System_Bind(srcCell: *mut IMPCell, dstCell: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_UnBind(IMPCell *srcCell, IMPCell *dstCell)\n\n CellCell.\n\n @param[in] srcCell Cell.\n @param[in] dstCell Cell.\n\n\n @retval 0 .\n @retval 0 .\n\n @remark .\n\n @attention "]
    pub fn IMP_System_UnBind(srcCell: *mut IMPCell, dstCell: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_GetBindbyDest(IMPCell *dstCell, IMPCell *srcCell)\n\n CellCell.\n\n @param[in] dstCell Cell.\n @param[out] srcCell Cell.\n\n\n @retval 0 .\n @retval 0 .\n\n @remark .\n\n @attention "]
    pub fn IMP_System_GetBindbyDest(dstCell: *mut IMPCell, srcCell: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_System_MemPoolRequest(int poolId, size_t size, const char *name);\n\n Rmemmempool\n\n @param[in] poolId     poolID.\n @param[in] size       .\n @param[in] name       pool.\n\n @retval    0          .\n @retval    0        .\n\n @remarks\n ,,\n ,.\n RMEM,\n .\n ,\n \n\n @attention ."]
    pub fn IMP_System_MemPoolRequest(
        poolId: libc::c_int,
        size: usize,
        name: *mut libc::c_char,
    ) -> libc::c_int;
}
pub const IMP_LOG_LEVEL_UNKNOWN: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_UNKNOWN;
pub const IMP_LOG_LEVEL_RESERVED: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_RESERVED;
pub const IMP_LOG_LEVEL_VERBOSE: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_VERBOSE;
pub const IMP_LOG_LEVEL_DEBUG: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_DEBUG;
pub const IMP_LOG_LEVEL_INFO: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_INFO;
pub const IMP_LOG_LEVEL_WARN: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_WARN;
pub const IMP_LOG_LEVEL_ERROR: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_ERROR;
pub const IMP_LOG_LEVEL_FATAL: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_FATAL;
pub const IMP_LOG_LEVEL_SILENT: _bindgen_ty_11 = _bindgen_ty_11::IMP_LOG_LEVEL_SILENT;
#[repr(u32)]
#[doc = " define log level"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_11 {
    IMP_LOG_LEVEL_UNKNOWN = 0,
    IMP_LOG_LEVEL_RESERVED = 1,
    IMP_LOG_LEVEL_VERBOSE = 2,
    IMP_LOG_LEVEL_DEBUG = 3,
    IMP_LOG_LEVEL_INFO = 4,
    IMP_LOG_LEVEL_WARN = 5,
    IMP_LOG_LEVEL_ERROR = 6,
    IMP_LOG_LEVEL_FATAL = 7,
    IMP_LOG_LEVEL_SILENT = 8,
}
extern "C" {
    #[doc = " used internal"]
    pub fn imp_log_fun(
        le: libc::c_int,
        op: libc::c_int,
        out: libc::c_int,
        tag: *const libc::c_char,
        file: *const libc::c_char,
        line: libc::c_int,
        func: *const libc::c_char,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    #[doc = " \n\n @fn void IMP_Log_Set_Option(int op);\n\n @param[in] op \n"]
    pub fn IMP_Log_Set_Option(op: libc::c_int);
}
extern "C" {
    #[doc = " \n\n @fn int IMP_Log_Get_Option(void );\n\n @retval \n"]
    pub fn IMP_Log_Get_Option() -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(__s: *mut libc::c_void, __c: libc::c_int, __n: libc::c_uint)
        -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const libc::c_void,
        __c: libc::c_int,
        __n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __l: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const libc::c_char, __n: libc::c_uint) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __reject: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __accept: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __accept: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const libc::c_char,
        __needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut libc::c_char, __delim: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut libc::c_char,
        __delim: *const libc::c_char,
        __save_ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strnlen(__string: *const libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: libc::c_int,
        __buf: *mut libc::c_char,
        __buflen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: libc::c_int, __l: locale_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const libc::c_void,
        __s2: *const libc::c_void,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const libc::c_void, __dest: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut libc::c_void, __n: libc::c_uint);
}
extern "C" {
    pub fn index(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(__i: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const libc::c_char,
        __s2: *const libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: libc::c_uint,
    ) -> *mut libc::c_char;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_int;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [libc::c_char; 16usize],
    pub __align: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sem_t"][::core::mem::size_of::<sem_t>() - 16usize];
    ["Alignment of sem_t"][::core::mem::align_of::<sem_t>() - 4usize];
    ["Offset of field: sem_t::__size"][::core::mem::offset_of!(sem_t, __size) - 0usize];
    ["Offset of field: sem_t::__align"][::core::mem::offset_of!(sem_t, __align) - 0usize];
};
impl Default for sem_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: libc::c_int,
        __value: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_open(__name: *const libc::c_char, __oflag: libc::c_int, ...) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> libc::c_int;
}
extern "C" {
    pub fn sem_getvalue(__sem: *mut sem_t, __sval: *mut libc::c_int) -> libc::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> libc::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> libc::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: f64, __y: f64) -> libc::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub static mut signgam: libc::c_int;
}
pub type wchar_t = libc::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::core::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::core::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::core::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::core::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::core::mem::size_of::<ldiv_t>() - 8usize];
    ["Alignment of ldiv_t"][::core::mem::align_of::<ldiv_t>() - 4usize];
    ["Offset of field: ldiv_t::quot"][::core::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::core::mem::offset_of!(ldiv_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::core::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::core::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::core::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::core::mem::offset_of!(lldiv_t, rem) - 8usize];
};
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::core::mem::size_of::<random_data>() - 28usize];
    ["Alignment of random_data"][::core::mem::align_of::<random_data>() - 4usize];
    ["Offset of field: random_data::fptr"][::core::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::core::mem::offset_of!(random_data, rptr) - 4usize];
    ["Offset of field: random_data::state"][::core::mem::offset_of!(random_data, state) - 8usize];
    ["Offset of field: random_data::rand_type"]
        [::core::mem::offset_of!(random_data, rand_type) - 12usize];
    ["Offset of field: random_data::rand_deg"]
        [::core::mem::offset_of!(random_data, rand_deg) - 16usize];
    ["Offset of field: random_data::rand_sep"]
        [::core::mem::offset_of!(random_data, rand_sep) - 20usize];
    ["Offset of field: random_data::end_ptr"]
        [::core::mem::offset_of!(random_data, end_ptr) - 24usize];
};
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::core::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::core::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::core::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::core::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::core::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::core::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::core::mem::offset_of!(drand48_data, __a) - 16usize];
};
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn malloc(__size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: libc::c_uint, __size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut libc::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn alloca(__size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: usize,
        __size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: libc::c_int, __arg: *mut libc::c_void),
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: libc::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut libc::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __buf: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut libc::c_char,
        __tokens: *const *mut libc::c_char,
        __valuep: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int) -> libc::c_int;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __type: libc::c_int,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;
}
extern "C" {
    pub fn close(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: libc::c_int, __buf: *const libc::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: libc::c_int,
        __buf: *mut libc::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: libc::c_int,
        __buf: *const libc::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn alarm(__seconds: libc::c_uint) -> libc::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: libc::c_uint) -> libc::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> libc::c_int;
}
extern "C" {
    pub fn pause() -> libc::c_int;
}
extern "C" {
    pub fn chown(__file: *const libc::c_char, __owner: __uid_t, __group: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn fchown(__fd: libc::c_int, __owner: __uid_t, __group: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn lchown(__file: *const libc::c_char, __owner: __uid_t, __group: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn chdir(__path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn fchdir(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut libc::c_char, __size: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn dup(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn dup2(__fd: libc::c_int, __fd2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut libc::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const libc::c_char,
        __argv: *const *mut libc::c_char,
        __envp: *const *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: libc::c_int,
        __argv: *const *mut libc::c_char,
        __envp: *const *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn execv(__path: *const libc::c_char, __argv: *const *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn execle(__path: *const libc::c_char, __arg: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn execl(__path: *const libc::c_char, __arg: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn execvp(__file: *const libc::c_char, __argv: *const *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn execlp(__file: *const libc::c_char, __arg: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn nice(__inc: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _exit(__status: libc::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_LINK_MAX;
pub const _PC_MAX_CANON: _bindgen_ty_13 = _bindgen_ty_13::_PC_MAX_CANON;
pub const _PC_MAX_INPUT: _bindgen_ty_13 = _bindgen_ty_13::_PC_MAX_INPUT;
pub const _PC_NAME_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_NAME_MAX;
pub const _PC_PATH_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_PATH_MAX;
pub const _PC_PIPE_BUF: _bindgen_ty_13 = _bindgen_ty_13::_PC_PIPE_BUF;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_13 = _bindgen_ty_13::_PC_CHOWN_RESTRICTED;
pub const _PC_NO_TRUNC: _bindgen_ty_13 = _bindgen_ty_13::_PC_NO_TRUNC;
pub const _PC_VDISABLE: _bindgen_ty_13 = _bindgen_ty_13::_PC_VDISABLE;
pub const _PC_SYNC_IO: _bindgen_ty_13 = _bindgen_ty_13::_PC_SYNC_IO;
pub const _PC_ASYNC_IO: _bindgen_ty_13 = _bindgen_ty_13::_PC_ASYNC_IO;
pub const _PC_PRIO_IO: _bindgen_ty_13 = _bindgen_ty_13::_PC_PRIO_IO;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_13 = _bindgen_ty_13::_PC_SOCK_MAXBUF;
pub const _PC_FILESIZEBITS: _bindgen_ty_13 = _bindgen_ty_13::_PC_FILESIZEBITS;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_INCR_XFER_SIZE;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_MAX_XFER_SIZE;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_MIN_XFER_SIZE;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_13 = _bindgen_ty_13::_PC_REC_XFER_ALIGN;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_13 = _bindgen_ty_13::_PC_ALLOC_SIZE_MIN;
pub const _PC_SYMLINK_MAX: _bindgen_ty_13 = _bindgen_ty_13::_PC_SYMLINK_MAX;
pub const _PC_2_SYMLINKS: _bindgen_ty_13 = _bindgen_ty_13::_PC_2_SYMLINKS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_13 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20,
}
pub const _SC_ARG_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_ARG_MAX;
pub const _SC_CHILD_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHILD_MAX;
pub const _SC_CLK_TCK: _bindgen_ty_14 = _bindgen_ty_14::_SC_CLK_TCK;
pub const _SC_NGROUPS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NGROUPS_MAX;
pub const _SC_OPEN_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_OPEN_MAX;
pub const _SC_STREAM_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_STREAM_MAX;
pub const _SC_TZNAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TZNAME_MAX;
pub const _SC_JOB_CONTROL: _bindgen_ty_14 = _bindgen_ty_14::_SC_JOB_CONTROL;
pub const _SC_SAVED_IDS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SAVED_IDS;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_14 = _bindgen_ty_14::_SC_REALTIME_SIGNALS;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_14 = _bindgen_ty_14::_SC_PRIORITY_SCHEDULING;
pub const _SC_TIMERS: _bindgen_ty_14 = _bindgen_ty_14::_SC_TIMERS;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_ASYNCHRONOUS_IO;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_PRIORITIZED_IO;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYNCHRONIZED_IO;
pub const _SC_FSYNC: _bindgen_ty_14 = _bindgen_ty_14::_SC_FSYNC;
pub const _SC_MAPPED_FILES: _bindgen_ty_14 = _bindgen_ty_14::_SC_MAPPED_FILES;
pub const _SC_MEMLOCK: _bindgen_ty_14 = _bindgen_ty_14::_SC_MEMLOCK;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_14 = _bindgen_ty_14::_SC_MEMLOCK_RANGE;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_14 = _bindgen_ty_14::_SC_MEMORY_PROTECTION;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_14 = _bindgen_ty_14::_SC_MESSAGE_PASSING;
pub const _SC_SEMAPHORES: _bindgen_ty_14 = _bindgen_ty_14::_SC_SEMAPHORES;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHARED_MEMORY_OBJECTS;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_AIO_LISTIO_MAX;
pub const _SC_AIO_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_AIO_MAX;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_AIO_PRIO_DELTA_MAX;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_DELAYTIMER_MAX;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_MQ_OPEN_MAX;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_MQ_PRIO_MAX;
pub const _SC_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_VERSION;
pub const _SC_PAGESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_PAGESIZE;
pub const _SC_RTSIG_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_RTSIG_MAX;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SEM_NSEMS_MAX;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SEM_VALUE_MAX;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SIGQUEUE_MAX;
pub const _SC_TIMER_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TIMER_MAX;
pub const _SC_BC_BASE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_BASE_MAX;
pub const _SC_BC_DIM_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_DIM_MAX;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_SCALE_MAX;
pub const _SC_BC_STRING_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_BC_STRING_MAX;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_COLL_WEIGHTS_MAX;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_EQUIV_CLASS_MAX;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_EXPR_NEST_MAX;
pub const _SC_LINE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_LINE_MAX;
pub const _SC_RE_DUP_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_RE_DUP_MAX;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHARCLASS_NAME_MAX;
pub const _SC_2_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_VERSION;
pub const _SC_2_C_BIND: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_C_BIND;
pub const _SC_2_C_DEV: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_C_DEV;
pub const _SC_2_FORT_DEV: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_FORT_DEV;
pub const _SC_2_FORT_RUN: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_FORT_RUN;
pub const _SC_2_SW_DEV: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_SW_DEV;
pub const _SC_2_LOCALEDEF: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_LOCALEDEF;
pub const _SC_PII: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII;
pub const _SC_PII_XTI: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_XTI;
pub const _SC_PII_SOCKET: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_SOCKET;
pub const _SC_PII_INTERNET: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_INTERNET;
pub const _SC_PII_OSI: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI;
pub const _SC_POLL: _bindgen_ty_14 = _bindgen_ty_14::_SC_POLL;
pub const _SC_SELECT: _bindgen_ty_14 = _bindgen_ty_14::_SC_SELECT;
pub const _SC_UIO_MAXIOV: _bindgen_ty_14 = _bindgen_ty_14::_SC_UIO_MAXIOV;
pub const _SC_IOV_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_UIO_MAXIOV;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_INTERNET_STREAM;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_INTERNET_DGRAM;
pub const _SC_PII_OSI_COTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI_COTS;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI_CLTS;
pub const _SC_PII_OSI_M: _bindgen_ty_14 = _bindgen_ty_14::_SC_PII_OSI_M;
pub const _SC_T_IOV_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_T_IOV_MAX;
pub const _SC_THREADS: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREADS;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_SAFE_FUNCTIONS;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_GETGR_R_SIZE_MAX;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_GETPW_R_SIZE_MAX;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_LOGIN_NAME_MAX;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TTY_NAME_MAX;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_DESTRUCTOR_ITERATIONS;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_KEYS_MAX;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_STACK_MIN;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_THREADS_MAX;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_ATTR_STACKADDR;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_ATTR_STACKSIZE;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_PRIORITY_SCHEDULING;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_PRIO_INHERIT;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_PRIO_PROTECT;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_PROCESS_SHARED;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_14 = _bindgen_ty_14::_SC_NPROCESSORS_CONF;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_14 = _bindgen_ty_14::_SC_NPROCESSORS_ONLN;
pub const _SC_PHYS_PAGES: _bindgen_ty_14 = _bindgen_ty_14::_SC_PHYS_PAGES;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_14 = _bindgen_ty_14::_SC_AVPHYS_PAGES;
pub const _SC_ATEXIT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_ATEXIT_MAX;
pub const _SC_PASS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_PASS_MAX;
pub const _SC_XOPEN_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_VERSION;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XCU_VERSION;
pub const _SC_XOPEN_UNIX: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_UNIX;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_CRYPT;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_ENH_I18N;
pub const _SC_XOPEN_SHM: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_SHM;
pub const _SC_2_CHAR_TERM: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_CHAR_TERM;
pub const _SC_2_C_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_C_VERSION;
pub const _SC_2_UPE: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_UPE;
pub const _SC_XOPEN_XPG2: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XPG2;
pub const _SC_XOPEN_XPG3: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XPG3;
pub const _SC_XOPEN_XPG4: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_XPG4;
pub const _SC_CHAR_BIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHAR_BIT;
pub const _SC_CHAR_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHAR_MAX;
pub const _SC_CHAR_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_CHAR_MIN;
pub const _SC_INT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_INT_MAX;
pub const _SC_INT_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_INT_MIN;
pub const _SC_LONG_BIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_LONG_BIT;
pub const _SC_WORD_BIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_WORD_BIT;
pub const _SC_MB_LEN_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_MB_LEN_MAX;
pub const _SC_NZERO: _bindgen_ty_14 = _bindgen_ty_14::_SC_NZERO;
pub const _SC_SSIZE_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SSIZE_MAX;
pub const _SC_SCHAR_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SCHAR_MAX;
pub const _SC_SCHAR_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_SCHAR_MIN;
pub const _SC_SHRT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHRT_MAX;
pub const _SC_SHRT_MIN: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHRT_MIN;
pub const _SC_UCHAR_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_UCHAR_MAX;
pub const _SC_UINT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_UINT_MAX;
pub const _SC_ULONG_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_ULONG_MAX;
pub const _SC_USHRT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_USHRT_MAX;
pub const _SC_NL_ARGMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_ARGMAX;
pub const _SC_NL_LANGMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_LANGMAX;
pub const _SC_NL_MSGMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_MSGMAX;
pub const _SC_NL_NMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_NMAX;
pub const _SC_NL_SETMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_SETMAX;
pub const _SC_NL_TEXTMAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_NL_TEXTMAX;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_ILP32_OFF32;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_ILP32_OFFBIG;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_LP64_OFF64;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_XBS5_LPBIG_OFFBIG;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_LEGACY;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_REALTIME;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_REALTIME_THREADS;
pub const _SC_ADVISORY_INFO: _bindgen_ty_14 = _bindgen_ty_14::_SC_ADVISORY_INFO;
pub const _SC_BARRIERS: _bindgen_ty_14 = _bindgen_ty_14::_SC_BARRIERS;
pub const _SC_BASE: _bindgen_ty_14 = _bindgen_ty_14::_SC_BASE;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_14 = _bindgen_ty_14::_SC_C_LANG_SUPPORT;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_C_LANG_SUPPORT_R;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_14 = _bindgen_ty_14::_SC_CLOCK_SELECTION;
pub const _SC_CPUTIME: _bindgen_ty_14 = _bindgen_ty_14::_SC_CPUTIME;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_CPUTIME;
pub const _SC_DEVICE_IO: _bindgen_ty_14 = _bindgen_ty_14::_SC_DEVICE_IO;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_14 = _bindgen_ty_14::_SC_DEVICE_SPECIFIC;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_DEVICE_SPECIFIC_R;
pub const _SC_FD_MGMT: _bindgen_ty_14 = _bindgen_ty_14::_SC_FD_MGMT;
pub const _SC_FIFO: _bindgen_ty_14 = _bindgen_ty_14::_SC_FIFO;
pub const _SC_PIPE: _bindgen_ty_14 = _bindgen_ty_14::_SC_PIPE;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_14 = _bindgen_ty_14::_SC_FILE_ATTRIBUTES;
pub const _SC_FILE_LOCKING: _bindgen_ty_14 = _bindgen_ty_14::_SC_FILE_LOCKING;
pub const _SC_FILE_SYSTEM: _bindgen_ty_14 = _bindgen_ty_14::_SC_FILE_SYSTEM;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_14 = _bindgen_ty_14::_SC_MONOTONIC_CLOCK;
pub const _SC_MULTI_PROCESS: _bindgen_ty_14 = _bindgen_ty_14::_SC_MULTI_PROCESS;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SINGLE_PROCESS;
pub const _SC_NETWORKING: _bindgen_ty_14 = _bindgen_ty_14::_SC_NETWORKING;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_14 = _bindgen_ty_14::_SC_READER_WRITER_LOCKS;
pub const _SC_SPIN_LOCKS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SPIN_LOCKS;
pub const _SC_REGEXP: _bindgen_ty_14 = _bindgen_ty_14::_SC_REGEXP;
pub const _SC_REGEX_VERSION: _bindgen_ty_14 = _bindgen_ty_14::_SC_REGEX_VERSION;
pub const _SC_SHELL: _bindgen_ty_14 = _bindgen_ty_14::_SC_SHELL;
pub const _SC_SIGNALS: _bindgen_ty_14 = _bindgen_ty_14::_SC_SIGNALS;
pub const _SC_SPAWN: _bindgen_ty_14 = _bindgen_ty_14::_SC_SPAWN;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_14 = _bindgen_ty_14::_SC_SPORADIC_SERVER;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_14 = _bindgen_ty_14::_SC_THREAD_SPORADIC_SERVER;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYSTEM_DATABASE;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYSTEM_DATABASE_R;
pub const _SC_TIMEOUTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_TIMEOUTS;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_14 = _bindgen_ty_14::_SC_TYPED_MEMORY_OBJECTS;
pub const _SC_USER_GROUPS: _bindgen_ty_14 = _bindgen_ty_14::_SC_USER_GROUPS;
pub const _SC_USER_GROUPS_R: _bindgen_ty_14 = _bindgen_ty_14::_SC_USER_GROUPS_R;
pub const _SC_2_PBS: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_ACCOUNTING;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_LOCATE;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_MESSAGE;
pub const _SC_2_PBS_TRACK: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_TRACK;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SYMLOOP_MAX;
pub const _SC_STREAMS: _bindgen_ty_14 = _bindgen_ty_14::_SC_STREAMS;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_14 = _bindgen_ty_14::_SC_2_PBS_CHECKPOINT;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_ILP32_OFF32;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_ILP32_OFFBIG;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_LP64_OFF64;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V6_LPBIG_OFFBIG;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_HOST_NAME_MAX;
pub const _SC_TRACE: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_EVENT_FILTER;
pub const _SC_TRACE_INHERIT: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_INHERIT;
pub const _SC_TRACE_LOG: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_LOG;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_ICACHE_SIZE;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_ICACHE_ASSOC;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_ICACHE_LINESIZE;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_DCACHE_SIZE;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_DCACHE_ASSOC;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL1_DCACHE_LINESIZE;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL2_CACHE_SIZE;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL2_CACHE_ASSOC;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL2_CACHE_LINESIZE;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL3_CACHE_SIZE;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL3_CACHE_ASSOC;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL3_CACHE_LINESIZE;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL4_CACHE_SIZE;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL4_CACHE_ASSOC;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_14 = _bindgen_ty_14::_SC_LEVEL4_CACHE_LINESIZE;
pub const _SC_IPV6: _bindgen_ty_14 = _bindgen_ty_14::_SC_IPV6;
pub const _SC_RAW_SOCKETS: _bindgen_ty_14 = _bindgen_ty_14::_SC_RAW_SOCKETS;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_ILP32_OFF32;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_ILP32_OFFBIG;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_LP64_OFF64;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_14 = _bindgen_ty_14::_SC_V7_LPBIG_OFFBIG;
pub const _SC_SS_REPL_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_SS_REPL_MAX;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_EVENT_NAME_MAX;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_NAME_MAX;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_SYS_MAX;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_14 = _bindgen_ty_14::_SC_TRACE_USER_EVENT_MAX;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_14 = _bindgen_ty_14::_SC_XOPEN_STREAMS;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_ROBUST_PRIO_INHERIT;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_14 =
    _bindgen_ty_14::_SC_THREAD_ROBUST_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_14 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
}
pub const _CS_PATH: _bindgen_ty_15 = _bindgen_ty_15::_CS_PATH;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_15 = _bindgen_ty_15::_CS_GNU_LIBC_VERSION;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_15 = _bindgen_ty_15::_CS_GNU_LIBPTHREAD_VERSION;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _CS_LFS_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_CFLAGS;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_LDFLAGS;
pub const _CS_LFS_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_LIBS;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS_LINTFLAGS;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_CFLAGS;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_LDFLAGS;
pub const _CS_LFS64_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_LIBS;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_LFS64_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_CFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_LDFLAGS;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_LIBS;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFF32_LINTFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_CFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_LDFLAGS;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_LIBS;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LP64_OFF64_CFLAGS;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LP64_OFF64_LDFLAGS;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LP64_OFF64_LIBS;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LP64_OFF64_LINTFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_CFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 = _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_LIBS;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_LIBS;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_LIBS;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_LIBS;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_CFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_LDFLAGS;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_LIBS;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LP64_OFF64_LINTFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_LIBS;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 =
    _bindgen_ty_15::_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS;
pub const _CS_V6_ENV: _bindgen_ty_15 = _bindgen_ty_15::_CS_V6_ENV;
pub const _CS_V7_ENV: _bindgen_ty_15 = _bindgen_ty_15::_CS_V7_ENV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_15 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149,
}
extern "C" {
    pub fn pathconf(__path: *const libc::c_char, __name: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: libc::c_int, __name: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn sysconf(__name: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn confstr(__name: libc::c_int, __buf: *mut libc::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn setpgrp() -> libc::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: libc::c_int, __list: *mut __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> libc::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> libc::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> libc::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> libc::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> libc::c_int;
}
extern "C" {
    pub fn ttyname(__fd: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ttyname_r(__fd: libc::c_int, __buf: *mut libc::c_char, __buflen: usize) -> libc::c_int;
}
extern "C" {
    pub fn isatty(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ttyslot() -> libc::c_int;
}
extern "C" {
    pub fn link(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: libc::c_int,
        __from: *const libc::c_char,
        __tofd: libc::c_int,
        __to: *const libc::c_char,
        __flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn readlink(__path: *const libc::c_char, __buf: *mut libc::c_char, __len: usize) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const libc::c_char,
        __tofd: libc::c_int,
        __to: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __buf: *mut libc::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: libc::c_int,
        __name: *const libc::c_char,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: libc::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: libc::c_int, __pgrp_id: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut libc::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut libc::c_char, __name_len: usize) -> libc::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub static mut optarg: *mut libc::c_char;
}
extern "C" {
    pub static mut optind: libc::c_int;
}
extern "C" {
    pub static mut opterr: libc::c_int;
}
extern "C" {
    pub static mut optopt: libc::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: libc::c_int,
        ___argv: *const *mut libc::c_char,
        __shortopts: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn sethostid(__id: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const libc::c_char, __len: usize) -> libc::c_int;
}
extern "C" {
    pub fn vhangup() -> libc::c_int;
}
extern "C" {
    pub fn revoke(__file: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut libc::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn acct(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut libc::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: libc::c_int, __noclose: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn chroot(__path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fsync(__fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn gethostid() -> libc::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> libc::c_int;
}
extern "C" {
    pub fn getdtablesize() -> libc::c_int;
}
extern "C" {
    pub fn truncate(__file: *const libc::c_char, __length: __off_t) -> libc::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: libc::c_int, __length: __off_t) -> libc::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut libc::c_void;
}
extern "C" {
    pub fn syscall(__sysno: libc::c_long, ...) -> libc::c_long;
}
extern "C" {
    pub fn lockf(__fd: libc::c_int, __cmd: libc::c_int, __len: __off_t) -> libc::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn crypt(__key: *const libc::c_char, __salt: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn getentropy(__buffer: *mut libc::c_void, __length: usize) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: libc::c_ulong,
    pub st_pad1: [libc::c_long; 3usize],
    pub st_ino: __ino_t,
    pub st_mode: __mode_t,
    pub st_nlink: __nlink_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub st_rdev: libc::c_ulong,
    pub st_pad2: [libc::c_long; 2usize],
    pub st_size: __off_t,
    pub st_pad3: libc::c_long,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_pad5: [libc::c_long; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::core::mem::size_of::<stat>() - 144usize];
    ["Alignment of stat"][::core::mem::align_of::<stat>() - 4usize];
    ["Offset of field: stat::st_dev"][::core::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::st_pad1"][::core::mem::offset_of!(stat, st_pad1) - 4usize];
    ["Offset of field: stat::st_ino"][::core::mem::offset_of!(stat, st_ino) - 16usize];
    ["Offset of field: stat::st_mode"][::core::mem::offset_of!(stat, st_mode) - 20usize];
    ["Offset of field: stat::st_nlink"][::core::mem::offset_of!(stat, st_nlink) - 24usize];
    ["Offset of field: stat::st_uid"][::core::mem::offset_of!(stat, st_uid) - 28usize];
    ["Offset of field: stat::st_gid"][::core::mem::offset_of!(stat, st_gid) - 32usize];
    ["Offset of field: stat::st_rdev"][::core::mem::offset_of!(stat, st_rdev) - 36usize];
    ["Offset of field: stat::st_pad2"][::core::mem::offset_of!(stat, st_pad2) - 40usize];
    ["Offset of field: stat::st_size"][::core::mem::offset_of!(stat, st_size) - 48usize];
    ["Offset of field: stat::st_pad3"][::core::mem::offset_of!(stat, st_pad3) - 52usize];
    ["Offset of field: stat::st_atim"][::core::mem::offset_of!(stat, st_atim) - 56usize];
    ["Offset of field: stat::st_mtim"][::core::mem::offset_of!(stat, st_mtim) - 64usize];
    ["Offset of field: stat::st_ctim"][::core::mem::offset_of!(stat, st_ctim) - 72usize];
    ["Offset of field: stat::st_blksize"][::core::mem::offset_of!(stat, st_blksize) - 80usize];
    ["Offset of field: stat::st_blocks"][::core::mem::offset_of!(stat, st_blocks) - 84usize];
    ["Offset of field: stat::st_pad5"][::core::mem::offset_of!(stat, st_pad5) - 88usize];
};
extern "C" {
    pub fn stat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
}
extern "C" {
    pub fn fstat(__fd: libc::c_int, __buf: *mut stat) -> libc::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __buf: *mut stat,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lstat(__file: *const libc::c_char, __buf: *mut stat) -> libc::c_int;
}
extern "C" {
    pub fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn fchmod(__fd: libc::c_int, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __mode: __mode_t,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn mkdirat(__fd: libc::c_int, __path: *const libc::c_char, __mode: __mode_t)
        -> libc::c_int;
}
extern "C" {
    pub fn mknod(__path: *const libc::c_char, __mode: __mode_t, __dev: __dev_t) -> libc::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __times: *const timespec,
        __flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn futimens(__fd: libc::c_int, __times: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn __fxstat(
        __ver: libc::c_int,
        __fildes: libc::c_int,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __lxstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __fxstatat(
        __ver: libc::c_int,
        __fildes: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
        __flag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __xmknod(
        __ver: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __xmknodat(
        __ver: libc::c_int,
        __fd: libc::c_int,
        __path: *const libc::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_type: libc::c_short,
    pub l_whence: libc::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_sysid: libc::c_long,
    pub l_pid: __pid_t,
    pub __glibc_reserved0: [libc::c_long; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flock"][::core::mem::size_of::<flock>() - 36usize];
    ["Alignment of flock"][::core::mem::align_of::<flock>() - 4usize];
    ["Offset of field: flock::l_type"][::core::mem::offset_of!(flock, l_type) - 0usize];
    ["Offset of field: flock::l_whence"][::core::mem::offset_of!(flock, l_whence) - 2usize];
    ["Offset of field: flock::l_start"][::core::mem::offset_of!(flock, l_start) - 4usize];
    ["Offset of field: flock::l_len"][::core::mem::offset_of!(flock, l_len) - 8usize];
    ["Offset of field: flock::l_sysid"][::core::mem::offset_of!(flock, l_sysid) - 12usize];
    ["Offset of field: flock::l_pid"][::core::mem::offset_of!(flock, l_pid) - 16usize];
    ["Offset of field: flock::__glibc_reserved0"]
        [::core::mem::offset_of!(flock, __glibc_reserved0) - 20usize];
};
pub type flock_t = flock;
extern "C" {
    pub fn fcntl(__fd: libc::c_int, __cmd: libc::c_int, ...) -> libc::c_int;
}
extern "C" {
    pub fn open(__file: *const libc::c_char, __oflag: libc::c_int, ...) -> libc::c_int;
}
extern "C" {
    pub fn openat(
        __fd: libc::c_int,
        __file: *const libc::c_char,
        __oflag: libc::c_int,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn creat(__file: *const libc::c_char, __mode: mode_t) -> libc::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: libc::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: libc::c_int, __offset: off_t, __len: off_t) -> libc::c_int;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPSensorControlBusType {
    #[doc = "< I2C"]
    TX_SENSOR_CONTROL_INTERFACE_I2C = 1,
    #[doc = "< SPI"]
    TX_SENSOR_CONTROL_INTERFACE_SPI = 2,
}
#[doc = " I2C"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPI2CInfo {
    #[doc = "< I2Cstruct i2c_device_idname"]
    pub type_: [libc::c_char; 20usize],
    #[doc = "< I2C"]
    pub addr: libc::c_int,
    #[doc = "< I2C"]
    pub i2c_adapter_id: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPI2CInfo"][::core::mem::size_of::<IMPI2CInfo>() - 28usize];
    ["Alignment of IMPI2CInfo"][::core::mem::align_of::<IMPI2CInfo>() - 4usize];
    ["Offset of field: IMPI2CInfo::type_"][::core::mem::offset_of!(IMPI2CInfo, type_) - 0usize];
    ["Offset of field: IMPI2CInfo::addr"][::core::mem::offset_of!(IMPI2CInfo, addr) - 20usize];
    ["Offset of field: IMPI2CInfo::i2c_adapter_id"]
        [::core::mem::offset_of!(IMPI2CInfo, i2c_adapter_id) - 24usize];
};
#[doc = " SPI"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPSPIInfo {
    #[doc = "< SPIstruct spi_device_idname"]
    pub modalias: [libc::c_char; 32usize],
    #[doc = "< SPI"]
    pub bus_num: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPSPIInfo"][::core::mem::size_of::<IMPSPIInfo>() - 36usize];
    ["Alignment of IMPSPIInfo"][::core::mem::align_of::<IMPSPIInfo>() - 4usize];
    ["Offset of field: IMPSPIInfo::modalias"]
        [::core::mem::offset_of!(IMPSPIInfo, modalias) - 0usize];
    ["Offset of field: IMPSPIInfo::bus_num"]
        [::core::mem::offset_of!(IMPSPIInfo, bus_num) - 32usize];
};
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPSensorInfo {
    #[doc = "< "]
    pub name: [libc::c_char; 32usize],
    #[doc = "< ID"]
    pub sensor_id: u16,
    #[doc = "< "]
    pub cbus_type: IMPSensorControlBusType,
    pub __anon1: IMPSensorInfo__bindgen_ty_1,
    #[doc = "< resetGPIO"]
    pub rst_gpio: libc::c_ushort,
    #[doc = "< power downGPIO"]
    pub pwdn_gpio: libc::c_ushort,
    #[doc = "< power GPIO"]
    pub power_gpio: libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPSensorInfo__bindgen_ty_1 {
    #[doc = "< I2C"]
    pub i2c: IMPI2CInfo,
    #[doc = "< SPI"]
    pub spi: IMPSPIInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPSensorInfo__bindgen_ty_1"]
        [::core::mem::size_of::<IMPSensorInfo__bindgen_ty_1>() - 36usize];
    ["Alignment of IMPSensorInfo__bindgen_ty_1"]
        [::core::mem::align_of::<IMPSensorInfo__bindgen_ty_1>() - 4usize];
    ["Offset of field: IMPSensorInfo__bindgen_ty_1::i2c"]
        [::core::mem::offset_of!(IMPSensorInfo__bindgen_ty_1, i2c) - 0usize];
    ["Offset of field: IMPSensorInfo__bindgen_ty_1::spi"]
        [::core::mem::offset_of!(IMPSensorInfo__bindgen_ty_1, spi) - 0usize];
};
impl Default for IMPSensorInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPSensorInfo"][::core::mem::size_of::<IMPSensorInfo>() - 84usize];
    ["Alignment of IMPSensorInfo"][::core::mem::align_of::<IMPSensorInfo>() - 4usize];
    ["Offset of field: IMPSensorInfo::name"][::core::mem::offset_of!(IMPSensorInfo, name) - 0usize];
    ["Offset of field: IMPSensorInfo::sensor_id"]
        [::core::mem::offset_of!(IMPSensorInfo, sensor_id) - 32usize];
    ["Offset of field: IMPSensorInfo::cbus_type"]
        [::core::mem::offset_of!(IMPSensorInfo, cbus_type) - 36usize];
    ["Offset of field: IMPSensorInfo::rst_gpio"]
        [::core::mem::offset_of!(IMPSensorInfo, rst_gpio) - 76usize];
    ["Offset of field: IMPSensorInfo::pwdn_gpio"]
        [::core::mem::offset_of!(IMPSensorInfo, pwdn_gpio) - 78usize];
    ["Offset of field: IMPSensorInfo::power_gpio"]
        [::core::mem::offset_of!(IMPSensorInfo, power_gpio) - 80usize];
};
impl Default for IMPSensorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Open(void)\n\n ISP\n\n @param \n\n @retval 0 \n @retval 0 \n\n @remark ISPISPsensorISP\n\n @attention sensor"]
    pub fn IMP_ISP_Open() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Close(void)\n\n ISP\n\n @param \n\n @retval 0 \n @retval 0 \n\n @remark ISPISP\n\n @attention FrameSourcesensor."]
    pub fn IMP_ISP_Close() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetDefaultBinPath(char *path)\n\n ISP bin\n\n @param[in] path  bin\n\n @retval 0 \n @retval 0 \n\n @remark ISPBin\n\n @attention sensorISP"]
    pub fn IMP_ISP_SetDefaultBinPath(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetDefaultBinPath(char *path)\n\n ISP bin\n\n @param[out] path\tbin\n\n @retval 0 \n @retval 0 \n\n @remark ISPBin\n\n @attention sensor\n @attention ISPbin"]
    pub fn IMP_ISP_GetDefaultBinPath(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_AddSensor(IMPSensorInfo *pinfo)\n\n sensorISP\n\n @param[in] pinfo sensor\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention ."]
    pub fn IMP_ISP_AddSensor(pinfo: *mut IMPSensorInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DelSensor(IMPSensorInfo *pinfo)\n\n sensor\n\n @param[in] pinfo sensor\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention IMP_ISP_DisableSensor."]
    pub fn IMP_ISP_DelSensor(pinfo: *mut IMPSensorInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_EnableSensor(void)\n\n sensor\n\n @param \n\n @retval 0 \n @retval 0 \n\n @remark , FrameSourceISP\n\n @attention ISP."]
    pub fn IMP_ISP_EnableSensor() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DisableSensor(void)\n\n sensor\n\n @param \n\n @retval 0 \n @retval 0 \n\n @remark , FrameSourceISP\n\n @attention FrameSource."]
    pub fn IMP_ISP_DisableSensor() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_SetSensorRegister(uint32_t reg, uint32_t value)\n\n sensor\n\n @param[in] reg \n\n @param[in] value \n\n @retval 0 \n @retval 0 \n\n @remark sensor\n\n @attention ."]
    pub fn IMP_ISP_SetSensorRegister(reg: u32, value: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_GetSensorRegister(uint32_t reg, uint32_t *value)\n\n sensor\n\n @param[in] reg \n\n @param[in] value \n\n @retval 0 \n @retval 0 \n\n @remark sensor\n\n @attention ."]
    pub fn IMP_ISP_GetSensorRegister(reg: u32, value: *mut u32) -> libc::c_int;
}
#[repr(u32)]
#[doc = " ISP"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPTuningOpsMode {
    #[doc = "< "]
    IMPISP_TUNING_OPS_MODE_DISABLE = 0,
    #[doc = "< "]
    IMPISP_TUNING_OPS_MODE_ENABLE = 1,
    #[doc = "< "]
    IMPISP_TUNING_OPS_MODE_BUTT = 2,
}
#[repr(u32)]
#[doc = " ISP"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPTuningOpsType {
    #[doc = "< "]
    IMPISP_TUNING_OPS_TYPE_AUTO = 0,
    #[doc = "< "]
    IMPISP_TUNING_OPS_TYPE_MANUAL = 1,
    #[doc = "< "]
    IMPISP_TUNING_OPS_TYPE_BUTT = 2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPZone {
    #[doc = "< "]
    pub zone: [[libc::c_uint; 15usize]; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPZone"][::core::mem::size_of::<IMPISPZone>() - 900usize];
    ["Alignment of IMPISPZone"][::core::mem::align_of::<IMPISPZone>() - 1usize];
    ["Offset of field: IMPISPZone::zone"][::core::mem::offset_of!(IMPISPZone, zone) - 0usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_EnableTuning(void)\n\n ISP\n\n @param \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor."]
    pub fn IMP_ISP_EnableTuning() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DisableTuning(void)\n\n ISP\n\n @param \n\n @retval 0 \n @retval 0 \n\n @attention sensorISP."]
    pub fn IMP_ISP_DisableTuning() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSensorFPS(uint32_t fps_num, uint32_t fps_den)\n\n \n\n @param[in] fps_num \n @param[in] fps_den \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor  IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSensorFPS(fps_num: u32, fps_den: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorFPS(uint32_t *fps_num, uint32_t *fps_den)\n\n \n\n @param[in] fps_num \n @param[in] fps_den \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor  IMP_ISP_EnableTuning\n @attention "]
    pub fn IMP_ISP_Tuning_GetSensorFPS(fps_num: *mut u32, fps_den: *mut u32) -> libc::c_int;
}
#[repr(u32)]
#[doc = " ISP"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAntiflickerAttr {
    #[doc = "< ISP"]
    IMPISP_ANTIFLICKER_DISABLE = 0,
    #[doc = "< ISP, 50HZ"]
    IMPISP_ANTIFLICKER_50HZ = 1,
    #[doc = "< ISP60HZ"]
    IMPISP_ANTIFLICKER_60HZ = 2,
    #[doc = "< "]
    IMPISP_ANTIFLICKER_BUTT = 3,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAntiFlickerAttr(IMPISPAntiflickerAttr attr)\n\n ISP\n\n @param[in] attr \n\n @retval 0 \n @retval 0 \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetAntiFlickerAttr(attr: IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAntiFlickerAttr(IMPISPAntiflickerAttr *pattr)\n\n ISP\n\n @param[in] pattr \n\n @retval 0 \n @retval 0 \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetAntiFlickerAttr(pattr: *mut IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBrightness(unsigned char bright)\n\n ISP \n\n @param[in] bright \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetBrightness(bright: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBrightness(unsigned char *pbright)\n\n ISP \n\n @param[in] bright \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetBrightness(pbright: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetContrast(unsigned char contrast)\n\n ISP \n\n @param[in] contrast \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetContrast(contrast: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetContrast(unsigned char *pcontrast)\n\n ISP \n\n @param[in] contrast \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetContrast(pcontrast: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSharpness(unsigned char sharpness)\n\n ISP \n\n @param[in] sharpness \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetSharpness(sharpness: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSharpness(unsigned char *psharpness)\n\n ISP \n\n @param[in] sharpness \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetSharpness(psharpness: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBcshHue(unsigned char hue)\n\n \n\n @param[in] hue \n\n @retval 0 \n @retval 0 \n\n @remark 1281281280~255\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetBcshHue(hue: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBcshHue(unsigned char *hue)\n\n \n\n @param[out] hue \n\n @retval 0 \n @retval 0 \n\n @remark 1281281280~255\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetBcshHue(hue: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSaturation(unsigned char sat)\n\n ISP \n\n @param[in] sat \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetSaturation(sat: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSaturation(unsigned char *psat)\n\n ISP \n\n @param[in] sat \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetSaturation(psat: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPBypass(IMPISPTuningOpsMode enable)\n\n ISPbypass\n\n @param[in] enable bypass\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetISPBypass(enable: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetTotalGain(uint32_t *gain)\n\n ISP\n\n @param[in] gain ,[24.8]24bit8bit\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor  IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetTotalGain(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " ISP\n\n @fn int IMP_ISP_Tuning_SetISPHflip(IMPISPTuningOpsMode mode)\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPHflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPHflip(IMPISPTuningOpsMode *pmode)\n\n ISP\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPHflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip(IMPISPTuningOpsMode mode)\n\n ISP\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPVflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPVflip(IMPISPTuningOpsMode *pmode)\n\n ISP\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPVflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " Sensor\n\n @fn int IMP_ISP_Tuning_SetSensorHflip(IMPISPTuningOpsMode mode)\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSensorHflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorHflip(IMPISPTuningOpsMode *pmode)\n\n Sensor\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetSensorHflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip(IMPISPTuningOpsMode mode)\n\n Sensor\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSensorVflip(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorVflip(IMPISPTuningOpsMode *pmode)\n\n Sensor\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetSensorVflip(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
#[repr(u32)]
#[doc = " ISP "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPRunningMode {
    #[doc = "< "]
    IMPISP_RUNNING_MODE_DAY = 0,
    #[doc = "< "]
    IMPISP_RUNNING_MODE_NIGHT = 1,
    #[doc = "< "]
    IMPISP_RUNNING_MODE_BUTT = 2,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPRunningMode(IMPISPRunningMode mode)\n\n ISP\n\n @param[in] mode\n\n @retval 0 \n @retval 0 \n\n \n @code\n IMPISPRunningMode mode;\n\n\tif( it is during a night now){\nmode = IMPISP_RUNNING_MODE_NIGHT\n}else{\nmode = IMPISP_RUNNING_MODE_DAY;\n}\nret = IMP_ISP_Tuning_SetISPRunningMode(mode);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetISPRunningMode error !\\n\");\nreturn -1;\n}\n\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPRunningMode(mode: IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPRunningMode(IMPISPRunningMode *pmode)\n\n ISP\n\n @param[in] pmode\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPRunningMode(pmode: *mut IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPCustomMode(IMPISPTuningOpsMode mode)\n\n ISP Custom Mode.\n\n @param[in] mode Custom \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPCustomMode(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPCustomMode(IMPISPTuningOpsMode mode)\n\n ISP Custom Mode.\n\n @param[out] mode Custom \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPCustomMode(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
#[doc = " gamma"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPGamma {
    #[doc = "< gamma129"]
    pub gamma: [u16; 129usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPGamma"][::core::mem::size_of::<IMPISPGamma>() - 258usize];
    ["Alignment of IMPISPGamma"][::core::mem::align_of::<IMPISPGamma>() - 2usize];
    ["Offset of field: IMPISPGamma::gamma"][::core::mem::offset_of!(IMPISPGamma, gamma) - 0usize];
};
impl Default for IMPISPGamma {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetGamma(IMPISPGamma *gamma)\n\n GAMMA.\n @param[in] gamma gamma\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetGamma(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetGamma(IMPISPGamma *gamma)\n\n GAMMA.\n @param[out] gamma gamma\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetGamma(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeComp(int comp)\n\n AEAEAE target[0-255].\n @param[in] comp AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeComp(comp: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeComp(int *comp)\n\n AE\n @param[out] comp AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeComp(comp: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeLuma(int *luma)\n\n \n\n @param[out] luma AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeLuma(luma: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeFreeze(IMPISPTuningOpsMode mode)\n\n AE Freeze.\n\n @param[in] mode AE Freeze.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeFreeze(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_expr_mode {
    #[doc = "< "]
    ISP_CORE_EXPR_MODE_AUTO = 0,
    #[doc = "< "]
    ISP_CORE_EXPR_MODE_MANUAL = 1,
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_expr_unit {
    #[doc = "< "]
    ISP_CORE_EXPR_UNIT_LINE = 0,
    #[doc = "< "]
    ISP_CORE_EXPR_UNIT_US = 1,
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub union isp_core_expr_attr {
    pub s_attr: isp_core_expr_attr__bindgen_ty_1,
    pub g_attr: isp_core_expr_attr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_expr_attr__bindgen_ty_1 {
    #[doc = "< "]
    pub mode: isp_core_expr_mode,
    #[doc = "< "]
    pub unit: isp_core_expr_unit,
    pub time: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_expr_attr__bindgen_ty_1"]
        [::core::mem::size_of::<isp_core_expr_attr__bindgen_ty_1>() - 12usize];
    ["Alignment of isp_core_expr_attr__bindgen_ty_1"]
        [::core::mem::align_of::<isp_core_expr_attr__bindgen_ty_1>() - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_1::mode"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_1, mode) - 0usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_1::unit"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_1, unit) - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_1::time"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_1, time) - 8usize];
};
impl Default for isp_core_expr_attr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_expr_attr__bindgen_ty_2 {
    #[doc = "< "]
    pub mode: isp_core_expr_mode,
    #[doc = "< "]
    pub integration_time: u16,
    #[doc = "< "]
    pub integration_time_min: u16,
    #[doc = "< "]
    pub integration_time_max: u16,
    #[doc = "< "]
    pub one_line_expr_in_us: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_expr_attr__bindgen_ty_2"]
        [::core::mem::size_of::<isp_core_expr_attr__bindgen_ty_2>() - 12usize];
    ["Alignment of isp_core_expr_attr__bindgen_ty_2"]
        [::core::mem::align_of::<isp_core_expr_attr__bindgen_ty_2>() - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::mode"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, mode) - 0usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::integration_time"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, integration_time) - 4usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::integration_time_min"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, integration_time_min) - 6usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::integration_time_max"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, integration_time_max) - 8usize];
    ["Offset of field: isp_core_expr_attr__bindgen_ty_2::one_line_expr_in_us"]
        [::core::mem::offset_of!(isp_core_expr_attr__bindgen_ty_2, one_line_expr_in_us) - 10usize];
};
impl Default for isp_core_expr_attr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_expr_attr"][::core::mem::size_of::<isp_core_expr_attr>() - 12usize];
    ["Alignment of isp_core_expr_attr"][::core::mem::align_of::<isp_core_expr_attr>() - 4usize];
    ["Offset of field: isp_core_expr_attr::s_attr"]
        [::core::mem::offset_of!(isp_core_expr_attr, s_attr) - 0usize];
    ["Offset of field: isp_core_expr_attr::g_attr"]
        [::core::mem::offset_of!(isp_core_expr_attr, g_attr) - 0usize];
};
impl Default for isp_core_expr_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
pub type IMPISPExpr = isp_core_expr_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetExpr(IMPISPExpr *expr)\n\n AE\n\n @param[in] expr AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetExpr(expr: *mut IMPISPExpr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetExpr(IMPISPExpr *expr)\n\n AE\n\n @param[out] expr AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetExpr(expr: *mut IMPISPExpr) -> libc::c_int;
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub union isp_core_ae_roi_select {
    pub __anon1: isp_core_ae_roi_select__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_ae_roi_select__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_ae_roi_select__bindgen_ty_1"]
        [::core::mem::size_of::<isp_core_ae_roi_select__bindgen_ty_1>() - 4usize];
    ["Alignment of isp_core_ae_roi_select__bindgen_ty_1"]
        [::core::mem::align_of::<isp_core_ae_roi_select__bindgen_ty_1>() - 4usize];
};
impl isp_core_ae_roi_select__bindgen_ty_1 {
    #[inline]
    pub fn endy(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_endy(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn endx(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_endx(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn starty(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_starty(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn startx(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_startx(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endy: libc::c_uint,
        endx: libc::c_uint,
        starty: libc::c_uint,
        startx: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let endy: u32 = unsafe { ::core::mem::transmute(endy) };
            endy as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let endx: u32 = unsafe { ::core::mem::transmute(endx) };
            endx as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let starty: u32 = unsafe { ::core::mem::transmute(starty) };
            starty as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let startx: u32 = unsafe { ::core::mem::transmute(startx) };
            startx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_ae_roi_select"][::core::mem::size_of::<isp_core_ae_roi_select>() - 4usize];
    ["Alignment of isp_core_ae_roi_select"]
        [::core::mem::align_of::<isp_core_ae_roi_select>() - 4usize];
    ["Offset of field: isp_core_ae_roi_select::value"]
        [::core::mem::offset_of!(isp_core_ae_roi_select, value) - 0usize];
};
impl Default for isp_core_ae_roi_select {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
pub type IMPISPAERoi = isp_core_ae_roi_select;
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_wb_mode {
    #[doc = "< "]
    ISP_CORE_WB_MODE_AUTO = 0,
    #[doc = "< "]
    ISP_CORE_WB_MODE_MANUAL = 1,
    #[doc = "< "]
    ISP_CORE_WB_MODE_DAY_LIGHT = 2,
    #[doc = "< "]
    ISP_CORE_WB_MODE_CLOUDY = 3,
    #[doc = "< "]
    ISP_CORE_WB_MODE_INCANDESCENT = 4,
    #[doc = "< "]
    ISP_CORE_WB_MODE_FLOURESCENT = 5,
    #[doc = "< "]
    ISP_CORE_WB_MODE_TWILIGHT = 6,
    #[doc = "< "]
    ISP_CORE_WB_MODE_SHADE = 7,
    #[doc = "< "]
    ISP_CORE_WB_MODE_WARM_FLOURESCENT = 8,
    #[doc = "< "]
    ISP_CORE_WB_MODE_CUSTOM = 9,
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_wb_attr {
    #[doc = "< "]
    pub mode: isp_core_wb_mode,
    #[doc = "< "]
    pub rgain: u16,
    #[doc = "< "]
    pub bgain: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_wb_attr"][::core::mem::size_of::<isp_core_wb_attr>() - 8usize];
    ["Alignment of isp_core_wb_attr"][::core::mem::align_of::<isp_core_wb_attr>() - 4usize];
    ["Offset of field: isp_core_wb_attr::mode"]
        [::core::mem::offset_of!(isp_core_wb_attr, mode) - 0usize];
    ["Offset of field: isp_core_wb_attr::rgain"]
        [::core::mem::offset_of!(isp_core_wb_attr, rgain) - 4usize];
    ["Offset of field: isp_core_wb_attr::bgain"]
        [::core::mem::offset_of!(isp_core_wb_attr, bgain) - 6usize];
};
impl Default for isp_core_wb_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
pub type IMPISPWB = isp_core_wb_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB(IMPISPWB *wb)\n\n rgainbgain\n\n @param[in] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetWB(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetWB(IMPISPWB *wb)\n\n \n\n @param[out] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetWB(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_Statis(IMPISPWB *wb)\n\n \n\n @param[out] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetWB_Statis(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_GOL_Statis(IMPISPWB *wb)\n\n \n\n @param[out] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetWB_GOL_Statis(wb: *mut IMPISPWB) -> libc::c_int;
}
#[doc = " Cluster "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBCluster {
    pub ClusterEn: IMPISPTuningOpsMode,
    pub ToleranceEn: IMPISPTuningOpsMode,
    pub tolerance_th: libc::c_uint,
    pub awb_cluster: [libc::c_uint; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBCluster"][::core::mem::size_of::<IMPISPAWBCluster>() - 40usize];
    ["Alignment of IMPISPAWBCluster"][::core::mem::align_of::<IMPISPAWBCluster>() - 4usize];
    ["Offset of field: IMPISPAWBCluster::ClusterEn"]
        [::core::mem::offset_of!(IMPISPAWBCluster, ClusterEn) - 0usize];
    ["Offset of field: IMPISPAWBCluster::ToleranceEn"]
        [::core::mem::offset_of!(IMPISPAWBCluster, ToleranceEn) - 4usize];
    ["Offset of field: IMPISPAWBCluster::tolerance_th"]
        [::core::mem::offset_of!(IMPISPAWBCluster, tolerance_th) - 8usize];
    ["Offset of field: IMPISPAWBCluster::awb_cluster"]
        [::core::mem::offset_of!(IMPISPAWBCluster, awb_cluster) - 12usize];
};
impl Default for IMPISPAWBCluster {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbClust(IMPISPAWBCluster *awb_cluster);\n\n CLuster AWB\n\n @param[in] CLuster AWB awb_cluster[]Tuning\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbClust(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbClust(IMPISPAWBCluster *awb_cluster)\n\n CLuster AWB\n\n @param[out] CLuster AWB \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbClust(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAWBCtTrend {
    pub trend_array: [libc::c_uint; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBCtTrend"][::core::mem::size_of::<IMPISPAWBCtTrend>() - 24usize];
    ["Alignment of IMPISPAWBCtTrend"][::core::mem::align_of::<IMPISPAWBCtTrend>() - 4usize];
    ["Offset of field: IMPISPAWBCtTrend::trend_array"]
        [::core::mem::offset_of!(IMPISPAWBCtTrend, trend_array) - 0usize];
};
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbCtTrend(IMPISPAWBCtTrend *ct_trend);\n\n rgainbgainoffset\n\n @param[in] ct_trend rgainbgain offset\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbCtTrend(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_GetAwbCtTrend(IMPISPAWBCtTrend *ct_trend);\n\n rgain offsetbgain offset\n\n @param[out] ct_trend rgainbgain offset\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbCtTrend(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
#[doc = " ISP WB COEFFT parameter structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_rgb_coefft_wb_attr {
    pub rgb_coefft_wb_r: libc::c_ushort,
    pub rgb_coefft_wb_g: libc::c_ushort,
    pub rgb_coefft_wb_b: libc::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_rgb_coefft_wb_attr"]
        [::core::mem::size_of::<isp_core_rgb_coefft_wb_attr>() - 6usize];
    ["Alignment of isp_core_rgb_coefft_wb_attr"]
        [::core::mem::align_of::<isp_core_rgb_coefft_wb_attr>() - 2usize];
    ["Offset of field: isp_core_rgb_coefft_wb_attr::rgb_coefft_wb_r"]
        [::core::mem::offset_of!(isp_core_rgb_coefft_wb_attr, rgb_coefft_wb_r) - 0usize];
    ["Offset of field: isp_core_rgb_coefft_wb_attr::rgb_coefft_wb_g"]
        [::core::mem::offset_of!(isp_core_rgb_coefft_wb_attr, rgb_coefft_wb_g) - 2usize];
    ["Offset of field: isp_core_rgb_coefft_wb_attr::rgb_coefft_wb_b"]
        [::core::mem::offset_of!(isp_core_rgb_coefft_wb_attr, rgb_coefft_wb_b) - 4usize];
};
#[doc = " ISP WB COEFFT parameter structure."]
pub type IMPISPCOEFFTWB = isp_core_rgb_coefft_wb_attr;
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_GetRgbCoefft(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n sensor AWB RGB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_Awb_GetRgbCoefft(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_SetRgbCoefft(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n sensorAWB RGB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning\n\n \n @code\n IMPISPCOEFFTWB isp_core_rgb_coefft_wb_attr;\n\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_r=x;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_g=y;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_b=z;\nIMP_ISP_Tuning_Awb_SetRgbCoefft(&isp_core_rgb_coefft_wb_attr);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_Awb_SetRgbCoefft error !\\n\");\nreturn -1;\n}"]
    pub fn IMP_ISP_Tuning_Awb_SetRgbCoefft(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxAgain(uint32_t gain)\n\n sensorAgain\n\n @param[in] gain sensoragain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMaxAgain(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxAgain(uint32_t *gain)\n\n sensorAgain\n\n @param[out] gain sensoragain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMaxAgain(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxDgain(uint32_t gain)\n\n ISPDgain\n\n @param[in] ISP Dgain dgain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMaxDgain(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxDgain(uint32_t *gain)\n\n ISPDgain\n\n @param[out] ISP Dgain dgain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMaxDgain(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetVideoDrop(void (*cb)(void))\n\n sensor\n\n @param[in] cb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetVideoDrop(
        cb: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHiLightDepress(uint32_t strength)\n\n \n\n @param[in] strength .0-10], 0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetHiLightDepress(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHiLightDepress(uint32_t *strength)\n\n \n\n @param[out] strength .0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetHiLightDepress(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBacklightComp(uint32_t strength)\n\n \n\n @param[in] strength .0-10], 0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetBacklightComp(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBacklightComp(uint32_t *strength)\n\n \n\n @param[out] strength .0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetBacklightComp(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetTemperStrength(uint32_t ratio)\n\n 3D\n\n @param[in] ratio .128,128128.0-255]. *\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetTemperStrength(ratio: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSinterStrength(uint32_t ratio)\n\n 2D\n\n @param[in] ratio .128,128128.0-255].\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSinterStrength(ratio: u32) -> libc::c_int;
}
#[doc = " ISP EV "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPEVAttr {
    #[doc = "< "]
    pub ev: u32,
    #[doc = "< "]
    pub expr_us: u32,
    #[doc = "<log"]
    pub ev_log2: u32,
    #[doc = "< "]
    pub again: u32,
    #[doc = "< "]
    pub dgain: u32,
    #[doc = "< log"]
    pub gain_log2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPEVAttr"][::core::mem::size_of::<IMPISPEVAttr>() - 24usize];
    ["Alignment of IMPISPEVAttr"][::core::mem::align_of::<IMPISPEVAttr>() - 4usize];
    ["Offset of field: IMPISPEVAttr::ev"][::core::mem::offset_of!(IMPISPEVAttr, ev) - 0usize];
    ["Offset of field: IMPISPEVAttr::expr_us"]
        [::core::mem::offset_of!(IMPISPEVAttr, expr_us) - 4usize];
    ["Offset of field: IMPISPEVAttr::ev_log2"]
        [::core::mem::offset_of!(IMPISPEVAttr, ev_log2) - 8usize];
    ["Offset of field: IMPISPEVAttr::again"]
        [::core::mem::offset_of!(IMPISPEVAttr, again) - 12usize];
    ["Offset of field: IMPISPEVAttr::dgain"]
        [::core::mem::offset_of!(IMPISPEVAttr, dgain) - 16usize];
    ["Offset of field: IMPISPEVAttr::gain_log2"]
        [::core::mem::offset_of!(IMPISPEVAttr, gain_log2) - 20usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetEVAttr(IMPISPEVAttr *attr)\n\n EV\n @param[out] attr EV\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetEVAttr(attr: *mut IMPISPEVAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableMovestate(void)\n\n sensorISP\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_EnableMovestate() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_DisableMovestate(void)\n\n sensorISP\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_Tuning_EnableMovestate"]
    pub fn IMP_ISP_Tuning_DisableMovestate() -> libc::c_int;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPTuningMode {
    #[doc = "< "]
    IMPISP_TUNING_MODE_AUTO = 0,
    #[doc = "< "]
    IMPISP_TUNING_MODE_MANUAL = 1,
    #[doc = "< "]
    IMPISP_TUNING_MODE_RANGE = 2,
    #[doc = "< "]
    IMPISP_TUNING_MODE_BUTT = 3,
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPWeight {
    #[doc = "<  [0 ~ 8]"]
    pub weight: [[libc::c_uchar; 15usize]; 15usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPWeight"][::core::mem::size_of::<IMPISPWeight>() - 225usize];
    ["Alignment of IMPISPWeight"][::core::mem::align_of::<IMPISPWeight>() - 1usize];
    ["Offset of field: IMPISPWeight::weight"]
        [::core::mem::offset_of!(IMPISPWeight, weight) - 0usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeWeight(IMPISPWeight *ae_weight)\n\n AE\n\n @param[in] ae_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeWeight(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeWeight(IMPISPWeight *ae_weight)\n\n AE\n\n @param[out] ae_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeWeight(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_GetROI(IMPISPWeight *roi_weight)\n\n AE\n\n @param[out] roi_weight AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_AE_GetROI(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_SetROI(IMPISPWeight *roi_weight)\n\n AE\n\n @param[in] roi_weight AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_AE_SetROI(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbWeight(IMPISPWeight *awb_weight)\n\n AWB\n\n @param[in] awb_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbWeight(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbWeight(IMPISPWeight *awb_weight)\n\n AWB\n\n @param[out] awb_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbWeight(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
#[doc = " AWB"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBZone {
    #[doc = "< 15*15RGB"]
    pub zone_r: [libc::c_uchar; 225usize],
    #[doc = "< 15*15RGB"]
    pub zone_g: [libc::c_uchar; 225usize],
    #[doc = "< 15*15RGB"]
    pub zone_b: [libc::c_uchar; 225usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBZone"][::core::mem::size_of::<IMPISPAWBZone>() - 675usize];
    ["Alignment of IMPISPAWBZone"][::core::mem::align_of::<IMPISPAWBZone>() - 1usize];
    ["Offset of field: IMPISPAWBZone::zone_r"]
        [::core::mem::offset_of!(IMPISPAWBZone, zone_r) - 0usize];
    ["Offset of field: IMPISPAWBZone::zone_g"]
        [::core::mem::offset_of!(IMPISPAWBZone, zone_g) - 225usize];
    ["Offset of field: IMPISPAWBZone::zone_b"]
        [::core::mem::offset_of!(IMPISPAWBZone, zone_b) - 450usize];
};
impl Default for IMPISPAWBZone {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbZone(IMPISPAWBZONE *awb_zone)\n\n WB\n\n @param[out] awb_zone \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbZone(awb_zone: *mut IMPISPAWBZone) -> libc::c_int;
}
#[repr(u32)]
#[doc = " AWB algorithm"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAWBAlgo {
    IMPISP_AWB_ALGO_NORMAL = 0,
    IMPISP_AWB_ALGO_GRAYWORLD = 1,
    IMPISP_AWB_ALGO_REWEIGHT = 2,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_ALGO(IMPISPAWBALGO wb_algo)\n\n AWB\n\n @param[in] wb_algo AWB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetWB_ALGO(wb_algo: IMPISPAWBAlgo) -> libc::c_int;
}
#[doc = " AE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAEHist {
    #[doc = "< AEbin [0 ~ 255]"]
    pub ae_histhresh: [libc::c_uchar; 4usize],
    #[doc = "< AEbin [0 ~ 65535]"]
    pub ae_hist: [libc::c_ushort; 5usize],
    #[doc = "<  [0 ~ 15]"]
    pub ae_stat_nodeh: libc::c_uchar,
    #[doc = "<  [0 ~ 15]"]
    pub ae_stat_nodev: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEHist"][::core::mem::size_of::<IMPISPAEHist>() - 16usize];
    ["Alignment of IMPISPAEHist"][::core::mem::align_of::<IMPISPAEHist>() - 2usize];
    ["Offset of field: IMPISPAEHist::ae_histhresh"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_histhresh) - 0usize];
    ["Offset of field: IMPISPAEHist::ae_hist"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_hist) - 4usize];
    ["Offset of field: IMPISPAEHist::ae_stat_nodeh"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_stat_nodeh) - 14usize];
    ["Offset of field: IMPISPAEHist::ae_stat_nodev"]
        [::core::mem::offset_of!(IMPISPAEHist, ae_stat_nodev) - 15usize];
};
#[doc = " AE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEHistOrigin {
    #[doc = "< AE256 bin"]
    pub ae_hist: [libc::c_uint; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEHistOrigin"][::core::mem::size_of::<IMPISPAEHistOrigin>() - 1024usize];
    ["Alignment of IMPISPAEHistOrigin"][::core::mem::align_of::<IMPISPAEHistOrigin>() - 4usize];
    ["Offset of field: IMPISPAEHistOrigin::ae_hist"]
        [::core::mem::offset_of!(IMPISPAEHistOrigin, ae_hist) - 0usize];
};
impl Default for IMPISPAEHistOrigin {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeHist(IMPISPAEHist *ae_hist)\n\n AE\n\n @param[in] ae_hist AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeHist(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist(IMPISPAEHist *ae_hist)\n\n AE\n\n @param[out] ae_hist AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeHist(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Origin(IMPISPAEHistOrigin *ae_hist)\n\n AE 256 bin\n\n @param[out] ae_hist AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeHist_Origin(ae_hist: *mut IMPISPAEHistOrigin) -> libc::c_int;
}
#[doc = " AWB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_awb_sta_info {
    #[doc = "< AWBr/g [0 ~ 4095]"]
    pub r_gain: libc::c_ushort,
    #[doc = "< AWBb/g [0 ~ 4095]"]
    pub b_gain: libc::c_ushort,
    #[doc = "< AWB [0 ~ 4294967295]"]
    pub awb_sum: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_awb_sta_info"][::core::mem::size_of::<isp_core_awb_sta_info>() - 8usize];
    ["Alignment of isp_core_awb_sta_info"]
        [::core::mem::align_of::<isp_core_awb_sta_info>() - 4usize];
    ["Offset of field: isp_core_awb_sta_info::r_gain"]
        [::core::mem::offset_of!(isp_core_awb_sta_info, r_gain) - 0usize];
    ["Offset of field: isp_core_awb_sta_info::b_gain"]
        [::core::mem::offset_of!(isp_core_awb_sta_info, b_gain) - 2usize];
    ["Offset of field: isp_core_awb_sta_info::awb_sum"]
        [::core::mem::offset_of!(isp_core_awb_sta_info, awb_sum) - 4usize];
};
#[repr(u32)]
#[doc = " AWB"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum isp_core_awb_stats_mode {
    #[doc = "< "]
    IMPISP_AWB_STATS_LEGACY_MODE = 0,
    #[doc = "< "]
    IMPISP_AWB_STATS_CURRENT_MODE = 1,
    IMPISP_AWB_STATS_MODE_BUTT = 2,
}
#[doc = " AWB"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBHist {
    #[doc = "< AWB"]
    pub awb_stat: isp_core_awb_sta_info,
    #[doc = "< AWB"]
    pub awb_stats_mode: isp_core_awb_stats_mode,
    #[doc = "< AWB [0 ~ 1023]"]
    pub awb_whitelevel: libc::c_ushort,
    #[doc = "< AWB [0 ~ 1023]"]
    pub awb_blacklevel: libc::c_ushort,
    #[doc = "< AWBr/g [0 ~ 4095]"]
    pub cr_ref_max: libc::c_ushort,
    #[doc = "< AWBr/g [0 ~ 4095]"]
    pub cr_ref_min: libc::c_ushort,
    #[doc = "< AWBb/g  [0 ~ 4095]"]
    pub cb_ref_max: libc::c_ushort,
    #[doc = "< AWBb/g  [0 ~ 4095]"]
    pub cb_ref_min: libc::c_ushort,
    #[doc = "<  [0 ~ 15]"]
    pub awb_stat_nodeh: libc::c_uchar,
    #[doc = "<  [0 ~ 15]"]
    pub awb_stat_nodev: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAWBHist"][::core::mem::size_of::<IMPISPAWBHist>() - 28usize];
    ["Alignment of IMPISPAWBHist"][::core::mem::align_of::<IMPISPAWBHist>() - 4usize];
    ["Offset of field: IMPISPAWBHist::awb_stat"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stat) - 0usize];
    ["Offset of field: IMPISPAWBHist::awb_stats_mode"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stats_mode) - 8usize];
    ["Offset of field: IMPISPAWBHist::awb_whitelevel"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_whitelevel) - 12usize];
    ["Offset of field: IMPISPAWBHist::awb_blacklevel"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_blacklevel) - 14usize];
    ["Offset of field: IMPISPAWBHist::cr_ref_max"]
        [::core::mem::offset_of!(IMPISPAWBHist, cr_ref_max) - 16usize];
    ["Offset of field: IMPISPAWBHist::cr_ref_min"]
        [::core::mem::offset_of!(IMPISPAWBHist, cr_ref_min) - 18usize];
    ["Offset of field: IMPISPAWBHist::cb_ref_max"]
        [::core::mem::offset_of!(IMPISPAWBHist, cb_ref_max) - 20usize];
    ["Offset of field: IMPISPAWBHist::cb_ref_min"]
        [::core::mem::offset_of!(IMPISPAWBHist, cb_ref_min) - 22usize];
    ["Offset of field: IMPISPAWBHist::awb_stat_nodeh"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stat_nodeh) - 24usize];
    ["Offset of field: IMPISPAWBHist::awb_stat_nodev"]
        [::core::mem::offset_of!(IMPISPAWBHist, awb_stat_nodev) - 25usize];
};
impl Default for IMPISPAWBHist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbHist(IMPISPAWBHist *awb_hist)\n\n AWB\n\n @param[out] awb_hist AWB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbHist(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbHist(IMPISPAWBHist *awb_hist)\n\n AWB\n\n @param[in] awb_hist AWB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbHist(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_core_af_sta_info {
    #[doc = "< AF"]
    pub af_metrics: libc::c_uint,
    #[doc = "< AF"]
    pub af_metrics_alt: libc::c_uint,
    pub af_wl: libc::c_uint,
    pub af_wh: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_core_af_sta_info"][::core::mem::size_of::<isp_core_af_sta_info>() - 16usize];
    ["Alignment of isp_core_af_sta_info"][::core::mem::align_of::<isp_core_af_sta_info>() - 4usize];
    ["Offset of field: isp_core_af_sta_info::af_metrics"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_metrics) - 0usize];
    ["Offset of field: isp_core_af_sta_info::af_metrics_alt"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_metrics_alt) - 4usize];
    ["Offset of field: isp_core_af_sta_info::af_wl"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_wl) - 8usize];
    ["Offset of field: isp_core_af_sta_info::af_wh"]
        [::core::mem::offset_of!(isp_core_af_sta_info, af_wh) - 12usize];
};
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_af_ldg_en_info {
    pub fir0_en: libc::c_uchar,
    pub fir1_en: libc::c_uchar,
    pub iir0_en: libc::c_uchar,
    pub iir1_en: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_af_ldg_en_info"][::core::mem::size_of::<isp_af_ldg_en_info>() - 4usize];
    ["Alignment of isp_af_ldg_en_info"][::core::mem::align_of::<isp_af_ldg_en_info>() - 1usize];
    ["Offset of field: isp_af_ldg_en_info::fir0_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, fir0_en) - 0usize];
    ["Offset of field: isp_af_ldg_en_info::fir1_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, fir1_en) - 1usize];
    ["Offset of field: isp_af_ldg_en_info::iir0_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, iir0_en) - 2usize];
    ["Offset of field: isp_af_ldg_en_info::iir1_en"]
        [::core::mem::offset_of!(isp_af_ldg_en_info, iir1_en) - 3usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isp_ldg_info {
    pub thlow1: libc::c_uchar,
    pub thlow2: libc::c_uchar,
    pub slplow: libc::c_ushort,
    pub gainlow: libc::c_uchar,
    pub thhigh1: libc::c_uchar,
    pub thhigh2: libc::c_uchar,
    pub slphigh: libc::c_ushort,
    pub gainhigh: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_ldg_info"][::core::mem::size_of::<isp_ldg_info>() - 12usize];
    ["Alignment of isp_ldg_info"][::core::mem::align_of::<isp_ldg_info>() - 2usize];
    ["Offset of field: isp_ldg_info::thlow1"]
        [::core::mem::offset_of!(isp_ldg_info, thlow1) - 0usize];
    ["Offset of field: isp_ldg_info::thlow2"]
        [::core::mem::offset_of!(isp_ldg_info, thlow2) - 1usize];
    ["Offset of field: isp_ldg_info::slplow"]
        [::core::mem::offset_of!(isp_ldg_info, slplow) - 2usize];
    ["Offset of field: isp_ldg_info::gainlow"]
        [::core::mem::offset_of!(isp_ldg_info, gainlow) - 4usize];
    ["Offset of field: isp_ldg_info::thhigh1"]
        [::core::mem::offset_of!(isp_ldg_info, thhigh1) - 5usize];
    ["Offset of field: isp_ldg_info::thhigh2"]
        [::core::mem::offset_of!(isp_ldg_info, thhigh2) - 6usize];
    ["Offset of field: isp_ldg_info::slphigh"]
        [::core::mem::offset_of!(isp_ldg_info, slphigh) - 8usize];
    ["Offset of field: isp_ldg_info::gainhigh"]
        [::core::mem::offset_of!(isp_ldg_info, gainhigh) - 10usize];
};
#[doc = " AF"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAFHist {
    pub af_stat: isp_core_af_sta_info,
    #[doc = "< AF"]
    pub af_enable: libc::c_uchar,
    #[doc = "< AF 012"]
    pub af_metrics_shift: libc::c_uchar,
    #[doc = "< AF [0 ~ 64]"]
    pub af_delta: libc::c_ushort,
    #[doc = "< AF [0 ~ 64]"]
    pub af_theta: libc::c_ushort,
    #[doc = "< AF [0 ~ 255]"]
    pub af_hilight_th: libc::c_ushort,
    #[doc = "< AF [0 ~ 64]"]
    pub af_alpha_alt: libc::c_ushort,
    #[doc = "< AF [0 ~ 64]"]
    pub af_belta_alt: libc::c_ushort,
    #[doc = "< AF[1-width]"]
    pub af_hstart: libc::c_uchar,
    #[doc = "< AF [3-height]"]
    pub af_vstart: libc::c_uchar,
    #[doc = "<  [15]H"]
    pub af_stat_nodeh: libc::c_uchar,
    #[doc = "<  [15]V"]
    pub af_stat_nodev: libc::c_uchar,
    pub af_frame_num: libc::c_uchar,
    #[doc = "< LDG"]
    pub ldg_en: isp_af_ldg_en_info,
    pub af_fir0: isp_ldg_info,
    pub af_fir1: isp_ldg_info,
    pub af_iir0: isp_ldg_info,
    pub af_iir1: isp_ldg_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAFHist"][::core::mem::size_of::<IMPISPAFHist>() - 88usize];
    ["Alignment of IMPISPAFHist"][::core::mem::align_of::<IMPISPAFHist>() - 4usize];
    ["Offset of field: IMPISPAFHist::af_stat"]
        [::core::mem::offset_of!(IMPISPAFHist, af_stat) - 0usize];
    ["Offset of field: IMPISPAFHist::af_enable"]
        [::core::mem::offset_of!(IMPISPAFHist, af_enable) - 16usize];
    ["Offset of field: IMPISPAFHist::af_metrics_shift"]
        [::core::mem::offset_of!(IMPISPAFHist, af_metrics_shift) - 17usize];
    ["Offset of field: IMPISPAFHist::af_delta"]
        [::core::mem::offset_of!(IMPISPAFHist, af_delta) - 18usize];
    ["Offset of field: IMPISPAFHist::af_theta"]
        [::core::mem::offset_of!(IMPISPAFHist, af_theta) - 20usize];
    ["Offset of field: IMPISPAFHist::af_hilight_th"]
        [::core::mem::offset_of!(IMPISPAFHist, af_hilight_th) - 22usize];
    ["Offset of field: IMPISPAFHist::af_alpha_alt"]
        [::core::mem::offset_of!(IMPISPAFHist, af_alpha_alt) - 24usize];
    ["Offset of field: IMPISPAFHist::af_belta_alt"]
        [::core::mem::offset_of!(IMPISPAFHist, af_belta_alt) - 26usize];
    ["Offset of field: IMPISPAFHist::af_hstart"]
        [::core::mem::offset_of!(IMPISPAFHist, af_hstart) - 28usize];
    ["Offset of field: IMPISPAFHist::af_vstart"]
        [::core::mem::offset_of!(IMPISPAFHist, af_vstart) - 29usize];
    ["Offset of field: IMPISPAFHist::af_stat_nodeh"]
        [::core::mem::offset_of!(IMPISPAFHist, af_stat_nodeh) - 30usize];
    ["Offset of field: IMPISPAFHist::af_stat_nodev"]
        [::core::mem::offset_of!(IMPISPAFHist, af_stat_nodev) - 31usize];
    ["Offset of field: IMPISPAFHist::af_frame_num"]
        [::core::mem::offset_of!(IMPISPAFHist, af_frame_num) - 32usize];
    ["Offset of field: IMPISPAFHist::ldg_en"]
        [::core::mem::offset_of!(IMPISPAFHist, ldg_en) - 33usize];
    ["Offset of field: IMPISPAFHist::af_fir0"]
        [::core::mem::offset_of!(IMPISPAFHist, af_fir0) - 38usize];
    ["Offset of field: IMPISPAFHist::af_fir1"]
        [::core::mem::offset_of!(IMPISPAFHist, af_fir1) - 50usize];
    ["Offset of field: IMPISPAFHist::af_iir0"]
        [::core::mem::offset_of!(IMPISPAFHist, af_iir0) - 62usize];
    ["Offset of field: IMPISPAFHist::af_iir1"]
        [::core::mem::offset_of!(IMPISPAFHist, af_iir1) - 74usize];
};
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetAFMetrices(unsigned int *metric);\n\n AF\n\n @param[out] metric AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAFMetrices(metric: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfHist(IMPISPAFHist *af_hist);\n\n AF\n\n @param[out] af_hist AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAfHist(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfHist(IMPISPAFHist *af_hist)\n\n AF\n\n @param[in] af_hist AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAfHist(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfWeight(IMPISPWeight *af_weight)\n\n AF\n\n @param[in] af_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAfWeight(af_weigh: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfWeight(IMPISPWeight *af_weight)\n\n AF\n\n @param[out] af_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAfWeight(af_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfZone(IMPISPZone *af_zone)\n\n AFzone\n\n @param[out] af_zone AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAfZone(af_zone: *mut IMPISPZone) -> libc::c_int;
}
#[doc = " ISP Wait Frame "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPWaitFrameAttr {
    #[doc = "< ms"]
    pub timeout: u32,
    #[doc = "< Frame"]
    pub cnt: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPWaitFrameAttr"][::core::mem::size_of::<IMPISPWaitFrameAttr>() - 16usize];
    ["Alignment of IMPISPWaitFrameAttr"][::core::mem::align_of::<IMPISPWaitFrameAttr>() - 8usize];
    ["Offset of field: IMPISPWaitFrameAttr::timeout"]
        [::core::mem::offset_of!(IMPISPWaitFrameAttr, timeout) - 0usize];
    ["Offset of field: IMPISPWaitFrameAttr::cnt"]
        [::core::mem::offset_of!(IMPISPWaitFrameAttr, cnt) - 8usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_WaitFrame(IMPISPWaitFrameAttr *attr)\n \n\n @param[out] attr \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_WaitFrame(attr: *mut IMPISPWaitFrameAttr) -> libc::c_int;
}
#[doc = " AE Min"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAEMin {
    #[doc = "< AE"]
    pub min_it: libc::c_uint,
    #[doc = "< AE "]
    pub min_again: libc::c_uint,
    #[doc = "< AE"]
    pub min_it_short: libc::c_uint,
    #[doc = "< AE "]
    pub min_again_short: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEMin"][::core::mem::size_of::<IMPISPAEMin>() - 16usize];
    ["Alignment of IMPISPAEMin"][::core::mem::align_of::<IMPISPAEMin>() - 4usize];
    ["Offset of field: IMPISPAEMin::min_it"][::core::mem::offset_of!(IMPISPAEMin, min_it) - 0usize];
    ["Offset of field: IMPISPAEMin::min_again"]
        [::core::mem::offset_of!(IMPISPAEMin, min_again) - 4usize];
    ["Offset of field: IMPISPAEMin::min_it_short"]
        [::core::mem::offset_of!(IMPISPAEMin, min_it_short) - 8usize];
    ["Offset of field: IMPISPAEMin::min_again_short"]
        [::core::mem::offset_of!(IMPISPAEMin, min_again_short) - 12usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeMin(IMPISPAEMin *ae_min)\n\n AE\n\n @param[in] ae_min AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeMin(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeMin(IMPISPAEMin *ae_min)\n\n AE\n\n @param[out] ae_min AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeMin(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAe_IT_MAX(unsigned int it_max)\n\n AE\n\n @param[in] it_max AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAe_IT_MAX(it_max: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAE_IT_MAX(unsigned int *it_max)\n\n AE\n\n @param[out] it_max AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAE_IT_MAX(it_max: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeZone(IMPISPZone *ae_zone)\n\n AEzoneY\n\n @param[out] ae_zone AEY\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeZone(ae_zone: *mut IMPISPZone) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAETargetList {
    pub at_list: [libc::c_uint; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAETargetList"][::core::mem::size_of::<IMPISPAETargetList>() - 40usize];
    ["Alignment of IMPISPAETargetList"][::core::mem::align_of::<IMPISPAETargetList>() - 4usize];
    ["Offset of field: IMPISPAETargetList::at_list"]
        [::core::mem::offset_of!(IMPISPAETargetList, at_list) - 0usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList(IMPISPAETargetList *target_list)\n\n AE\n\n @param[in] target_list  \n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeTargetList(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList(IMPISPAETargetList *target_list)\n\n AE\n\n @param[out] target_list  \n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeTargetList(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
#[doc = " ISP Module Control"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPISPModuleCtl {
    pub key: libc::c_uint,
    pub __anon1: IMPISPModuleCtl__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPModuleCtl__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPModuleCtl__bindgen_ty_1"]
        [::core::mem::size_of::<IMPISPModuleCtl__bindgen_ty_1>() - 4usize];
    ["Alignment of IMPISPModuleCtl__bindgen_ty_1"]
        [::core::mem::align_of::<IMPISPModuleCtl__bindgen_ty_1>() - 4usize];
};
impl IMPISPModuleCtl__bindgen_ty_1 {
    #[inline]
    pub fn bitBypassBLC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassBLC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassGIB(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassGIB(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassAG(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassAG(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDPC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDPC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassRDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassRDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassLSC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassLSC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassADR(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassADR(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDMSC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDMSC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCCM(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCCM(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassGAMMA(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassGAMMA(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDEFOG(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDEFOG(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCSC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCSC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCLM(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCLM(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassSP(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassSP(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassYDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassYDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassBCSH(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassBCSH(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassSDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassSDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassHLDC(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassHLDC(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitRsv(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_bitRsv(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassMDNS(&self) -> libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassMDNS(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bitBypassBLC: libc::c_uint,
        bitBypassGIB: libc::c_uint,
        bitBypassAG: libc::c_uint,
        bitBypassDPC: libc::c_uint,
        bitBypassRDNS: libc::c_uint,
        bitBypassLSC: libc::c_uint,
        bitBypassADR: libc::c_uint,
        bitBypassDMSC: libc::c_uint,
        bitBypassCCM: libc::c_uint,
        bitBypassGAMMA: libc::c_uint,
        bitBypassDEFOG: libc::c_uint,
        bitBypassCSC: libc::c_uint,
        bitBypassCLM: libc::c_uint,
        bitBypassSP: libc::c_uint,
        bitBypassYDNS: libc::c_uint,
        bitBypassBCSH: libc::c_uint,
        bitBypassSDNS: libc::c_uint,
        bitBypassHLDC: libc::c_uint,
        bitRsv: libc::c_uint,
        bitBypassMDNS: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bitBypassBLC: u32 = unsafe { ::core::mem::transmute(bitBypassBLC) };
            bitBypassBLC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bitBypassGIB: u32 = unsafe { ::core::mem::transmute(bitBypassGIB) };
            bitBypassGIB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bitBypassAG: u32 = unsafe { ::core::mem::transmute(bitBypassAG) };
            bitBypassAG as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bitBypassDPC: u32 = unsafe { ::core::mem::transmute(bitBypassDPC) };
            bitBypassDPC as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bitBypassRDNS: u32 = unsafe { ::core::mem::transmute(bitBypassRDNS) };
            bitBypassRDNS as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bitBypassLSC: u32 = unsafe { ::core::mem::transmute(bitBypassLSC) };
            bitBypassLSC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bitBypassADR: u32 = unsafe { ::core::mem::transmute(bitBypassADR) };
            bitBypassADR as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bitBypassDMSC: u32 = unsafe { ::core::mem::transmute(bitBypassDMSC) };
            bitBypassDMSC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bitBypassCCM: u32 = unsafe { ::core::mem::transmute(bitBypassCCM) };
            bitBypassCCM as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bitBypassGAMMA: u32 = unsafe { ::core::mem::transmute(bitBypassGAMMA) };
            bitBypassGAMMA as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bitBypassDEFOG: u32 = unsafe { ::core::mem::transmute(bitBypassDEFOG) };
            bitBypassDEFOG as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bitBypassCSC: u32 = unsafe { ::core::mem::transmute(bitBypassCSC) };
            bitBypassCSC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let bitBypassCLM: u32 = unsafe { ::core::mem::transmute(bitBypassCLM) };
            bitBypassCLM as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let bitBypassSP: u32 = unsafe { ::core::mem::transmute(bitBypassSP) };
            bitBypassSP as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let bitBypassYDNS: u32 = unsafe { ::core::mem::transmute(bitBypassYDNS) };
            bitBypassYDNS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let bitBypassBCSH: u32 = unsafe { ::core::mem::transmute(bitBypassBCSH) };
            bitBypassBCSH as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bitBypassSDNS: u32 = unsafe { ::core::mem::transmute(bitBypassSDNS) };
            bitBypassSDNS as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let bitBypassHLDC: u32 = unsafe { ::core::mem::transmute(bitBypassHLDC) };
            bitBypassHLDC as u64
        });
        __bindgen_bitfield_unit.set(18usize, 12u8, {
            let bitRsv: u32 = unsafe { ::core::mem::transmute(bitRsv) };
            bitRsv as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let bitBypassMDNS: u32 = unsafe { ::core::mem::transmute(bitBypassMDNS) };
            bitBypassMDNS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPModuleCtl"][::core::mem::size_of::<IMPISPModuleCtl>() - 4usize];
    ["Alignment of IMPISPModuleCtl"][::core::mem::align_of::<IMPISPModuleCtl>() - 4usize];
    ["Offset of field: IMPISPModuleCtl::key"]
        [::core::mem::offset_of!(IMPISPModuleCtl, key) - 0usize];
};
impl Default for IMPISPModuleCtl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetModuleControl(IMPISPModuleCtl *ispmodule)\n\n ISPbypass\n\n @param[in] ispmodule ISPbypass.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetModuleControl(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetModuleControl(IMPISPModuleCtl *ispmodule)\n\n ISPbypass.\n\n @param[out] ispmodule ISPbypass\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetModuleControl(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
#[doc = " ISP Front Crop Attribution"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPFrontCrop {
    pub fcrop_enable: bool,
    pub fcrop_top: libc::c_uint,
    pub fcrop_left: libc::c_uint,
    pub fcrop_width: libc::c_uint,
    pub fcrop_height: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFrontCrop"][::core::mem::size_of::<IMPISPFrontCrop>() - 20usize];
    ["Alignment of IMPISPFrontCrop"][::core::mem::align_of::<IMPISPFrontCrop>() - 4usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_enable"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_enable) - 0usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_top"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_top) - 4usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_left"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_left) - 8usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_width"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_width) - 12usize];
    ["Offset of field: IMPISPFrontCrop::fcrop_height"]
        [::core::mem::offset_of!(IMPISPFrontCrop, fcrop_height) - 16usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetFrontCrop(IMPISPFrontCrop *ispfrontcrop)\n\n ISPCrop\n\n @param[in] ispfrontcrop Crop\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetFrontCrop(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetFrontCrop(IMPISPFrontCrop *ispfrontcrop)\n\n Crop.\n\n @param[out] ispfrontcrop Crop\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetFrontCrop(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDPC_Strength(unsigned int strength)\n\n DPC.\n\n @param[in] strength .128,128128.0-255]\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDPC_Strength(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDPC_Strength(unsigned int *strength)\n\n DPC.\n\n @param[out] strength .128,128128.0-255]\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDPC_Strength(ratio: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDRC_Strength(unsigned int ratio)\n\n DRC.\n\n @param[in] strength .128,128128.0-255]\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDRC_Strength(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDRC_Strength(unsigned int *ratio)\n\n DRC.\n\n @param[out] ratio .128,128128.0-255]\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDRC_Strength(ratio: *mut libc::c_uint) -> libc::c_int;
}
#[repr(u32)]
#[doc = " HV Flip "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPHVFLIP {
    #[doc = "< "]
    IMPISP_FLIP_NORMAL_MODE = 0,
    #[doc = "< "]
    IMPISP_FLIP_H_MODE = 1,
    #[doc = "< "]
    IMPISP_FLIP_V_MODE = 2,
    #[doc = "< "]
    IMPISP_FLIP_HV_MODE = 3,
    IMPISP_FLIP_MODE_BUTT = 4,
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHVFLIP(IMPISPHVFLIP hvflip)\n\n HV Flip.\n\n @param[in] hvflip HV Flip.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetHVFLIP(hvflip: IMPISPHVFLIP) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHVFlip(IMPISPHVFLIP *hvflip)\n\n HV Flip.\n\n @param[out] hvflip HV Flip.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetHVFlip(hvflip: *mut IMPISPHVFLIP) -> libc::c_int;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISP_MASK_TYPE {
    #[doc = "< RGB"]
    IMPISP_MASK_TYPE_RGB = 0,
    #[doc = "< YUV"]
    IMPISP_MASK_TYPE_YUV = 1,
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub union mask_value {
    #[doc = "< RGB"]
    pub mask_rgb: mask_value__bindgen_ty_1,
    #[doc = "< YUV"]
    pub mask_ayuv: mask_value__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mask_value__bindgen_ty_1 {
    #[doc = "< R "]
    pub Red: libc::c_uchar,
    #[doc = "< G "]
    pub Green: libc::c_uchar,
    #[doc = "< B "]
    pub Blue: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask_value__bindgen_ty_1"]
        [::core::mem::size_of::<mask_value__bindgen_ty_1>() - 3usize];
    ["Alignment of mask_value__bindgen_ty_1"]
        [::core::mem::align_of::<mask_value__bindgen_ty_1>() - 1usize];
    ["Offset of field: mask_value__bindgen_ty_1::Red"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_1, Red) - 0usize];
    ["Offset of field: mask_value__bindgen_ty_1::Green"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_1, Green) - 1usize];
    ["Offset of field: mask_value__bindgen_ty_1::Blue"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_1, Blue) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mask_value__bindgen_ty_2 {
    #[doc = "< Y "]
    pub y_value: libc::c_uchar,
    #[doc = "< U "]
    pub u_value: libc::c_uchar,
    #[doc = "< V "]
    pub v_value: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask_value__bindgen_ty_2"]
        [::core::mem::size_of::<mask_value__bindgen_ty_2>() - 3usize];
    ["Alignment of mask_value__bindgen_ty_2"]
        [::core::mem::align_of::<mask_value__bindgen_ty_2>() - 1usize];
    ["Offset of field: mask_value__bindgen_ty_2::y_value"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_2, y_value) - 0usize];
    ["Offset of field: mask_value__bindgen_ty_2::u_value"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_2, u_value) - 1usize];
    ["Offset of field: mask_value__bindgen_ty_2::v_value"]
        [::core::mem::offset_of!(mask_value__bindgen_ty_2, v_value) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask_value"][::core::mem::size_of::<mask_value>() - 3usize];
    ["Alignment of mask_value"][::core::mem::align_of::<mask_value>() - 1usize];
    ["Offset of field: mask_value::mask_rgb"]
        [::core::mem::offset_of!(mask_value, mask_rgb) - 0usize];
    ["Offset of field: mask_value::mask_ayuv"]
        [::core::mem::offset_of!(mask_value, mask_ayuv) - 0usize];
};
impl Default for mask_value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
pub type IMP_ISP_MASK_VALUE = mask_value;
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISP_MASK_BLOCK_PAR {
    #[doc = "< "]
    pub mask_en: libc::c_uchar,
    #[doc = "< y"]
    pub mask_pos_top: libc::c_ushort,
    #[doc = "< x"]
    pub mask_pos_left: libc::c_ushort,
    #[doc = "< "]
    pub mask_width: libc::c_ushort,
    #[doc = "< "]
    pub mask_height: libc::c_ushort,
    #[doc = "< "]
    pub mask_value: IMP_ISP_MASK_VALUE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISP_MASK_BLOCK_PAR"][::core::mem::size_of::<IMPISP_MASK_BLOCK_PAR>() - 14usize];
    ["Alignment of IMPISP_MASK_BLOCK_PAR"]
        [::core::mem::align_of::<IMPISP_MASK_BLOCK_PAR>() - 2usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_en"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_en) - 0usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_pos_top"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_pos_top) - 2usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_pos_left"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_pos_left) - 4usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_width"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_width) - 6usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_height"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_height) - 8usize];
    ["Offset of field: IMPISP_MASK_BLOCK_PAR::mask_value"]
        [::core::mem::offset_of!(IMPISP_MASK_BLOCK_PAR, mask_value) - 10usize];
};
impl Default for IMPISP_MASK_BLOCK_PAR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPMASKAttr {
    #[doc = "< 0"]
    pub chn0: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< 1"]
    pub chn1: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< 3"]
    pub chn2: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< "]
    pub mask_type: IMPISP_MASK_TYPE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPMASKAttr"][::core::mem::size_of::<IMPISPMASKAttr>() - 172usize];
    ["Alignment of IMPISPMASKAttr"][::core::mem::align_of::<IMPISPMASKAttr>() - 4usize];
    ["Offset of field: IMPISPMASKAttr::chn0"]
        [::core::mem::offset_of!(IMPISPMASKAttr, chn0) - 0usize];
    ["Offset of field: IMPISPMASKAttr::chn1"]
        [::core::mem::offset_of!(IMPISPMASKAttr, chn1) - 56usize];
    ["Offset of field: IMPISPMASKAttr::chn2"]
        [::core::mem::offset_of!(IMPISPMASKAttr, chn2) - 112usize];
    ["Offset of field: IMPISPMASKAttr::mask_type"]
        [::core::mem::offset_of!(IMPISPMASKAttr, mask_type) - 168usize];
};
impl Default for IMPISPMASKAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMask(IMPISPMASKAttr *mask)\n\n .\n\n @param[in] mask .\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMask(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMask(IMPISPMASKAttr *mask)\n\n .\n\n @param[out] mask .\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMask(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
#[doc = " Sensor"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPSENSORAttr {
    #[doc = "< sensor hts"]
    pub hts: libc::c_uint,
    #[doc = "< sensor vts"]
    pub vts: libc::c_uint,
    #[doc = "< sensor "]
    pub fps: libc::c_uint,
    #[doc = "< sensor"]
    pub width: libc::c_uint,
    #[doc = "< sensor"]
    pub height: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPSENSORAttr"][::core::mem::size_of::<IMPISPSENSORAttr>() - 20usize];
    ["Alignment of IMPISPSENSORAttr"][::core::mem::align_of::<IMPISPSENSORAttr>() - 4usize];
    ["Offset of field: IMPISPSENSORAttr::hts"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, hts) - 0usize];
    ["Offset of field: IMPISPSENSORAttr::vts"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, vts) - 4usize];
    ["Offset of field: IMPISPSENSORAttr::fps"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, fps) - 8usize];
    ["Offset of field: IMPISPSENSORAttr::width"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, width) - 12usize];
    ["Offset of field: IMPISPSENSORAttr::height"]
        [::core::mem::offset_of!(IMPISPSENSORAttr, height) - 16usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorAttr(IMPISPSENSORAttr *attr)\n\n .\n\n @param[out] attr sensor.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetSensorAttr(attr: *mut IMPISPSENSORAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDRC(IMPISPTuningOpsMode mode)\n\n DRC.\n\n @param[out] mode DRC.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_EnableDRC(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDefog(IMPISPTuningOpsMode mode)\n\n Defog.\n\n @param[out] mode Defog.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_EnableDefog(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbCt(unsigned int *ct)\n\n AWB.\n\n @param[in] ct AWB.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbCt(ct: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAWBCt(unsigned int *ct)\n\n AWB.\n\n @param[out] ct AWB.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAWBCt(ct: *mut libc::c_uint) -> libc::c_int;
}
#[doc = " ISP "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCCMAttr {
    pub ManualEn: IMPISPTuningOpsMode,
    pub SatEn: IMPISPTuningOpsMode,
    pub ColorMatrix: [f32; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPCCMAttr"][::core::mem::size_of::<IMPISPCCMAttr>() - 44usize];
    ["Alignment of IMPISPCCMAttr"][::core::mem::align_of::<IMPISPCCMAttr>() - 4usize];
    ["Offset of field: IMPISPCCMAttr::ManualEn"]
        [::core::mem::offset_of!(IMPISPCCMAttr, ManualEn) - 0usize];
    ["Offset of field: IMPISPCCMAttr::SatEn"]
        [::core::mem::offset_of!(IMPISPCCMAttr, SatEn) - 4usize];
    ["Offset of field: IMPISPCCMAttr::ColorMatrix"]
        [::core::mem::offset_of!(IMPISPCCMAttr, ColorMatrix) - 8usize];
};
impl Default for IMPISPCCMAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetCCMAttr(IMPISPCCMAttr *ccm)\n\n CCM.\n\n @param[in] ccm CCM.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetCCMAttr(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetCCMAttr(IMPISPCCMAttr *ccm)\n\n CCM.\n\n @param[out] ccm CCM.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetCCMAttr(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
#[doc = " ISP AE "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEAttr {
    pub AeFreezenEn: IMPISPTuningOpsMode,
    pub AeItManualEn: IMPISPTuningOpsMode,
    pub AeIt: libc::c_uint,
    pub AeAGainManualEn: IMPISPTuningOpsMode,
    pub AeAGain: libc::c_uint,
    pub AeDGainManualEn: IMPISPTuningOpsMode,
    pub AeDGain: libc::c_uint,
    pub AeIspDGainManualEn: IMPISPTuningOpsMode,
    pub AeIspDGain: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEAttr"][::core::mem::size_of::<IMPISPAEAttr>() - 36usize];
    ["Alignment of IMPISPAEAttr"][::core::mem::align_of::<IMPISPAEAttr>() - 4usize];
    ["Offset of field: IMPISPAEAttr::AeFreezenEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeFreezenEn) - 0usize];
    ["Offset of field: IMPISPAEAttr::AeItManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeItManualEn) - 4usize];
    ["Offset of field: IMPISPAEAttr::AeIt"][::core::mem::offset_of!(IMPISPAEAttr, AeIt) - 8usize];
    ["Offset of field: IMPISPAEAttr::AeAGainManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeAGainManualEn) - 12usize];
    ["Offset of field: IMPISPAEAttr::AeAGain"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeAGain) - 16usize];
    ["Offset of field: IMPISPAEAttr::AeDGainManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeDGainManualEn) - 20usize];
    ["Offset of field: IMPISPAEAttr::AeDGain"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeDGain) - 24usize];
    ["Offset of field: IMPISPAEAttr::AeIspDGainManualEn"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeIspDGainManualEn) - 28usize];
    ["Offset of field: IMPISPAEAttr::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAEAttr, AeIspDGain) - 32usize];
};
impl Default for IMPISPAEAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeAttr(IMPISPAEAttr *ae)\n\n AE.\n\n @param[in] ae AE.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeAttr(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeAttr(IMPISPAEAttr *ae)\n\n AE.\n\n @param[out] ae AE.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning\n @attention IMPISPAEAttr0"]
    pub fn IMP_ISP_Tuning_GetAeAttr(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAEState {
    pub stable: bool,
    pub target: libc::c_uint,
    pub ae_mean: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAEState"][::core::mem::size_of::<IMPISPAEState>() - 12usize];
    ["Alignment of IMPISPAEState"][::core::mem::align_of::<IMPISPAEState>() - 4usize];
    ["Offset of field: IMPISPAEState::stable"]
        [::core::mem::offset_of!(IMPISPAEState, stable) - 0usize];
    ["Offset of field: IMPISPAEState::target"]
        [::core::mem::offset_of!(IMPISPAEState, target) - 4usize];
    ["Offset of field: IMPISPAEState::ae_mean"]
        [::core::mem::offset_of!(IMPISPAEState, ae_mean) - 8usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeState(IMPISPAEState *ae_state)\n\n AE.\n\n @param[out] ae AE.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeState(ae_state: *mut IMPISPAEState) -> libc::c_int;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPScalerMethod {
    IMP_ISP_SCALER_METHOD_FITTING_CURVE = 0,
    IMP_ISP_SCALER_METHOD_FIXED_WEIGHT = 1,
    IMP_ISP_SCALER_METHOD_BUTT = 2,
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPScalerLv {
    pub channel: libc::c_uchar,
    pub method: IMPISPScalerMethod,
    pub level: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPScalerLv"][::core::mem::size_of::<IMPISPScalerLv>() - 12usize];
    ["Alignment of IMPISPScalerLv"][::core::mem::align_of::<IMPISPScalerLv>() - 4usize];
    ["Offset of field: IMPISPScalerLv::channel"]
        [::core::mem::offset_of!(IMPISPScalerLv, channel) - 0usize];
    ["Offset of field: IMPISPScalerLv::method"]
        [::core::mem::offset_of!(IMPISPScalerLv, method) - 4usize];
    ["Offset of field: IMPISPScalerLv::level"]
        [::core::mem::offset_of!(IMPISPScalerLv, level) - 8usize];
};
impl Default for IMPISPScalerLv {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetScalerLv(IMPISPScalerLv *scaler_level)\n\n Set Scaler .\n\n @param[in] mscaler .\n\n @retval 0 \n @retval 0 \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetScalerLv(scaler_level: *mut IMPISPScalerLv) -> libc::c_int;
}
#[doc = " AE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeInitAttr {
    #[doc = "< AE"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeAGain: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeDGain: u32,
    #[doc = "< AE ISP  x 1024"]
    pub AeIspDGain: u32,
    #[doc = "< AE"]
    pub AeMinIntegrationTime: u32,
    #[doc = "< AEsensor"]
    pub AeMinAGain: u32,
    #[doc = "< AEsensor"]
    pub AeMinDgain: u32,
    #[doc = "< AEISP"]
    pub AeMinIspDGain: u32,
    #[doc = "< AE"]
    pub AeMaxIntegrationTime: u32,
    #[doc = "< AEsensor"]
    pub AeMaxAGain: u32,
    #[doc = "< AEsensor"]
    pub AeMaxDgain: u32,
    #[doc = "< AEISP"]
    pub AeMaxIspDGain: u32,
    #[doc = "< AE"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeShortAGain: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP  x 1024"]
    pub AeShortIspDGain: u32,
    #[doc = "< AE"]
    pub AeShortMinIntegrationTime: u32,
    #[doc = "< AEsensor"]
    pub AeShortMinAGain: u32,
    #[doc = "< AEsensor"]
    pub AeShortMinDgain: u32,
    #[doc = "< AEISP"]
    pub AeShortMinIspDGain: u32,
    #[doc = "< AE"]
    pub AeShortMaxIntegrationTime: u32,
    #[doc = "< AEsensor"]
    pub AeShortMaxAGain: u32,
    #[doc = "< AEsensor"]
    pub AeShortMaxDgain: u32,
    #[doc = "< AEISP"]
    pub AeShortMaxIspDGain: u32,
    #[doc = "< sensor "]
    pub fps: u32,
    #[doc = "< AE"]
    pub AeStatis: IMPISPAEHist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeInitAttr"][::core::mem::size_of::<IMPISPAeInitAttr>() - 120usize];
    ["Alignment of IMPISPAeInitAttr"][::core::mem::align_of::<IMPISPAeInitAttr>() - 4usize];
    ["Offset of field: IMPISPAeInitAttr::AeIntegrationTimeUnit"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeIntegrationTimeUnit) - 0usize];
    ["Offset of field: IMPISPAeInitAttr::AeIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeIntegrationTime) - 4usize];
    ["Offset of field: IMPISPAeInitAttr::AeAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeAGain) - 8usize];
    ["Offset of field: IMPISPAeInitAttr::AeDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeDGain) - 12usize];
    ["Offset of field: IMPISPAeInitAttr::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeIspDGain) - 16usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinIntegrationTime) - 20usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinAGain) - 24usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinDgain) - 28usize];
    ["Offset of field: IMPISPAeInitAttr::AeMinIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMinIspDGain) - 32usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxIntegrationTime) - 36usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxAGain) - 40usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxDgain) - 44usize];
    ["Offset of field: IMPISPAeInitAttr::AeMaxIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeMaxIspDGain) - 48usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortIntegrationTime) - 52usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortAGain) - 56usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortDGain) - 60usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortIspDGain) - 64usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinIntegrationTime) - 68usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinAGain) - 72usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinDgain) - 76usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMinIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMinIspDGain) - 80usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxIntegrationTime) - 84usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxAGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxAGain) - 88usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxDgain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxDgain) - 92usize];
    ["Offset of field: IMPISPAeInitAttr::AeShortMaxIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeShortMaxIspDGain) - 96usize];
    ["Offset of field: IMPISPAeInitAttr::fps"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, fps) - 100usize];
    ["Offset of field: IMPISPAeInitAttr::AeStatis"]
        [::core::mem::offset_of!(IMPISPAeInitAttr, AeStatis) - 104usize];
};
impl Default for IMPISPAeInitAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " AE"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeInfo {
    #[doc = "< AE"]
    pub ae_zone: IMPISPZone,
    #[doc = "< AE256bin"]
    pub ae_hist_256bin: IMPISPAEHistOrigin,
    #[doc = "< AE5bin"]
    pub ae_hist: IMPISPAEHist,
    #[doc = "< AE"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE Sensor  x 1024"]
    pub AeAGain: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeDGain: u32,
    #[doc = "< AE ISP  x 1024"]
    pub AeIspDGain: u32,
    #[doc = "< AE"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE Sensor  x 1024"]
    pub AeShortAGain: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP  x 1024"]
    pub AeShortIspDGain: u32,
    #[doc = "< WDR"]
    pub Wdr_mode: u32,
    #[doc = "< Sensor"]
    pub sensor_attr: IMPISPSENSORAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeInfo"][::core::mem::size_of::<IMPISPAeInfo>() - 2000usize];
    ["Alignment of IMPISPAeInfo"][::core::mem::align_of::<IMPISPAeInfo>() - 1usize];
    ["Offset of field: IMPISPAeInfo::ae_zone"]
        [::core::mem::offset_of!(IMPISPAeInfo, ae_zone) - 0usize];
    ["Offset of field: IMPISPAeInfo::ae_hist_256bin"]
        [::core::mem::offset_of!(IMPISPAeInfo, ae_hist_256bin) - 900usize];
    ["Offset of field: IMPISPAeInfo::ae_hist"]
        [::core::mem::offset_of!(IMPISPAeInfo, ae_hist) - 1924usize];
    ["Offset of field: IMPISPAeInfo::AeIntegrationTimeUnit"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeIntegrationTimeUnit) - 1940usize];
    ["Offset of field: IMPISPAeInfo::AeIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeIntegrationTime) - 1944usize];
    ["Offset of field: IMPISPAeInfo::AeAGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeAGain) - 1948usize];
    ["Offset of field: IMPISPAeInfo::AeDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeDGain) - 1952usize];
    ["Offset of field: IMPISPAeInfo::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeIspDGain) - 1956usize];
    ["Offset of field: IMPISPAeInfo::AeShortIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortIntegrationTime) - 1960usize];
    ["Offset of field: IMPISPAeInfo::AeShortAGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortAGain) - 1964usize];
    ["Offset of field: IMPISPAeInfo::AeShortDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortDGain) - 1968usize];
    ["Offset of field: IMPISPAeInfo::AeShortIspDGain"]
        [::core::mem::offset_of!(IMPISPAeInfo, AeShortIspDGain) - 1972usize];
    ["Offset of field: IMPISPAeInfo::Wdr_mode"]
        [::core::mem::offset_of!(IMPISPAeInfo, Wdr_mode) - 1976usize];
    ["Offset of field: IMPISPAeInfo::sensor_attr"]
        [::core::mem::offset_of!(IMPISPAeInfo, sensor_attr) - 1980usize];
};
impl Default for IMPISPAeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " AE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeAttr {
    #[doc = "< AE"]
    pub change: u32,
    #[doc = "< AE"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE Sensor  x 1024"]
    pub AeAGain: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeDGain: u32,
    #[doc = "< AE ISP  x 1024"]
    pub AeIspDGain: u32,
    #[doc = "< AE"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE Sensor  x 1024"]
    pub AeShortAGain: u32,
    #[doc = "< AE Sensor x 1024"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP  x 1024"]
    pub AeShortIspDGain: u32,
    #[doc = "< AE Luma"]
    pub luma: u32,
    #[doc = "< AE Luma"]
    pub luma_scence: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeAttr"][::core::mem::size_of::<IMPISPAeAttr>() - 48usize];
    ["Alignment of IMPISPAeAttr"][::core::mem::align_of::<IMPISPAeAttr>() - 4usize];
    ["Offset of field: IMPISPAeAttr::change"]
        [::core::mem::offset_of!(IMPISPAeAttr, change) - 0usize];
    ["Offset of field: IMPISPAeAttr::AeIntegrationTimeUnit"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeIntegrationTimeUnit) - 4usize];
    ["Offset of field: IMPISPAeAttr::AeIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeIntegrationTime) - 8usize];
    ["Offset of field: IMPISPAeAttr::AeAGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeAGain) - 12usize];
    ["Offset of field: IMPISPAeAttr::AeDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeDGain) - 16usize];
    ["Offset of field: IMPISPAeAttr::AeIspDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeIspDGain) - 20usize];
    ["Offset of field: IMPISPAeAttr::AeShortIntegrationTime"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortIntegrationTime) - 24usize];
    ["Offset of field: IMPISPAeAttr::AeShortAGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortAGain) - 28usize];
    ["Offset of field: IMPISPAeAttr::AeShortDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortDGain) - 32usize];
    ["Offset of field: IMPISPAeAttr::AeShortIspDGain"]
        [::core::mem::offset_of!(IMPISPAeAttr, AeShortIspDGain) - 36usize];
    ["Offset of field: IMPISPAeAttr::luma"][::core::mem::offset_of!(IMPISPAeAttr, luma) - 40usize];
    ["Offset of field: IMPISPAeAttr::luma_scence"]
        [::core::mem::offset_of!(IMPISPAeAttr, luma_scence) - 44usize];
};
impl Default for IMPISPAeAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " AE"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAeNotify {
    #[doc = "< "]
    IMPISP_AE_NOTIFY_FPS_CHANGE = 0,
}
#[doc = " AE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeAlgoFunc {
    #[doc = "< "]
    pub priv_data: *mut libc::c_void,
    #[doc = "< AE"]
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            AeInitAttr: *mut IMPISPAeInitAttr,
        ) -> libc::c_int,
    >,
    #[doc = "< AE"]
    pub close: ::core::option::Option<unsafe extern "C" fn(priv_data: *mut libc::c_void)>,
    #[doc = "< AE"]
    pub handle: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            AeInfo: *const IMPISPAeInfo,
            AeAttr: *mut IMPISPAeAttr,
        ),
    >,
    #[doc = "< AE"]
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            notify: IMPISPAeNotify,
            data: *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAeAlgoFunc"][::core::mem::size_of::<IMPISPAeAlgoFunc>() - 20usize];
    ["Alignment of IMPISPAeAlgoFunc"][::core::mem::align_of::<IMPISPAeAlgoFunc>() - 4usize];
    ["Offset of field: IMPISPAeAlgoFunc::priv_data"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, priv_data) - 0usize];
    ["Offset of field: IMPISPAeAlgoFunc::open"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, open) - 4usize];
    ["Offset of field: IMPISPAeAlgoFunc::close"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, close) - 8usize];
    ["Offset of field: IMPISPAeAlgoFunc::handle"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, handle) - 12usize];
    ["Offset of field: IMPISPAeAlgoFunc::notify"]
        [::core::mem::offset_of!(IMPISPAeAlgoFunc, notify) - 16usize];
};
impl Default for IMPISPAeAlgoFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " "]
    pub fn IMP_ISP_SetAeAlgoFunc(ae_func: *mut IMPISPAeAlgoFunc) -> i32;
}
#[doc = " AWB"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbInfo {
    #[doc = "< R"]
    pub cur_r_gain: u32,
    #[doc = "< B"]
    pub cur_b_gain: u32,
    #[doc = "< r_gain"]
    pub r_gain_statis: u32,
    #[doc = "< b_gain"]
    pub b_gain_statis: u32,
    #[doc = "< r_gain"]
    pub r_gain_wei_statis: u32,
    #[doc = "< b_gain"]
    pub b_gain_wei_statis: u32,
    #[doc = "< "]
    pub awb_statis: IMPISPAWBZone,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAwbInfo"][::core::mem::size_of::<IMPISPAwbInfo>() - 699usize];
    ["Alignment of IMPISPAwbInfo"][::core::mem::align_of::<IMPISPAwbInfo>() - 1usize];
    ["Offset of field: IMPISPAwbInfo::cur_r_gain"]
        [::core::mem::offset_of!(IMPISPAwbInfo, cur_r_gain) - 0usize];
    ["Offset of field: IMPISPAwbInfo::cur_b_gain"]
        [::core::mem::offset_of!(IMPISPAwbInfo, cur_b_gain) - 4usize];
    ["Offset of field: IMPISPAwbInfo::r_gain_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, r_gain_statis) - 8usize];
    ["Offset of field: IMPISPAwbInfo::b_gain_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, b_gain_statis) - 12usize];
    ["Offset of field: IMPISPAwbInfo::r_gain_wei_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, r_gain_wei_statis) - 16usize];
    ["Offset of field: IMPISPAwbInfo::b_gain_wei_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, b_gain_wei_statis) - 20usize];
    ["Offset of field: IMPISPAwbInfo::awb_statis"]
        [::core::mem::offset_of!(IMPISPAwbInfo, awb_statis) - 24usize];
};
impl Default for IMPISPAwbInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " AWB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAwbAttr {
    #[doc = "< AWB"]
    pub change: u32,
    #[doc = "< AWB r_gain"]
    pub r_gain: u32,
    #[doc = "< AWB b_gain"]
    pub b_gain: u32,
    #[doc = "< "]
    pub ct: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAwbAttr"][::core::mem::size_of::<IMPISPAwbAttr>() - 16usize];
    ["Alignment of IMPISPAwbAttr"][::core::mem::align_of::<IMPISPAwbAttr>() - 4usize];
    ["Offset of field: IMPISPAwbAttr::change"]
        [::core::mem::offset_of!(IMPISPAwbAttr, change) - 0usize];
    ["Offset of field: IMPISPAwbAttr::r_gain"]
        [::core::mem::offset_of!(IMPISPAwbAttr, r_gain) - 4usize];
    ["Offset of field: IMPISPAwbAttr::b_gain"]
        [::core::mem::offset_of!(IMPISPAwbAttr, b_gain) - 8usize];
    ["Offset of field: IMPISPAwbAttr::ct"][::core::mem::offset_of!(IMPISPAwbAttr, ct) - 12usize];
};
#[repr(u32)]
#[doc = " AWB"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPAwbNotify {
    #[doc = "< AWB"]
    IMPISP_AWB_NOTIFY_MODE_CHANGE = 0,
}
#[doc = " AWB"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbAlgoFunc {
    #[doc = "< "]
    pub priv_data: *mut libc::c_void,
    #[doc = "< AWB"]
    pub open:
        ::core::option::Option<unsafe extern "C" fn(priv_data: *mut libc::c_void) -> libc::c_int>,
    #[doc = "< AWB"]
    pub close: ::core::option::Option<unsafe extern "C" fn(priv_data: *mut libc::c_void)>,
    #[doc = "< AWB"]
    pub handle: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            AwbInfo: *const IMPISPAwbInfo,
            AwbAttr: *mut IMPISPAwbAttr,
        ),
    >,
    #[doc = "< AWB"]
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut libc::c_void,
            notify: IMPISPAwbNotify,
            data: *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAwbAlgoFunc"][::core::mem::size_of::<IMPISPAwbAlgoFunc>() - 20usize];
    ["Alignment of IMPISPAwbAlgoFunc"][::core::mem::align_of::<IMPISPAwbAlgoFunc>() - 4usize];
    ["Offset of field: IMPISPAwbAlgoFunc::priv_data"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, priv_data) - 0usize];
    ["Offset of field: IMPISPAwbAlgoFunc::open"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, open) - 4usize];
    ["Offset of field: IMPISPAwbAlgoFunc::close"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, close) - 8usize];
    ["Offset of field: IMPISPAwbAlgoFunc::handle"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, handle) - 12usize];
    ["Offset of field: IMPISPAwbAlgoFunc::notify"]
        [::core::mem::offset_of!(IMPISPAwbAlgoFunc, notify) - 16usize];
};
impl Default for IMPISPAwbAlgoFunc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " "]
    pub fn IMP_ISP_SetAwbAlgoFunc(awb_func: *mut IMPISPAwbAlgoFunc) -> i32;
}
#[doc = "\t"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPBlcAttr {
    #[doc = "< R"]
    pub black_level_r: libc::c_uint,
    #[doc = "< GR"]
    pub black_level_gr: libc::c_uint,
    #[doc = "< GB"]
    pub black_level_gb: libc::c_uint,
    #[doc = "< B"]
    pub black_level_b: libc::c_uint,
    #[doc = "< IR"]
    pub black_level_ir: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPBlcAttr"][::core::mem::size_of::<IMPISPBlcAttr>() - 20usize];
    ["Alignment of IMPISPBlcAttr"][::core::mem::align_of::<IMPISPBlcAttr>() - 4usize];
    ["Offset of field: IMPISPBlcAttr::black_level_r"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_r) - 0usize];
    ["Offset of field: IMPISPBlcAttr::black_level_gr"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_gr) - 4usize];
    ["Offset of field: IMPISPBlcAttr::black_level_gb"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_gb) - 8usize];
    ["Offset of field: IMPISPBlcAttr::black_level_b"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_b) - 12usize];
    ["Offset of field: IMPISPBlcAttr::black_level_ir"]
        [::core::mem::offset_of!(IMPISPBlcAttr, black_level_ir) - 16usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBlcAttr(IMPISPBlcAttr *blc)\n\n BLC.\n\n @param[out] blc blc.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning\n @attention IMPISPAEAttr0"]
    pub fn IMP_ISP_Tuning_GetBlcAttr(blc: *mut IMPISPBlcAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDefog_Strength(uint8_t *ratio)\n\n Defog\n\n @param[in] ratio  Defog.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDefog_Strength(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDefog_Strength(uint8_t *ratio)\n\n Defog\n\n @param[in] ratio  Defog.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDefog_Strength(ratio: *mut u8) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPCscCgMode {
    #[doc = "< BT601 full range"]
    ISP_CSC_CG_BT601_FULL = 0,
    #[doc = "< BT601 full range"]
    ISP_CSC_CG_BT601_CLIP = 1,
    #[doc = "< BT709 full range"]
    ISP_CSC_CG_BT709_FULL = 2,
    #[doc = "< BT709 full range"]
    ISP_CSC_CG_BT709_CLIP = 3,
    #[doc = "< "]
    ISP_CSC_CG_USER = 4,
    #[doc = "< "]
    IMP_CSC_CG_BUTT = 5,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPCscParam {
    #[doc = "< 3x3"]
    pub csc_coef: [libc::c_int; 9usize],
    #[doc = "< [0] UV [1] Y"]
    pub csc_offset: [libc::c_int; 2usize],
    #[doc = "< YY"]
    pub csc_y_clip: [libc::c_int; 2usize],
    #[doc = "< UVUV"]
    pub csc_c_clip: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPCscParam"][::core::mem::size_of::<IMPISPCscParam>() - 60usize];
    ["Alignment of IMPISPCscParam"][::core::mem::align_of::<IMPISPCscParam>() - 4usize];
    ["Offset of field: IMPISPCscParam::csc_coef"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_coef) - 0usize];
    ["Offset of field: IMPISPCscParam::csc_offset"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_offset) - 36usize];
    ["Offset of field: IMPISPCscParam::csc_y_clip"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_y_clip) - 44usize];
    ["Offset of field: IMPISPCscParam::csc_c_clip"]
        [::core::mem::offset_of!(IMPISPCscParam, csc_c_clip) - 52usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCscAttr {
    #[doc = "< "]
    pub mode: IMPISPCscCgMode,
    #[doc = "< "]
    pub csc_par: IMPISPCscParam,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPCscAttr"][::core::mem::size_of::<IMPISPCscAttr>() - 64usize];
    ["Alignment of IMPISPCscAttr"][::core::mem::align_of::<IMPISPCscAttr>() - 4usize];
    ["Offset of field: IMPISPCscAttr::mode"][::core::mem::offset_of!(IMPISPCscAttr, mode) - 0usize];
    ["Offset of field: IMPISPCscAttr::csc_par"]
        [::core::mem::offset_of!(IMPISPCscAttr, csc_par) - 4usize];
};
impl Default for IMPISPCscAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetCsc_Attr(IMPISPCscAttr *attr)\n\n CSC\n\n @param[in] attr CSC.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetCsc_Attr(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetCsc_Attr(IMPISPCscAttr *attr)\n\n CSC\n\n @param[in] attr CSC.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetCsc_Attr(attr: *mut IMPISPCscAttr) -> i32;
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrameDrop {
    #[doc = "< "]
    pub enable: IMPISPTuningOpsMode,
    #[doc = "< (:0~31)"]
    pub lsize: u8,
    #[doc = "< (10)"]
    pub fmark: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFrameDrop"][::core::mem::size_of::<IMPISPFrameDrop>() - 12usize];
    ["Alignment of IMPISPFrameDrop"][::core::mem::align_of::<IMPISPFrameDrop>() - 4usize];
    ["Offset of field: IMPISPFrameDrop::enable"]
        [::core::mem::offset_of!(IMPISPFrameDrop, enable) - 0usize];
    ["Offset of field: IMPISPFrameDrop::lsize"]
        [::core::mem::offset_of!(IMPISPFrameDrop, lsize) - 4usize];
    ["Offset of field: IMPISPFrameDrop::fmark"]
        [::core::mem::offset_of!(IMPISPFrameDrop, fmark) - 8usize];
};
impl Default for IMPISPFrameDrop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrameDropAttr {
    #[doc = "< "]
    pub fdrop: [IMPISPFrameDrop; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFrameDropAttr"][::core::mem::size_of::<IMPISPFrameDropAttr>() - 36usize];
    ["Alignment of IMPISPFrameDropAttr"][::core::mem::align_of::<IMPISPFrameDropAttr>() - 4usize];
    ["Offset of field: IMPISPFrameDropAttr::fdrop"]
        [::core::mem::offset_of!(IMPISPFrameDropAttr, fdrop) - 0usize];
};
impl Default for IMPISPFrameDropAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFrameDrop(IMPISPFrameDropAttr *attr)\n\n \n\n @param[in] attr      \n\n @retval 0 \n @retval 0 \n\n @remark (lsize+1)(fmark)\n @remark lsize=3,fmark=0x5(424)\n\n @attention IMP_ISP_Open"]
    pub fn IMP_ISP_SetFrameDrop(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetFrameDrop(IMPISPFrameDropAttr *attr)\n\n \n\n @param[out] attr     \n\n @retval 0 \n @retval 0 \n\n @remark (lsize+1)(fmark)\n @remark lsize=3,fmark=0x5(424)\n\n @attention IMP_ISP_Open"]
    pub fn IMP_ISP_GetFrameDrop(attr: *mut IMPISPFrameDropAttr) -> i32;
}
#[doc = " mjpeg"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPFixedContrastAttr {
    pub mode: u8,
    pub range_low: u8,
    pub range_high: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPFixedContrastAttr"][::core::mem::size_of::<IMPISPFixedContrastAttr>() - 3usize];
    ["Alignment of IMPISPFixedContrastAttr"]
        [::core::mem::align_of::<IMPISPFixedContrastAttr>() - 1usize];
    ["Offset of field: IMPISPFixedContrastAttr::mode"]
        [::core::mem::offset_of!(IMPISPFixedContrastAttr, mode) - 0usize];
    ["Offset of field: IMPISPFixedContrastAttr::range_low"]
        [::core::mem::offset_of!(IMPISPFixedContrastAttr, range_low) - 1usize];
    ["Offset of field: IMPISPFixedContrastAttr::range_high"]
        [::core::mem::offset_of!(IMPISPFixedContrastAttr, range_high) - 2usize];
};
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFixedContraster(IMPISPFixedContrastAttr *attr)\n\n mjpeg\n\n @param[out] attr\t.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_SetFixedContraster(attr: *mut IMPISPFixedContrastAttr) -> i32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPGPIO {
    pub gpio_num: [u16; 10usize],
    #[doc = " gpio"]
    pub gpio_sta: [u16; 10usize],
    #[doc = " gpio"]
    pub free: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPGPIO"][::core::mem::size_of::<IMPISPGPIO>() - 42usize];
    ["Alignment of IMPISPGPIO"][::core::mem::align_of::<IMPISPGPIO>() - 2usize];
    ["Offset of field: IMPISPGPIO::gpio_num"]
        [::core::mem::offset_of!(IMPISPGPIO, gpio_num) - 0usize];
    ["Offset of field: IMPISPGPIO::gpio_sta"]
        [::core::mem::offset_of!(IMPISPGPIO, gpio_sta) - 20usize];
    ["Offset of field: IMPISPGPIO::free"][::core::mem::offset_of!(IMPISPGPIO, free) - 40usize];
};
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SET_GPIO_INIT_OR_FREE(IMPISPGPIO *attr);\n\n GPIO\n @param[in] gpio_num GPIO0xFF\n @param[in] gpio_sta GPIO0 1\n @param[in] free 0 1\n\n @retval 0 \n @retval 0 \n\n @remark gpio_num[10]={20,21,0xff},gpio_sta[10]= {1,0} PA20PA21\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_SET_GPIO_INIT_OR_FREE(attr: *mut IMPISPGPIO) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SET_GPIO_STA(IMPISPGPIO *attr)\n\n VIC DONEGPIO.\n\n @param[in] gpio_num GPIO0xFF\n @param[in] gpio_sta GPIO0 1\n\n @remark gpio_num[10]={20,21,0xff},gpio_sta[10]= {1,0} PA20PA21\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_SET_GPIO_STA(attr: *mut IMPISPGPIO) -> i32;
}
#[doc = " ISP AutoZoom Attribution"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPAutoZoom {
    pub chan: libc::c_int,
    #[doc = " <>"]
    pub scaler_enable: libc::c_int,
    #[doc = " <>"]
    pub scaler_outwidth: libc::c_int,
    #[doc = " <>"]
    pub scaler_outheight: libc::c_int,
    #[doc = " <>"]
    pub crop_enable: libc::c_int,
    #[doc = " <>"]
    pub crop_left: libc::c_int,
    #[doc = " <>"]
    pub crop_top: libc::c_int,
    #[doc = " <>"]
    pub crop_width: libc::c_int,
    #[doc = " <>"]
    pub crop_height: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPAutoZoom"][::core::mem::size_of::<IMPISPAutoZoom>() - 36usize];
    ["Alignment of IMPISPAutoZoom"][::core::mem::align_of::<IMPISPAutoZoom>() - 4usize];
    ["Offset of field: IMPISPAutoZoom::chan"]
        [::core::mem::offset_of!(IMPISPAutoZoom, chan) - 0usize];
    ["Offset of field: IMPISPAutoZoom::scaler_enable"]
        [::core::mem::offset_of!(IMPISPAutoZoom, scaler_enable) - 4usize];
    ["Offset of field: IMPISPAutoZoom::scaler_outwidth"]
        [::core::mem::offset_of!(IMPISPAutoZoom, scaler_outwidth) - 8usize];
    ["Offset of field: IMPISPAutoZoom::scaler_outheight"]
        [::core::mem::offset_of!(IMPISPAutoZoom, scaler_outheight) - 12usize];
    ["Offset of field: IMPISPAutoZoom::crop_enable"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_enable) - 16usize];
    ["Offset of field: IMPISPAutoZoom::crop_left"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_left) - 20usize];
    ["Offset of field: IMPISPAutoZoom::crop_top"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_top) - 24usize];
    ["Offset of field: IMPISPAutoZoom::crop_width"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_width) - 28usize];
    ["Offset of field: IMPISPAutoZoom::crop_height"]
        [::core::mem::offset_of!(IMPISPAutoZoom, crop_height) - 32usize];
};
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAutoZoom(IMPISPAutoZoom *ispautozoom)\n\n \n\n @param[in] \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor."]
    pub fn IMP_ISP_Tuning_SetAutoZoom(ispautozoom: *mut IMPISPAutoZoom) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAutoZoom(IMPISPAutoZoom *ispautozoom)\n\n \n\n @param[in] ispautozoom \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_Tuning_SetAutoZoom.\n @attention IMP_ISP_EnableSensor."]
    pub fn IMP_ISP_Tuning_GetAutoZoom(ispautozoom: *mut IMPISPAutoZoom) -> libc::c_int;
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub union color_value {
    #[doc = "< RGB"]
    pub argb: color_value__bindgen_ty_1,
    #[doc = "< YUV"]
    pub ayuv: color_value__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct color_value__bindgen_ty_1 {
    #[doc = "< R "]
    pub r_value: libc::c_uchar,
    #[doc = "< G "]
    pub g_value: libc::c_uchar,
    #[doc = "< B "]
    pub b_value: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of color_value__bindgen_ty_1"]
        [::core::mem::size_of::<color_value__bindgen_ty_1>() - 3usize];
    ["Alignment of color_value__bindgen_ty_1"]
        [::core::mem::align_of::<color_value__bindgen_ty_1>() - 1usize];
    ["Offset of field: color_value__bindgen_ty_1::r_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_1, r_value) - 0usize];
    ["Offset of field: color_value__bindgen_ty_1::g_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_1, g_value) - 1usize];
    ["Offset of field: color_value__bindgen_ty_1::b_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_1, b_value) - 2usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct color_value__bindgen_ty_2 {
    #[doc = "< Y "]
    pub y_value: libc::c_uchar,
    #[doc = "< U "]
    pub u_value: libc::c_uchar,
    #[doc = "< V "]
    pub v_value: libc::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of color_value__bindgen_ty_2"]
        [::core::mem::size_of::<color_value__bindgen_ty_2>() - 3usize];
    ["Alignment of color_value__bindgen_ty_2"]
        [::core::mem::align_of::<color_value__bindgen_ty_2>() - 1usize];
    ["Offset of field: color_value__bindgen_ty_2::y_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_2, y_value) - 0usize];
    ["Offset of field: color_value__bindgen_ty_2::u_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_2, u_value) - 1usize];
    ["Offset of field: color_value__bindgen_ty_2::v_value"]
        [::core::mem::offset_of!(color_value__bindgen_ty_2, v_value) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of color_value"][::core::mem::size_of::<color_value>() - 3usize];
    ["Alignment of color_value"][::core::mem::align_of::<color_value>() - 1usize];
    ["Offset of field: color_value::argb"][::core::mem::offset_of!(color_value, argb) - 0usize];
    ["Offset of field: color_value::ayuv"][::core::mem::offset_of!(color_value, ayuv) - 0usize];
};
impl Default for color_value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
pub type IMP_ISP_COLOR_VALUE = color_value;
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct isp_mask_block_par {
    #[doc = "< (: 0~2)"]
    pub chx: u8,
    #[doc = "< (: 0~3)"]
    pub pinum: u8,
    #[doc = "< "]
    pub mask_en: u8,
    #[doc = "< y"]
    pub mask_pos_top: u16,
    #[doc = "< x"]
    pub mask_pos_left: u16,
    #[doc = "< "]
    pub mask_width: u16,
    #[doc = "< "]
    pub mask_height: u16,
    #[doc = "< "]
    pub mask_type: IMPISP_MASK_TYPE,
    #[doc = "< "]
    pub mask_value: IMP_ISP_COLOR_VALUE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of isp_mask_block_par"][::core::mem::size_of::<isp_mask_block_par>() - 20usize];
    ["Alignment of isp_mask_block_par"][::core::mem::align_of::<isp_mask_block_par>() - 4usize];
    ["Offset of field: isp_mask_block_par::chx"]
        [::core::mem::offset_of!(isp_mask_block_par, chx) - 0usize];
    ["Offset of field: isp_mask_block_par::pinum"]
        [::core::mem::offset_of!(isp_mask_block_par, pinum) - 1usize];
    ["Offset of field: isp_mask_block_par::mask_en"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_en) - 2usize];
    ["Offset of field: isp_mask_block_par::mask_pos_top"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_pos_top) - 4usize];
    ["Offset of field: isp_mask_block_par::mask_pos_left"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_pos_left) - 6usize];
    ["Offset of field: isp_mask_block_par::mask_width"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_width) - 8usize];
    ["Offset of field: isp_mask_block_par::mask_height"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_height) - 10usize];
    ["Offset of field: isp_mask_block_par::mask_type"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_type) - 12usize];
    ["Offset of field: isp_mask_block_par::mask_value"]
        [::core::mem::offset_of!(isp_mask_block_par, mask_value) - 16usize];
};
impl Default for isp_mask_block_par {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
pub type IMPISPMaskBlockAttr = isp_mask_block_par;
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetMaskBlock(IMPISPMaskBlockAttr *mask)\n\n .\n\n @param[in] num   sensor\n @param[in] mask  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr block;\n\n if (en) {\n      block.chx = 0;\n      block.pinum = 0;\n      block.mask_en = 1;\n      block.mask_pos_top = 10;\n      block.mask_pos_left = 100;\n      block.mask_width = 200;\n      block.mask_height = 200;\n      block.mask_type = IMPISP_MASK_TYPE_YUV;\n      block.mask_value.ayuv.y_value = 100;\n      block.mask_value.ayuv.u_value = 100;\n      block.mask_value.ayuv.v_value = 100;\n } else {\n      block.mask_en = 0;\n }\n\n ret = IMP_ISP_Tuning_SetMaskBlock(&block);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetMaskBlock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMaskBlock(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetMaskBlock(IMPISPMaskBlockAttr *mask)\n\n .\n\n @param[in] num   sensor\n @param[out] mask .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr attr;\n\n attr.chx = 0;\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetMaskBlock(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetMaskBlock error !\\n\");\n \treturn -1;\n }\n printf(\"chx:%d, pinum:%d, en:%d\\n\", attr.chx, attr.pinum, attr.mask_en);\n if (attr.mask_en) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMaskBlock(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPPICTYPE {
    #[doc = "< ARGB8888"]
    IMP_ISP_PIC_ARGB_8888 = 0,
    #[doc = "< ARBG1555"]
    IMP_ISP_PIC_ARGB_1555 = 1,
    #[doc = "< AC 2bit"]
    IMP_ISP_PIC_ARGB_1100 = 2,
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPARGBType {
    IMP_ISP_ARGB_TYPE_BGRA = 0,
    IMP_ISP_ARGB_TYPE_GBRA = 1,
    IMP_ISP_ARGB_TYPE_BRGA = 2,
    IMP_ISP_ARGB_TYPE_RBGA = 3,
    IMP_ISP_ARGB_TYPE_GRBA = 4,
    IMP_ISP_ARGB_TYPE_RGBA = 5,
    IMP_ISP_ARGB_TYPE_ABGR = 8,
    IMP_ISP_ARGB_TYPE_AGBR = 9,
    IMP_ISP_ARGB_TYPE_ABRG = 10,
    IMP_ISP_ARGB_TYPE_AGRB = 11,
    IMP_ISP_ARGB_TYPE_ARBG = 12,
    IMP_ISP_ARGB_TYPE_ARGB = 13,
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDBlockAttr {
    #[doc = "< (: 0~7)"]
    pub pinum: u8,
    #[doc = "< "]
    pub osd_enable: u8,
    #[doc = "< "]
    pub osd_left: u16,
    #[doc = "< "]
    pub osd_top: u16,
    #[doc = "< "]
    pub osd_width: u16,
    #[doc = "< "]
    pub osd_height: u16,
    #[doc = "< "]
    pub osd_image: *mut libc::c_char,
    #[doc = "< , 320x240RGBA8888osd_stride=320*4"]
    pub osd_stride: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPOSDBlockAttr"][::core::mem::size_of::<IMPISPOSDBlockAttr>() - 20usize];
    ["Alignment of IMPISPOSDBlockAttr"][::core::mem::align_of::<IMPISPOSDBlockAttr>() - 4usize];
    ["Offset of field: IMPISPOSDBlockAttr::pinum"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, pinum) - 0usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_enable"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_enable) - 1usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_left"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_left) - 2usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_top"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_top) - 4usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_width"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_width) - 6usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_height"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_height) - 8usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_image"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_image) - 12usize];
    ["Offset of field: IMPISPOSDBlockAttr::osd_stride"]
        [::core::mem::offset_of!(IMPISPOSDBlockAttr, osd_stride) - 16usize];
};
impl Default for IMPISPOSDBlockAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDAttr {
    #[doc = "< "]
    pub osd_type: IMPISPPICTYPE,
    #[doc = "< "]
    pub osd_argb_type: IMPISPARGBType,
    #[doc = "< Alpha"]
    pub osd_pixel_alpha_disable: IMPISPTuningOpsMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPOSDAttr"][::core::mem::size_of::<IMPISPOSDAttr>() - 12usize];
    ["Alignment of IMPISPOSDAttr"][::core::mem::align_of::<IMPISPOSDAttr>() - 4usize];
    ["Offset of field: IMPISPOSDAttr::osd_type"]
        [::core::mem::offset_of!(IMPISPOSDAttr, osd_type) - 0usize];
    ["Offset of field: IMPISPOSDAttr::osd_argb_type"]
        [::core::mem::offset_of!(IMPISPOSDAttr, osd_argb_type) - 4usize];
    ["Offset of field: IMPISPOSDAttr::osd_pixel_alpha_disable"]
        [::core::mem::offset_of!(IMPISPOSDAttr, osd_pixel_alpha_disable) - 8usize];
};
impl Default for IMPISPOSDAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDAttr(IMPISPOSDAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[in] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n attr.osd_type = IMP_ISP_PIC_ARGB_8888;\n attr.osd_argb_type = IMP_ISP_ARGB_TYPE_BGRA;\n attr.osd_pixel_alpha_disable = IMPISP_TUNING_OPS_MODE_ENABLE;\n\n if(ret){\n \tIMP_LOG_ERR(TAG, \" error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetOSDAttr(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDAttr(IMPISPOSDAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[out] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n ret = IMP_ISP_Tuning_GetOSDAttr(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDAttr error !\\n\");\n \treturn -1;\n }\n printf(\"type:%d, argb_type:%d, mode:%d\\n\", attr.osd_type,\n attr.osd_argb_type, attr.osd_pixel_alpha_disable);\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetOSDAttr(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDBlock(IMPISPOSDBlockAttr *attr)\n\n OSD.\n\n @param[in] num   sensor\n @param[in] attr  OSD.\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr block;\n\n block.pinum = pinum;\n block.osd_enable = enable;\n block.osd_left = left / 2 * 2;\n block.osd_top = top / 2 * 2;\n block.osd_width = width;\n block.osd_height = height;\n block.osd_image = image;\n block.osd_stride = stride;\n\n ret = IMP_ISP_Tuning_SetOSDBlock(&block);\n if(ret){\n \timp_log_err(tag, \"imp_isp_tuning_setosdblock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetOSDBlock(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDBlock(IMPISPOSDBlockAttr *attr)\n\n OSD.\n\n @param[in] num   sensor\n @param[out] attr OSD.\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetOSDBlock(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, en:%d\\n\", attr.pinum, attr.osd_enable);\n if (attr.osd_enable) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetOSDBlock(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawWindAttr {
    #[doc = "< "]
    pub enable: u8,
    #[doc = "< "]
    pub left: u16,
    #[doc = "< "]
    pub top: u16,
    #[doc = "< "]
    pub width: u16,
    #[doc = "< "]
    pub height: u16,
    #[doc = "< "]
    pub color: IMP_ISP_COLOR_VALUE,
    #[doc = "< "]
    pub line_width: u8,
    #[doc = "< alpha3bit"]
    pub alpha: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawWindAttr"][::core::mem::size_of::<IMPISPDrawWindAttr>() - 16usize];
    ["Alignment of IMPISPDrawWindAttr"][::core::mem::align_of::<IMPISPDrawWindAttr>() - 2usize];
    ["Offset of field: IMPISPDrawWindAttr::enable"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, enable) - 0usize];
    ["Offset of field: IMPISPDrawWindAttr::left"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, left) - 2usize];
    ["Offset of field: IMPISPDrawWindAttr::top"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, top) - 4usize];
    ["Offset of field: IMPISPDrawWindAttr::width"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, width) - 6usize];
    ["Offset of field: IMPISPDrawWindAttr::height"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, height) - 8usize];
    ["Offset of field: IMPISPDrawWindAttr::color"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, color) - 10usize];
    ["Offset of field: IMPISPDrawWindAttr::line_width"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, line_width) - 13usize];
    ["Offset of field: IMPISPDrawWindAttr::alpha"]
        [::core::mem::offset_of!(IMPISPDrawWindAttr, alpha) - 14usize];
};
impl Default for IMPISPDrawWindAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawRangAttr {
    #[doc = "< "]
    pub enable: u8,
    #[doc = "< "]
    pub left: u16,
    #[doc = "< "]
    pub top: u16,
    #[doc = "< "]
    pub width: u16,
    #[doc = "< "]
    pub height: u16,
    #[doc = "< "]
    pub color: IMP_ISP_COLOR_VALUE,
    #[doc = "< "]
    pub line_width: u8,
    #[doc = "< alpha 3bit"]
    pub alpha: u8,
    #[doc = "< "]
    pub extend: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawRangAttr"][::core::mem::size_of::<IMPISPDrawRangAttr>() - 18usize];
    ["Alignment of IMPISPDrawRangAttr"][::core::mem::align_of::<IMPISPDrawRangAttr>() - 2usize];
    ["Offset of field: IMPISPDrawRangAttr::enable"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, enable) - 0usize];
    ["Offset of field: IMPISPDrawRangAttr::left"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, left) - 2usize];
    ["Offset of field: IMPISPDrawRangAttr::top"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, top) - 4usize];
    ["Offset of field: IMPISPDrawRangAttr::width"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, width) - 6usize];
    ["Offset of field: IMPISPDrawRangAttr::height"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, height) - 8usize];
    ["Offset of field: IMPISPDrawRangAttr::color"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, color) - 10usize];
    ["Offset of field: IMPISPDrawRangAttr::line_width"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, line_width) - 13usize];
    ["Offset of field: IMPISPDrawRangAttr::alpha"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, alpha) - 14usize];
    ["Offset of field: IMPISPDrawRangAttr::extend"]
        [::core::mem::offset_of!(IMPISPDrawRangAttr, extend) - 16usize];
};
impl Default for IMPISPDrawRangAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawLineAttr {
    #[doc = "< "]
    pub enable: u8,
    #[doc = "< "]
    pub startx: u16,
    #[doc = "< "]
    pub starty: u16,
    #[doc = "< "]
    pub endx: u16,
    #[doc = "< "]
    pub endy: u16,
    #[doc = "< "]
    pub color: IMP_ISP_COLOR_VALUE,
    #[doc = "< "]
    pub width: u8,
    #[doc = "< Alpha"]
    pub alpha: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawLineAttr"][::core::mem::size_of::<IMPISPDrawLineAttr>() - 16usize];
    ["Alignment of IMPISPDrawLineAttr"][::core::mem::align_of::<IMPISPDrawLineAttr>() - 2usize];
    ["Offset of field: IMPISPDrawLineAttr::enable"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, enable) - 0usize];
    ["Offset of field: IMPISPDrawLineAttr::startx"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, startx) - 2usize];
    ["Offset of field: IMPISPDrawLineAttr::starty"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, starty) - 4usize];
    ["Offset of field: IMPISPDrawLineAttr::endx"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, endx) - 6usize];
    ["Offset of field: IMPISPDrawLineAttr::endy"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, endy) - 8usize];
    ["Offset of field: IMPISPDrawLineAttr::color"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, color) - 10usize];
    ["Offset of field: IMPISPDrawLineAttr::width"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, width) - 13usize];
    ["Offset of field: IMPISPDrawLineAttr::alpha"]
        [::core::mem::offset_of!(IMPISPDrawLineAttr, alpha) - 14usize];
};
impl Default for IMPISPDrawLineAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPDrawType {
    #[doc = "< "]
    IMP_ISP_DRAW_WIND = 0,
    #[doc = "< "]
    IMP_ISP_DRAW_RANGE = 1,
    #[doc = "< "]
    IMP_ISP_DRAW_LINE = 2,
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPDrawBlockAttr {
    #[doc = "< (: 0~19)"]
    pub pinum: u8,
    #[doc = "< "]
    pub type_: IMPISPDrawType,
    #[doc = "< "]
    pub color_type: IMPISP_MASK_TYPE,
    #[doc = "< "]
    pub cfg: IMPISPDrawBlockAttr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPISPDrawBlockAttr__bindgen_ty_1 {
    #[doc = "< "]
    pub wind: IMPISPDrawWindAttr,
    #[doc = "< "]
    pub rang: IMPISPDrawRangAttr,
    #[doc = "< "]
    pub line: IMPISPDrawLineAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawBlockAttr__bindgen_ty_1"]
        [::core::mem::size_of::<IMPISPDrawBlockAttr__bindgen_ty_1>() - 18usize];
    ["Alignment of IMPISPDrawBlockAttr__bindgen_ty_1"]
        [::core::mem::align_of::<IMPISPDrawBlockAttr__bindgen_ty_1>() - 2usize];
    ["Offset of field: IMPISPDrawBlockAttr__bindgen_ty_1::wind"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr__bindgen_ty_1, wind) - 0usize];
    ["Offset of field: IMPISPDrawBlockAttr__bindgen_ty_1::rang"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr__bindgen_ty_1, rang) - 0usize];
    ["Offset of field: IMPISPDrawBlockAttr__bindgen_ty_1::line"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr__bindgen_ty_1, line) - 0usize];
};
impl Default for IMPISPDrawBlockAttr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPDrawBlockAttr"][::core::mem::size_of::<IMPISPDrawBlockAttr>() - 32usize];
    ["Alignment of IMPISPDrawBlockAttr"][::core::mem::align_of::<IMPISPDrawBlockAttr>() - 4usize];
    ["Offset of field: IMPISPDrawBlockAttr::pinum"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, pinum) - 0usize];
    ["Offset of field: IMPISPDrawBlockAttr::type_"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, type_) - 4usize];
    ["Offset of field: IMPISPDrawBlockAttr::color_type"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, color_type) - 8usize];
    ["Offset of field: IMPISPDrawBlockAttr::cfg"]
        [::core::mem::offset_of!(IMPISPDrawBlockAttr, cfg) - 12usize];
};
impl Default for IMPISPDrawBlockAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDrawBlock(IMPISPDrawBlockAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[in] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)2;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.line.enable = en;\n block.cfg.line.startx = left / 2 * 2;\n block.cfg.line.starty = top / 2 * 2;\n block.cfg.line.endx = w / 2 * 2;\n block.cfg.line.endy = h / 2 * 2;\n block.cfg.line.color.ayuv.y_value = y;\n block.cfg.line.color.ayuv.u_value = u;\n block.cfg.line.color.ayuv.v_value = v;\n block.cfg.line.width = lw / 2 * 2;\n block.cfg.line.alpha = alpha;\n IMP_ISP_Tuning_SetDrawBlock(&block);\n\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)0;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.wind.enable = en;\n block.cfg.wind.left = left / 2 * 2;\n block.cfg.wind.top = top / 2 * 2;\n block.cfg.wind.width = w / 2 * 2;\n block.cfg.wind.height = h / 2 * 2;\n block.cfg.wind.color.ayuv.y_value = y;\n block.cfg.wind.color.ayuv.u_value = u;\n block.cfg.wind.color.ayuv.v_value = v;\n block.cfg.wind.line_width = lw / 2 * 2;\n block.cfg.wind.alpha = alpha;\n\n IMP_ISP_Tuning_SetDrawBlock(&block);\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)1;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.rang.enable = en;\n block.cfg.rang.left = left / 2 * 2;\n block.cfg.rang.top = top / 2 * 2;\n block.cfg.rang.width = w / 2 * 2;\n block.cfg.rang.height = h / 2 * 2;\n block.cfg.rang.color.ayuv.y_value = y;\n block.cfg.rang.color.ayuv.u_value = u;\n block.cfg.rang.color.ayuv.v_value = v;\n block.cfg.rang.line_width = lw / 2 * 2;\n block.cfg.rang.alpha = alpha;\n block.cfg.rang.extend = extend / 2 * 2;\n\n IMP_ISP_Tuning_SetDrawBlock(&block);\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDrawBlock(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDrawBlock(IMPISPDrawBlockAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[out] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPDrawBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetDrawBlock(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetDrawBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, type:%d, color type:%d\\n\", attr.pinum, attr.type, attr.color_type);\n switch (attr.type) {\n      case IMP_ISP_DRAW_WIND:\n          printf(\"enable:%d\\n\", attr.wind.enable);\n          if (attr.wind.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_RANGE:\n          printf(\"enable:%d\\n\", attr.rang.enable);\n          if (attr.rang.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_LINE:\n          printf(\"enable:%d\\n\", attr.line.enable);\n          if (attr.line.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      default:\n          break;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDrawBlock(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetDefaultBinPath_Sec(char *path)\n\n ISP bin\n\n @param[in] path  bin\n\n @retval 0 \n @retval 0 \n\n @remark ISPBin\n\n @attention sensorISP"]
    pub fn IMP_ISP_SetDefaultBinPath_Sec(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetDefaultBinPath_Sec(char *path)\n\n ISP bin\n\n @param[out] path\tbin\n\n @retval 0 \n @retval 0 \n\n @remark ISPBin\n\n @attention sensor\n @attention ISPbin"]
    pub fn IMP_ISP_GetDefaultBinPath_Sec(path: *mut libc::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_SetSensorRegister_Sec(uint32_t reg, uint32_t value)\n\n sensor\n\n @param[in] reg \n\n @param[in] value \n\n @retval 0 \n @retval 0 \n\n @remark sensor\n\n @attention ."]
    pub fn IMP_ISP_SetSensorRegister_Sec(reg: u32, value: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_GetSensorRegister_Sec(uint32_t reg, uint32_t *value)\n\n sensor\n\n @param[in] reg \n\n @param[in] value \n\n @retval 0 \n @retval 0 \n\n @remark sensor\n\n @attention ."]
    pub fn IMP_ISP_GetSensorRegister_Sec(reg: u32, value: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSensorFPS_Sec(uint32_t fps_num, uint32_t fps_den)\n\n \n\n @param[in] fps_num \n @param[in] fps_den \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor  IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSensorFPS_Sec(fps_num: u32, fps_den: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorFPS_Sec(uint32_t *fps_num, uint32_t *fps_den)\n\n \n\n @param[in] fps_num \n @param[in] fps_den \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor  IMP_ISP_EnableTuning\n @attention "]
    pub fn IMP_ISP_Tuning_GetSensorFPS_Sec(fps_num: *mut u32, fps_den: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAntiFlickerAttr_Sec(IMPISPAntiflickerAttr attr)\n\n ISP\n\n @param[in] attr \n\n @retval 0 \n @retval 0 \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetAntiFlickerAttr_Sec(attr: IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAntiFlickerAttr_Sec(IMPISPAntiflickerAttr *pattr)\n\n ISP\n\n @param[in] pattr \n\n @retval 0 \n @retval 0 \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetAntiFlickerAttr_Sec(pattr: *mut IMPISPAntiflickerAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBrightness_Sec(unsigned char bright)\n\n ISP \n\n @param[in] bright \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetBrightness_Sec(bright: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBrightness_Sec(unsigned char *pbright)\n\n ISP \n\n @param[in] bright \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetBrightness_Sec(pbright: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetContrast_Sec(unsigned char contrast)\n\n ISP \n\n @param[in] contrast \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetContrast_Sec(contrast: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetContrast_Sec(unsigned char *pcontrast)\n\n ISP \n\n @param[in] contrast \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetContrast_Sec(pcontrast: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSharpness_Sec(unsigned char sharpness)\n\n ISP \n\n @param[in] sharpness \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetSharpness_Sec(sharpness: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSharpness_Sec(unsigned char *psharpness)\n\n ISP \n\n @param[in] sharpness \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetSharpness_Sec(psharpness: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBcshHue_Sec(unsigned char hue)\n\n \n\n @param[in] hue \n\n @retval 0 \n @retval 0 \n\n @remark 1281281280~255\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetBcshHue_Sec(hue: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBcshHue_Sec(unsigned char *hue)\n\n \n\n @param[out] hue \n\n @retval 0 \n @retval 0 \n\n @remark 1281281280~255\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetBcshHue_Sec(hue: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSaturation_Sec(unsigned char sat)\n\n ISP \n\n @param[in] sat \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetSaturation_Sec(sat: libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSaturation_Sec(unsigned char *psat)\n\n ISP \n\n @param[in] sat \n\n @retval 0 \n @retval 0 \n\n @remark 128128128\n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_GetSaturation_Sec(psat: *mut libc::c_uchar) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetTotalGain_Sec(uint32_t *gain)\n\n ISP\n\n @param[in] gain ,[24.8]24bit8bit\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor  IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetTotalGain_Sec(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " ISP\n\n @fn int IMP_ISP_Tuning_SetISPHflip_Sec(IMPISPTuningOpsMode mode)\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPHflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPHflip_Sec(IMPISPTuningOpsMode *pmode)\n\n ISP\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPHflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip_Sec(IMPISPTuningOpsMode mode)\n\n ISP\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPVflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPVflip_Sec(IMPISPTuningOpsMode *pmode)\n\n ISP\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPVflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " Sensor\n\n @fn int IMP_ISP_Tuning_SetSensorHflip_Sec(IMPISPTuningOpsMode mode)\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSensorHflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorHflip_Sec(IMPISPTuningOpsMode *pmode)\n\n Sensor\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetSensorHflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip_Sec(IMPISPTuningOpsMode mode)\n\n Sensor\n\n @param[in] mode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSensorVflip_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorVflip_Sec(IMPISPTuningOpsMode *pmode)\n\n Sensor\n\n @param[in] pmode \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetSensorVflip_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPRunningMode_Sec(IMPISPRunningMode mode)\n\n ISP\n\n @param[in] mode\n\n @retval 0 \n @retval 0 \n\n \n @code\n IMPISPRunningMode mode;\n\n\tif( it is during a night now){\nmode = IMPISP_RUNNING_MODE_NIGHT\n}else{\nmode = IMPISP_RUNNING_MODE_DAY;\n}\nret = IMP_ISP_Tuning_SetISPRunningMode_Sec(mode);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetISPRunningMode error !\\n\");\nreturn -1;\n}\n\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPRunningMode_Sec(mode: IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPRunningMode_Sec(IMPISPRunningMode *pmode)\n\n ISP\n\n @param[in] pmode\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPRunningMode_Sec(pmode: *mut IMPISPRunningMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPCustomMode_Sec(IMPISPTuningOpsMode mode)\n\n ISP Custom Mode.\n\n @param[in] mode Custom \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetISPCustomMode_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPCustomMode_Sec(IMPISPTuningOpsMode mode)\n\n ISP Custom Mode.\n\n @param[out] mode Custom \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetISPCustomMode_Sec(pmode: *mut IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetGamma_Sec(IMPISPGamma *gamma)\n\n GAMMA.\n @param[in] gamma gamma\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetGamma_Sec(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetGamma_Sec(IMPISPGamma *gamma)\n\n GAMMA.\n @param[out] gamma gamma\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetGamma_Sec(gamma: *mut IMPISPGamma) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeComp_Sec(int comp)\n\n AEAEAE target[0-255].\n @param[in] comp AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeComp_Sec(comp: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeComp_Sec(int *comp)\n\n AE\n @param[out] comp AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeComp_Sec(comp: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeLuma_Sec(int *luma)\n\n \n\n @param[out] luma AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeLuma_Sec(luma: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeFreeze_Sec(IMPISPTuningOpsMode mode)\n\n AE Freeze.\n\n @param[in] mode AE Freeze.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeFreeze_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetExpr_Sec(IMPISPExpr *expr)\n\n AE\n\n @param[in] expr AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetExpr_Sec(expr: *mut IMPISPExpr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetExpr_Sec(IMPISPExpr *expr)\n\n AE\n\n @param[out] expr AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetExpr_Sec(expr: *mut IMPISPExpr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_Sec(IMPISPWB *wb)\n\n rgainbgain\n\n @param[in] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetWB_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetWB_Sec(IMPISPWB *wb)\n\n \n\n @param[out] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetWB_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_Statis_Sec(IMPISPWB *wb)\n\n \n\n @param[out] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetWB_Statis_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_GOL_Statis_Sec(IMPISPWB *wb)\n\n \n\n @param[out] wb \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetWB_GOL_Statis_Sec(wb: *mut IMPISPWB) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbClust_Sec(IMPISPAWBCluster *awb_cluster);\n\n CLuster AWB\n\n @param[in] CLuster AWB awb_cluster[]Tuning\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbClust_Sec(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbClust_Sec(IMPISPAWBCluster *awb_cluster)\n\n CLuster AWB\n\n @param[out] CLuster AWB \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbClust_Sec(awb_cluster: *mut IMPISPAWBCluster) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_SetAwbCtTrend_Sec(IMPISPAWBCtTrend *ct_trend);\n\n rgainbgainoffset\n\n @param[in] ct_trend rgainbgain offset\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbCtTrend_Sec(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
extern "C" {
    #[doc = " int IMP_ISP_Tuning_GetAwbCtTrend_Sec(IMPISPAWBCtTrend *ct_trend);\n\n rgain offsetbgain offset\n\n @param[out] ct_trend rgainbgain offset\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbCtTrend_Sec(ct_trend: *mut IMPISPAWBCtTrend) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_GetRgbCoefft_Sec(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n sensor AWB RGB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_Awb_GetRgbCoefft_Sec(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_Awb_SetRgbCoefft_Sec(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n sensorAWB RGB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning\n\n \n @code\n IMPISPCOEFFTWB isp_core_rgb_coefft_wb_attr;\n\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_r=x;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_g=y;\nisp_core_rgb_coefft_wb_attr.rgb_coefft_wb_b=z;\nIMP_ISP_Tuning_Awb_SetRgbCoefft_Sec(&isp_core_rgb_coefft_wb_attr);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_Awb_SetRgbCoefft error !\\n\");\nreturn -1;\n}"]
    pub fn IMP_ISP_Tuning_Awb_SetRgbCoefft_Sec(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxAgain_Sec(uint32_t gain)\n\n sensorAgain\n\n @param[in] gain sensoragain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMaxAgain_Sec(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxAgain_Sec(uint32_t *gain)\n\n sensorAgain\n\n @param[out] gain sensoragain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMaxAgain_Sec(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxDgain_Sec(uint32_t gain)\n\n ISPDgain\n\n @param[in] ISP Dgain dgain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMaxDgain_Sec(gain: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxDgain_Sec(uint32_t *gain)\n\n ISPDgain\n\n @param[out] ISP Dgain dgain.01x322x\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMaxDgain_Sec(gain: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHiLightDepress_Sec(uint32_t strength)\n\n \n\n @param[in] strength .0-10], 0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetHiLightDepress_Sec(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHiLightDepress_Sec(uint32_t *strength)\n\n \n\n @param[out] strength .0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetHiLightDepress_Sec(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBacklightComp_Sec(uint32_t strength)\n\n \n\n @param[in] strength .0-10], 0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetBacklightComp_Sec(strength: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBacklightComp_Sec(uint32_t *strength)\n\n \n\n @param[out] strength .0\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetBacklightComp_Sec(strength: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetTemperStrength_Sec(uint32_t ratio)\n\n 3D\n\n @param[in] ratio .128,128128.0-255]. *\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetTemperStrength_Sec(ratio: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSinterStrength_Sec(uint32_t ratio)\n\n 2D\n\n @param[in] ratio .128,128128.0-255].\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetSinterStrength_Sec(ratio: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetEVAttr_Sec(IMPISPEVAttr *attr)\n\n EV\n @param[out] attr EV\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetEVAttr_Sec(attr: *mut IMPISPEVAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableMovestate_Sec(void)\n\n sensorISP\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_EnableMovestate_Sec() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_DisableMovestate_Sec(void)\n\n sensorISP\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_Tuning_EnableMovestate"]
    pub fn IMP_ISP_Tuning_DisableMovestate_Sec() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeWeight_Sec(IMPISPWeight *ae_weight)\n\n AE\n\n @param[in] ae_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeWeight_Sec(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeWeight_Sec(IMPISPWeight *ae_weight)\n\n AE\n\n @param[out] ae_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeWeight_Sec(ae_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_GetROI_Sec(IMPISPWeight *roi_weight)\n\n AE\n\n @param[out] roi_weight AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_AE_GetROI_Sec(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_SetROI_Sec(IMPISPWeight *roi_weight)\n\n AE\n\n @param[in] roi_weight AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_AE_SetROI_Sec(roi_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbWeight_Sec(IMPISPWeight *awb_weight)\n\n AWB\n\n @param[in] awb_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbWeight_Sec(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbWeight_Sec(IMPISPWeight *awb_weight)\n\n AWB\n\n @param[out] awb_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbWeight_Sec(awb_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbZone_Sec(IMPISPAWBZONE *awb_zone)\n\n WB\n\n @param[out] awb_zone \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbZone_Sec(awb_zone: *mut IMPISPAWBZone) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_ALGO_Sec(IMPISPAWBALGO wb_algo)\n\n AWB\n\n @param[in] wb_algo AWB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetWB_ALGO_Sec(wb_algo: IMPISPAWBAlgo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeHist_Sec(IMPISPAEHist *ae_hist)\n\n AE\n\n @param[in] ae_hist AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeHist_Sec(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Sec(IMPISPAEHist *ae_hist)\n\n AE\n\n @param[out] ae_hist AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeHist_Sec(ae_hist: *mut IMPISPAEHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Origin_Sec(IMPISPAEHistOrigin *ae_hist)\n\n AE 256 bin\n\n @param[out] ae_hist AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeHist_Origin_Sec(ae_hist: *mut IMPISPAEHistOrigin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbHist_Sec(IMPISPAWBHist *awb_hist)\n\n AWB\n\n @param[out] awb_hist AWB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAwbHist_Sec(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbHist_Sec(IMPISPAWBHist *awb_hist)\n\n AWB\n\n @param[in] awb_hist AWB\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbHist_Sec(awb_hist: *mut IMPISPAWBHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetAFMetrices_Sec(unsigned int *metric);\n\n AF\n\n @param[out] metric AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAFMetrices_Sec(metric: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfHist_Sec(IMPISPAFHist *af_hist);\n\n AF\n\n @param[out] af_hist AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAfHist_Sec(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfHist_Sec(IMPISPAFHist *af_hist)\n\n AF\n\n @param[in] af_hist AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAfHist_Sec(af_hist: *mut IMPISPAFHist) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfWeight_Sec(IMPISPWeight *af_weight)\n\n AF\n\n @param[in] af_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAfWeight_Sec(af_weigh: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfWeight_Sec(IMPISPWeight *af_weight)\n\n AF\n\n @param[out] af_weight \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAfWeight_Sec(af_weight: *mut IMPISPWeight) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfZone_Sec(IMPISPZone *af_zone)\n\n AFzone\n\n @param[out] af_zone AF\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAfZone_Sec(af_zone: *mut IMPISPZone) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_WaitFrame_Sec(IMPISPWaitFrameAttr *attr)\n \n\n @param[out] attr \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_WaitFrame_Sec(attr: *mut IMPISPWaitFrameAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeMin_Sec(IMPISPAEMin *ae_min)\n\n AE\n\n @param[in] ae_min AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeMin_Sec(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeMin_Sec(IMPISPAEMin *ae_min)\n\n AE\n\n @param[out] ae_min AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeMin_Sec(ae_min: *mut IMPISPAEMin) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAe_IT_MAX_Sec(unsigned int it_max)\n\n AE\n\n @param[in] it_max AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAe_IT_MAX_Sec(it_max: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAE_IT_MAX_Sec(unsigned int *it_max)\n\n AE\n\n @param[out] it_max AE\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAE_IT_MAX_Sec(it_max: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeZone_Sec(IMPISPZone *ae_zone)\n\n AEzoneY\n\n @param[out] ae_zone AEY\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeZone_Sec(ae_zone: *mut IMPISPZone) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList_Sec(IMPISPAETargetList *target_list)\n\n AE\n\n @param[in] target_list  \n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeTargetList_Sec(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList_Sec(IMPISPAETargetList *target_list)\n\n AE\n\n @param[out] target_list  \n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeTargetList_Sec(target_list: *mut IMPISPAETargetList) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetModuleControl_Sec(IMPISPModuleCtl *ispmodule)\n\n ISPbypass\n\n @param[in] ispmodule ISPbypass.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetModuleControl_Sec(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetModuleControl_Sec(IMPISPModuleCtl *ispmodule)\n\n ISPbypass.\n\n @param[out] ispmodule ISPbypass\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetModuleControl_Sec(ispmodule: *mut IMPISPModuleCtl) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetFrontCrop_Sec(IMPISPFrontCrop *ispfrontcrop)\n\n ISPCrop\n\n @param[in] ispfrontcrop Crop\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetFrontCrop_Sec(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetFrontCrop_Sec(IMPISPFrontCrop *ispfrontcrop)\n\n Crop.\n\n @param[out] ispfrontcrop Crop\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetFrontCrop_Sec(ispfrontcrop: *mut IMPISPFrontCrop) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDPC_Strength_Sec(unsigned int strength)\n\n DPC.\n\n @param[in] strength .128,128128.0-255]\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDPC_Strength_Sec(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDPC_Strength_Sec(unsigned int *strength)\n\n DPC.\n\n @param[out] strength .128,128128.0-255]\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDPC_Strength_Sec(ratio: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDRC_Strength_Sec(unsigned int ratio)\n\n DRC.\n\n @param[in] strength .128,128128.0-255]\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDRC_Strength_Sec(ratio: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDRC_Strength_Sec(unsigned int *ratio)\n\n DRC.\n\n @param[out] ratio .128,128128.0-255]\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDRC_Strength_Sec(ratio: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHVFLIP_Sec(IMPISPHVFLIP hvflip)\n\n HV Flip.\n\n @param[in] hvflip HV Flip.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetHVFLIP_Sec(hvflip: IMPISPHVFLIP) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHVFlip_Sec(IMPISPHVFLIP *hvflip)\n\n HV Flip.\n\n @param[out] hvflip HV Flip.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetHVFlip_Sec(hvflip: *mut IMPISPHVFLIP) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMask_Sec(IMPISPMASKAttr *mask)\n\n .\n\n @param[in] mask .\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMask_Sec(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMask_Sec(IMPISPMASKAttr *mask)\n\n .\n\n @param[out] mask .\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMask_Sec(mask: *mut IMPISPMASKAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorAttr_Sec(IMPISPSENSORAttr *attr)\n\n .\n\n @param[out] attr sensor.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetSensorAttr_Sec(attr: *mut IMPISPSENSORAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDRC_Sec(IMPISPTuningOpsMode mode)\n\n DRC.\n\n @param[out] mode DRC.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_EnableDRC_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDefog_Sec(IMPISPTuningOpsMode mode)\n\n Defog.\n\n @param[out] mode Defog.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_EnableDefog_Sec(mode: IMPISPTuningOpsMode) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbCt_Sec(unsigned int *ct)\n\n AWB.\n\n @param[in] ct AWB.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAwbCt_Sec(ct: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAWBCt_Sec(unsigned int *ct)\n\n AWB.\n\n @param[out] ct AWB.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAWBCt_Sec(ct: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetCCMAttr_Sec(IMPISPCCMAttr *ccm)\n\n CCM.\n\n @param[in] ccm CCM.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetCCMAttr_Sec(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetCCMAttr_Sec(IMPISPCCMAttr *ccm)\n\n CCM.\n\n @param[out] ccm CCM.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetCCMAttr_Sec(ccm: *mut IMPISPCCMAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeAttr_Sec(IMPISPAEAttr *ae)\n\n AE.\n\n @param[in] ae AE.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetAeAttr_Sec(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeAttr_Sec(IMPISPAEAttr *ae)\n\n AE.\n\n @param[out] ae AE.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning\n @attention IMPISPAEAttr0"]
    pub fn IMP_ISP_Tuning_GetAeAttr_Sec(ae: *mut IMPISPAEAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeState_Sec(IMPISPAEState *ae_state)\n\n AE.\n\n @param[out] ae AE.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetAeState_Sec(ae_state: *mut IMPISPAEState) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetScalerLv_Sec(IMPISPScalerLv *scaler_level)\n\n Set Scaler .\n\n @param[in] mscaler .\n\n @retval 0 \n @retval 0 \n\n @attention ISP."]
    pub fn IMP_ISP_Tuning_SetScalerLv_Sec(scaler_level: *mut IMPISPScalerLv) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBlcAttr_Sec(IMPISPBlcAttr *blc)\n\n BLC.\n\n @param[out] blc blc.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning\n @attention IMPISPAEAttr0"]
    pub fn IMP_ISP_Tuning_GetBlcAttr_Sec(blc: *mut IMPISPBlcAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDefog_Strength_Sec(uint8_t *ratio)\n\n Defog\n\n @param[in] ratio  Defog.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDefog_Strength_Sec(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDefog_Strength_Sec(uint8_t *ratio)\n\n Defog\n\n @param[in] ratio  Defog.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDefog_Strength_Sec(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetCsc_Attr_Sec(IMPISPCscAttr *attr)\n\n CSC\n\n @param[in] attr CSC.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetCsc_Attr_Sec(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetCsc_Attr_Sec(IMPISPCscAttr *attr)\n\n CSC\n\n @param[in] attr CSC.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetCsc_Attr_Sec(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFrameDrop_Sec(IMPISPFrameDropAttr *attr)\n\n \n\n @param[in] attr      \n\n @retval 0 \n @retval 0 \n\n @remark (lsize+1)(fmark)\n @remark lsize=3,fmark=0x5(424)\n\n @attention IMP_ISP_Open"]
    pub fn IMP_ISP_SetFrameDrop_Sec(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetFrameDrop_Sec(IMPISPFrameDropAttr *attr)\n\n \n\n @param[out] attr     \n\n @retval 0 \n @retval 0 \n\n @remark (lsize+1)(fmark)\n @remark lsize=3,fmark=0x5(424)\n\n @attention IMP_ISP_Open"]
    pub fn IMP_ISP_GetFrameDrop_Sec(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFixedContraster_Sec(IMPISPFixedContrastAttr *attr)\n\n mjpeg\n\n @param[out] attr\t.\n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_SetFixedContraster_Sec(attr: *mut IMPISPFixedContrastAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAutoZoom_Sec(IMPISPAutoZoom *ispautozoom)\n\n \n\n @param[in] \n\n @retval 0 \n @retval 0 \n\n @attention IMP_ISP_EnableSensor."]
    pub fn IMP_ISP_Tuning_SetAutoZoom_Sec(ispautozoom: *mut IMPISPAutoZoom) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetMaskBlock_Sec(IMPISPMaskBlockAttr *mask)\n\n .\n\n @param[in] num   sensor\n @param[in] mask  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr block;\n\n if (en) {\n      block.chx = 0;\n      block.pinum = 0;\n      block.mask_en = 1;\n      block.mask_pos_top = 10;\n      block.mask_pos_left = 100;\n      block.mask_width = 200;\n      block.mask_height = 200;\n      block.mask_type = IMPISP_MASK_TYPE_YUV;\n      block.mask_value.ayuv.y_value = 100;\n      block.mask_value.ayuv.u_value = 100;\n      block.mask_value.ayuv.v_value = 100;\n } else {\n      block.mask_en = 0;\n }\n\n ret = IMP_ISP_Tuning_SetMaskBlock_Sec(&block);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetMaskBlock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetMaskBlock_Sec(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetMaskBlock_Sec(IMPISPMaskBlockAttr *mask)\n\n .\n\n @param[in] num   sensor\n @param[out] mask .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPMaskBlockAttr attr;\n\n attr.chx = 0;\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetMaskBlock_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetMaskBlock error !\\n\");\n \treturn -1;\n }\n printf(\"chx:%d, pinum:%d, en:%d\\n\", attr.chx, attr.pinum, attr.mask_en);\n if (attr.mask_en) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetMaskBlock_Sec(mask: *mut IMPISPMaskBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDAttr_Sec(IMPISPOSDAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[in] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n attr.osd_type = IMP_ISP_PIC_ARGB_8888;\n attr.osd_argb_type = IMP_ISP_ARGB_TYPE_BGRA;\n attr.osd_pixel_alpha_disable = IMPISP_TUNING_OPS_MODE_ENABLE;\n\n if(ret){\n \tIMP_LOG_ERR(TAG, \" error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetOSDAttr_Sec(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDAttr_Sec(IMPISPOSDAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[out] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDAttr attr;\n\n ret = IMP_ISP_Tuning_GetOSDAttr_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDAttr error !\\n\");\n \treturn -1;\n }\n printf(\"type:%d, argb_type:%d, mode:%d\\n\", attr.osd_type,\n attr.osd_argb_type, attr.osd_pixel_alpha_disable);\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetOSDAttr_Sec(attr: *mut IMPISPOSDAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetOSDBlock_Sec(IMPISPOSDBlockAttr *attr)\n\n OSD.\n\n @param[in] num   sensor\n @param[in] attr  OSD.\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr block;\n\n block.pinum = pinum;\n block.osd_enable = enable;\n block.osd_left = left / 2 * 2;\n block.osd_top = top / 2 * 2;\n block.osd_width = width;\n block.osd_height = height;\n block.osd_image = image;\n block.osd_stride = stride;\n\n ret = IMP_ISP_Tuning_SetOSDBlock_Sec(&block);\n if(ret){\n \timp_log_err(tag, \"imp_isp_tuning_setosdblock error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetOSDBlock_Sec(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetOSDBlock_Sec(IMPISPOSDBlockAttr *attr)\n\n OSD.\n\n @param[in] num   sensor\n @param[out] attr OSD.\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPOSDBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetOSDBlock_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetOSDBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, en:%d\\n\", attr.pinum, attr.osd_enable);\n if (attr.osd_enable) {\n      printf(\"top:%d, left:%d ...\\n\", ...);\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetOSDBlock_Sec(attr: *mut IMPISPOSDBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDrawBlock_Sec(IMPISPDrawBlockAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[in] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)2;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.line.enable = en;\n block.cfg.line.startx = left / 2 * 2;\n block.cfg.line.starty = top / 2 * 2;\n block.cfg.line.endx = w / 2 * 2;\n block.cfg.line.endy = h / 2 * 2;\n block.cfg.line.color.ayuv.y_value = y;\n block.cfg.line.color.ayuv.u_value = u;\n block.cfg.line.color.ayuv.v_value = v;\n block.cfg.line.width = lw / 2 * 2;\n block.cfg.line.alpha = alpha;\n IMP_ISP_Tuning_SetDrawBlock_Sec(&block);\n\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)0;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.wind.enable = en;\n block.cfg.wind.left = left / 2 * 2;\n block.cfg.wind.top = top / 2 * 2;\n block.cfg.wind.width = w / 2 * 2;\n block.cfg.wind.height = h / 2 * 2;\n block.cfg.wind.color.ayuv.y_value = y;\n block.cfg.wind.color.ayuv.u_value = u;\n block.cfg.wind.color.ayuv.v_value = v;\n block.cfg.wind.line_width = lw / 2 * 2;\n block.cfg.wind.alpha = alpha;\n\n IMP_ISP_Tuning_SetDrawBlock_Sec(&block);\n IMPISPDrawBlockAttr block;\n\n block.pinum = pinum;\n block.type = (IMPISPDrawType)1;\n block.color_type = (IMPISP_MASK_TYPE)ctype;\n block.cfg.rang.enable = en;\n block.cfg.rang.left = left / 2 * 2;\n block.cfg.rang.top = top / 2 * 2;\n block.cfg.rang.width = w / 2 * 2;\n block.cfg.rang.height = h / 2 * 2;\n block.cfg.rang.color.ayuv.y_value = y;\n block.cfg.rang.color.ayuv.u_value = u;\n block.cfg.rang.color.ayuv.v_value = v;\n block.cfg.rang.line_width = lw / 2 * 2;\n block.cfg.rang.alpha = alpha;\n block.cfg.rang.extend = extend / 2 * 2;\n\n IMP_ISP_Tuning_SetDrawBlock_Sec(&block);\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SetDrawBlock_Sec(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDrawBlock_Sec(IMPISPDrawBlockAttr *attr)\n\n .\n\n @param[in] num   sensor\n @param[out] attr  .\n\n @retval 0 \n @retval 0 \n\n @code\n int ret = 0;\n IMPISPDrawBlockAttr attr;\n\n attr.pinum = 0;\n ret = IMP_ISP_Tuning_GetDrawBlock_Sec(&attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_GetDrawBlock error !\\n\");\n \treturn -1;\n }\n printf(\"pinum:%d, type:%d, color type:%d\\n\", attr.pinum, attr.type, attr.color_type);\n switch (attr.type) {\n      case IMP_ISP_DRAW_WIND:\n          printf(\"enable:%d\\n\", attr.wind.enable);\n          if (attr.wind.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_RANGE:\n          printf(\"enable:%d\\n\", attr.rang.enable);\n          if (attr.rang.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      case IMP_ISP_DRAW_LINE:\n          printf(\"enable:%d\\n\", attr.line.enable);\n          if (attr.line.enable) {\n              printf(\"left:%d, ...\\n\", ...);\n          }\n          break;\n      default:\n          break;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_GetDrawBlock_Sec(attr: *mut IMPISPDrawBlockAttr) -> i32;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPIspOsdRngStat {
    IMP_ISP_OSD_RGN_FREE = 0,
    IMP_ISP_OSD_RGN_BUSY = 1,
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPISPOSDType {
    #[doc = "< "]
    ISP_OSD_REG_INV = 0,
    #[doc = "< ISP"]
    ISP_OSD_REG_PIC = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDNode {
    _unused: [u8; 0],
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPOSDSingleAttr {
    pub chx: libc::c_int,
    pub sensornum: libc::c_int,
    #[doc = "< "]
    pub chnOSDAttr: IMPISPOSDAttr,
    #[doc = "< 8"]
    pub pic: IMPISPOSDBlockAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPOSDSingleAttr"][::core::mem::size_of::<IMPISPOSDSingleAttr>() - 40usize];
    ["Alignment of IMPISPOSDSingleAttr"][::core::mem::align_of::<IMPISPOSDSingleAttr>() - 4usize];
    ["Offset of field: IMPISPOSDSingleAttr::chx"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, chx) - 0usize];
    ["Offset of field: IMPISPOSDSingleAttr::sensornum"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, sensornum) - 4usize];
    ["Offset of field: IMPISPOSDSingleAttr::chnOSDAttr"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, chnOSDAttr) - 8usize];
    ["Offset of field: IMPISPOSDSingleAttr::pic"]
        [::core::mem::offset_of!(IMPISPOSDSingleAttr, pic) - 20usize];
};
impl Default for IMPISPOSDSingleAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ISPOSD"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPIspOsdAttrAsm {
    pub type_: IMPISPOSDType,
    pub __anon1: IMPIspOsdAttrAsm__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPIspOsdAttrAsm__bindgen_ty_1 {
    pub stsinglepicAttr: IMPISPOSDSingleAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPIspOsdAttrAsm__bindgen_ty_1"]
        [::core::mem::size_of::<IMPIspOsdAttrAsm__bindgen_ty_1>() - 40usize];
    ["Alignment of IMPIspOsdAttrAsm__bindgen_ty_1"]
        [::core::mem::align_of::<IMPIspOsdAttrAsm__bindgen_ty_1>() - 4usize];
    ["Offset of field: IMPIspOsdAttrAsm__bindgen_ty_1::stsinglepicAttr"]
        [::core::mem::offset_of!(IMPIspOsdAttrAsm__bindgen_ty_1, stsinglepicAttr) - 0usize];
};
impl Default for IMPIspOsdAttrAsm__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPIspOsdAttrAsm"][::core::mem::size_of::<IMPIspOsdAttrAsm>() - 44usize];
    ["Alignment of IMPIspOsdAttrAsm"][::core::mem::align_of::<IMPIspOsdAttrAsm>() - 4usize];
    ["Offset of field: IMPIspOsdAttrAsm::type_"]
        [::core::mem::offset_of!(IMPIspOsdAttrAsm, type_) - 0usize];
};
impl Default for IMPIspOsdAttrAsm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetOsdPoolSize(int size)\n\n ISPOSDrmem\n\n @param[in]\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_ISP_Tuning_SetOsdPoolSize(size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_CreateOsdRgn(int chn,IMPIspOsdAttrAsm *pIspOsdAttr)\n\n ISPOSD\n\n @param[in] chnIMPIspOsdAttrAsm \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_ISP_Tuning_CreateOsdRgn(
        chn: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetOsdRgnAttr(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n ISPOSD \n\n @param[in] sensor numhandle IMPIspOsdAttrAsm \n\n @retval 0 \n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_ISP_Tuning_SetOsdRgnAttr(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetOsdRgnAttr(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n ISPOSD \n\n @param[in] sensor numhandleIMPOSDRgnCreateStat \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_ISP_Tuning_GetOsdRgnAttr(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_ShowOsdRgn( int chn,int handle, int showFlag)\n\n ISPOSDhandle\n\n @param[in] sensor numhandleshowFlag(0:1:)\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_ISP_Tuning_ShowOsdRgn(
        chn: libc::c_int,
        handle: libc::c_int,
        showFlag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_DestroyOsdRgn(int chn,int handle)\n\n handle\n\n @param[in] sensor numhandle\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_ISP_Tuning_DestroyOsdRgn(chn: libc::c_int, handle: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPBinAttr {
    #[doc = "< Switch bin"]
    pub enable: IMPISPTuningOpsMode,
    #[doc = "< bin"]
    pub bname: [libc::c_char; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPBinAttr"][::core::mem::size_of::<IMPISPBinAttr>() - 132usize];
    ["Alignment of IMPISPBinAttr"][::core::mem::align_of::<IMPISPBinAttr>() - 4usize];
    ["Offset of field: IMPISPBinAttr::enable"]
        [::core::mem::offset_of!(IMPISPBinAttr, enable) - 0usize];
    ["Offset of field: IMPISPBinAttr::bname"]
        [::core::mem::offset_of!(IMPISPBinAttr, bname) - 4usize];
};
impl Default for IMPISPBinAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SwitchBin(IMPISPBinAttr *attr)\n\n Bin.\n\n @param[in] attr     bin\n\n @retval 0 \n @retval 0 \n @code\n int ret = 0;\n IMPISPBinAttr attr;\n char name[] = \"/etc/sensor/xxx-t23.bin\"\n\n attr.enable = IMPISP_TUNING_OPS_MODE_ENABLE;\n memcpy(attr.bname, name, sizeof(name));\n ret = IMP_ISP_Tuning_SwitchBin( &attr);\n if(ret){\n \tIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SwitchBin error !\\n\");\n \treturn -1;\n }\n @endcode\n\n @attention IMP_ISP_EnableTuning"]
    pub fn IMP_ISP_Tuning_SwitchBin(attr: *mut IMPISPBinAttr) -> i32;
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPStreamState {
    #[doc = "< Sensor10"]
    pub sensor: [libc::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPStreamState"][::core::mem::size_of::<IMPISPStreamState>() - 8usize];
    ["Alignment of IMPISPStreamState"][::core::mem::align_of::<IMPISPStreamState>() - 4usize];
    ["Offset of field: IMPISPStreamState::sensor"]
        [::core::mem::offset_of!(IMPISPStreamState, sensor) - 0usize];
};
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPISPStreamCheck {
    #[doc = "< ms"]
    pub timeout: libc::c_int,
    pub state: IMPISPStreamState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPISPStreamCheck"][::core::mem::size_of::<IMPISPStreamCheck>() - 12usize];
    ["Alignment of IMPISPStreamCheck"][::core::mem::align_of::<IMPISPStreamCheck>() - 4usize];
    ["Offset of field: IMPISPStreamCheck::timeout"]
        [::core::mem::offset_of!(IMPISPStreamCheck, timeout) - 0usize];
    ["Offset of field: IMPISPStreamCheck::state"]
        [::core::mem::offset_of!(IMPISPStreamCheck, state) - 4usize];
};
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_StreamCheck(IMPISPStreamCheck *check)\n\n .\n\n @param[in] check .\n\n @retval 0 \n @retval 0 \n\n @code\n IMPISPStreamCheck attr;\n memset(&attr, 0x0, sizeof(IMPISPStreamCheck));\n attr.timeout = 500;\n IMP_ISP_StreamCheck(&attr);\n\n printf(\"state:%d %d\\n\", attr.state.sensor[0], attr.state.sensor[1]);\n @endcode\n\n @attention ."]
    pub fn IMP_ISP_StreamCheck(check: *mut IMPISPStreamCheck) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetStreamOut(IMPISPStreamState *state)\n\n .\n\n @param[in] state .\n\n @retval 0 \n @retval 0 \n\n @code\n IMPISPStreamState attr;\n\n memset(&attr, 0x0, sizeof(IMPISPStreamState));\n attr.sensor[0] = 1;\n attr.sensor[1] = 0;\n IMP_ISP_SetStreamOut(&attr);\n @endcode\n\n @attention ."]
    pub fn IMP_ISP_SetStreamOut(state: *mut IMPISPStreamState) -> i32;
}
#[doc = " OSD "]
pub type IMPRgnHandle = libc::c_int;
#[repr(u32)]
#[doc = " DrawBox OSDbgra"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPOsdColour {
    OSD_RED = 0,
    OSD_BLACK = 1,
    OSD_GREEN = 2,
    OSD_YELLOW = 3,
}
#[repr(u32)]
#[doc = " IPU OSD "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPIpuColour {
    #[doc = "< "]
    OSD_IPU_BLACK = 4278190080,
    #[doc = "< "]
    OSD_IPU_WHITE = 4294967295,
    #[doc = "< "]
    OSD_IPU_RED = 4294901760,
    #[doc = "< "]
    OSD_IPU_GREEN = 4278255360,
    #[doc = "< "]
    OSD_IPU_BLUE = 4278190335,
}
#[repr(u32)]
#[doc = " OSD"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPOsdRgnType {
    #[doc = "< "]
    OSD_REG_INV = 0,
    #[doc = "< "]
    OSD_REG_HORIZONTAL_LINE = 1,
    #[doc = "< "]
    OSD_REG_VERTICAL_LINE = 2,
    #[doc = "< "]
    OSD_REG_RECT = 3,
    #[doc = "< "]
    OSD_REG_FOUR_CORNER_RECT = 4,
    #[doc = "< "]
    OSD_REG_BITMAP = 5,
    #[doc = "< "]
    OSD_REG_COVER = 6,
    #[doc = "< Logo"]
    OSD_REG_PIC = 7,
    #[doc = "< Logo, RMEM"]
    OSD_REG_PIC_RMEM = 8,
    OSD_REG_SLASH = 9,
    OSD_REG_ISP_PIC = 10,
    OSD_REG_ISP_LINE_RECT = 11,
    OSD_REG_ISP_COVER = 12,
    OSD_REG_MOSAIC = 13,
}
#[doc = " OSD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lineRectData {
    #[doc = "< IMPOsdColour"]
    pub color: u32,
    #[doc = "< "]
    pub linewidth: u32,
    #[doc = "< "]
    pub linelength: u32,
    #[doc = "< "]
    pub rectlinelength: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lineRectData"][::core::mem::size_of::<lineRectData>() - 16usize];
    ["Alignment of lineRectData"][::core::mem::align_of::<lineRectData>() - 4usize];
    ["Offset of field: lineRectData::color"][::core::mem::offset_of!(lineRectData, color) - 0usize];
    ["Offset of field: lineRectData::linewidth"]
        [::core::mem::offset_of!(lineRectData, linewidth) - 4usize];
    ["Offset of field: lineRectData::linelength"]
        [::core::mem::offset_of!(lineRectData, linelength) - 8usize];
    ["Offset of field: lineRectData::rectlinelength"]
        [::core::mem::offset_of!(lineRectData, rectlinelength) - 12usize];
};
#[doc = " OSD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct coverData {
    #[doc = "< bgra"]
    pub color: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of coverData"][::core::mem::size_of::<coverData>() - 4usize];
    ["Alignment of coverData"][::core::mem::align_of::<coverData>() - 4usize];
    ["Offset of field: coverData::color"][::core::mem::offset_of!(coverData, color) - 0usize];
};
#[doc = " OSD"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct picData {
    #[doc = "< "]
    pub pData: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of picData"][::core::mem::size_of::<picData>() - 4usize];
    ["Alignment of picData"][::core::mem::align_of::<picData>() - 4usize];
    ["Offset of field: picData::pData"][::core::mem::offset_of!(picData, pData) - 0usize];
};
impl Default for picData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPOSDRgnAttrData {
    #[doc = "< "]
    pub bitmapData: *mut libc::c_void,
    #[doc = "< "]
    pub lineRectData: lineRectData,
    #[doc = "< "]
    pub coverData: coverData,
    #[doc = "< "]
    pub picData: picData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDRgnAttrData"][::core::mem::size_of::<IMPOSDRgnAttrData>() - 16usize];
    ["Alignment of IMPOSDRgnAttrData"][::core::mem::align_of::<IMPOSDRgnAttrData>() - 4usize];
    ["Offset of field: IMPOSDRgnAttrData::bitmapData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, bitmapData) - 0usize];
    ["Offset of field: IMPOSDRgnAttrData::lineRectData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, lineRectData) - 0usize];
    ["Offset of field: IMPOSDRgnAttrData::coverData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, coverData) - 0usize];
    ["Offset of field: IMPOSDRgnAttrData::picData"]
        [::core::mem::offset_of!(IMPOSDRgnAttrData, picData) - 0usize];
};
impl Default for IMPOSDRgnAttrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD Font"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPOSDFontSizeAttrData {
    pub fontWidth: libc::c_uint,
    pub fontHeight: libc::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDFontSizeAttrData"][::core::mem::size_of::<IMPOSDFontSizeAttrData>() - 8usize];
    ["Alignment of IMPOSDFontSizeAttrData"]
        [::core::mem::align_of::<IMPOSDFontSizeAttrData>() - 4usize];
    ["Offset of field: IMPOSDFontSizeAttrData::fontWidth"]
        [::core::mem::offset_of!(IMPOSDFontSizeAttrData, fontWidth) - 0usize];
    ["Offset of field: IMPOSDFontSizeAttrData::fontHeight"]
        [::core::mem::offset_of!(IMPOSDFontSizeAttrData, fontHeight) - 4usize];
};
#[doc = " OSD Font"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPOSDFontAttrData {
    #[doc = "< "]
    pub invertColorSwitch: libc::c_uint,
    #[doc = "<  190"]
    pub luminance: libc::c_uint,
    #[doc = "< "]
    pub length: libc::c_uint,
    #[doc = "< "]
    pub data: IMPOSDFontSizeAttrData,
    #[doc = "< "]
    pub istimestamp: libc::c_uint,
    #[doc = "< "]
    pub colType: [libc::c_uint; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDFontAttrData"][::core::mem::size_of::<IMPOSDFontAttrData>() - 280usize];
    ["Alignment of IMPOSDFontAttrData"][::core::mem::align_of::<IMPOSDFontAttrData>() - 4usize];
    ["Offset of field: IMPOSDFontAttrData::invertColorSwitch"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, invertColorSwitch) - 0usize];
    ["Offset of field: IMPOSDFontAttrData::luminance"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, luminance) - 4usize];
    ["Offset of field: IMPOSDFontAttrData::length"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, length) - 8usize];
    ["Offset of field: IMPOSDFontAttrData::data"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, data) - 12usize];
    ["Offset of field: IMPOSDFontAttrData::istimestamp"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, istimestamp) - 20usize];
    ["Offset of field: IMPOSDFontAttrData::colType"]
        [::core::mem::offset_of!(IMPOSDFontAttrData, colType) - 24usize];
};
impl Default for IMPOSDFontAttrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPOSDIspDraw {
    pub stDrawAttr: IMPISPDrawBlockAttr,
    pub stpicAttr: IMPISPOSDBlockAttr,
    pub stCoverAttr: IMPISPMaskBlockAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDIspDraw"][::core::mem::size_of::<IMPOSDIspDraw>() - 72usize];
    ["Alignment of IMPOSDIspDraw"][::core::mem::align_of::<IMPOSDIspDraw>() - 4usize];
    ["Offset of field: IMPOSDIspDraw::stDrawAttr"]
        [::core::mem::offset_of!(IMPOSDIspDraw, stDrawAttr) - 0usize];
    ["Offset of field: IMPOSDIspDraw::stpicAttr"]
        [::core::mem::offset_of!(IMPOSDIspDraw, stpicAttr) - 32usize];
    ["Offset of field: IMPOSDIspDraw::stCoverAttr"]
        [::core::mem::offset_of!(IMPOSDIspDraw, stCoverAttr) - 52usize];
};
impl Default for IMPOSDIspDraw {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mosaicPointAttr {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub mosaic_width: libc::c_int,
    pub mosaic_height: libc::c_int,
    pub frame_width: libc::c_int,
    pub frame_height: libc::c_int,
    pub mosaic_min_size: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mosaicPointAttr"][::core::mem::size_of::<mosaicPointAttr>() - 28usize];
    ["Alignment of mosaicPointAttr"][::core::mem::align_of::<mosaicPointAttr>() - 4usize];
    ["Offset of field: mosaicPointAttr::x"][::core::mem::offset_of!(mosaicPointAttr, x) - 0usize];
    ["Offset of field: mosaicPointAttr::y"][::core::mem::offset_of!(mosaicPointAttr, y) - 4usize];
    ["Offset of field: mosaicPointAttr::mosaic_width"]
        [::core::mem::offset_of!(mosaicPointAttr, mosaic_width) - 8usize];
    ["Offset of field: mosaicPointAttr::mosaic_height"]
        [::core::mem::offset_of!(mosaicPointAttr, mosaic_height) - 12usize];
    ["Offset of field: mosaicPointAttr::frame_width"]
        [::core::mem::offset_of!(mosaicPointAttr, frame_width) - 16usize];
    ["Offset of field: mosaicPointAttr::frame_height"]
        [::core::mem::offset_of!(mosaicPointAttr, frame_height) - 20usize];
    ["Offset of field: mosaicPointAttr::mosaic_min_size"]
        [::core::mem::offset_of!(mosaicPointAttr, mosaic_min_size) - 24usize];
};
#[doc = " OSD"]
pub type IMPOSDMosaicAttr = mosaicPointAttr;
#[doc = " OSD"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPOSDRgnAttr {
    #[doc = "< OSD"]
    pub type_: IMPOsdRgnType,
    #[doc = "< "]
    pub rect: IMPRect,
    #[doc = "< "]
    pub line: IMPLine,
    #[doc = "< "]
    pub fmt: IMPPixelFormat,
    #[doc = "< OSD"]
    pub data: IMPOSDRgnAttrData,
    #[doc = "< ISPOSD"]
    pub osdispdraw: IMPOSDIspDraw,
    #[doc = "< OSD Font"]
    pub fontData: IMPOSDFontAttrData,
    #[doc = "< "]
    pub mosaicAttr: IMPOSDMosaicAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDRgnAttr"][::core::mem::size_of::<IMPOSDRgnAttr>() - 428usize];
    ["Alignment of IMPOSDRgnAttr"][::core::mem::align_of::<IMPOSDRgnAttr>() - 4usize];
    ["Offset of field: IMPOSDRgnAttr::type_"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, type_) - 0usize];
    ["Offset of field: IMPOSDRgnAttr::rect"][::core::mem::offset_of!(IMPOSDRgnAttr, rect) - 4usize];
    ["Offset of field: IMPOSDRgnAttr::line"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, line) - 20usize];
    ["Offset of field: IMPOSDRgnAttr::fmt"][::core::mem::offset_of!(IMPOSDRgnAttr, fmt) - 28usize];
    ["Offset of field: IMPOSDRgnAttr::data"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, data) - 32usize];
    ["Offset of field: IMPOSDRgnAttr::osdispdraw"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, osdispdraw) - 48usize];
    ["Offset of field: IMPOSDRgnAttr::fontData"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, fontData) - 120usize];
    ["Offset of field: IMPOSDRgnAttr::mosaicAttr"]
        [::core::mem::offset_of!(IMPOSDRgnAttr, mosaicAttr) - 400usize];
};
impl Default for IMPOSDRgnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " OSD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPOSDRgnTimestamp {
    #[doc = "< "]
    pub ts: u64,
    #[doc = "< "]
    pub minus: u64,
    #[doc = "< "]
    pub plus: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDRgnTimestamp"][::core::mem::size_of::<IMPOSDRgnTimestamp>() - 24usize];
    ["Alignment of IMPOSDRgnTimestamp"][::core::mem::align_of::<IMPOSDRgnTimestamp>() - 8usize];
    ["Offset of field: IMPOSDRgnTimestamp::ts"]
        [::core::mem::offset_of!(IMPOSDRgnTimestamp, ts) - 0usize];
    ["Offset of field: IMPOSDRgnTimestamp::minus"]
        [::core::mem::offset_of!(IMPOSDRgnTimestamp, minus) - 8usize];
    ["Offset of field: IMPOSDRgnTimestamp::plus"]
        [::core::mem::offset_of!(IMPOSDRgnTimestamp, plus) - 16usize];
};
#[doc = " OSD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPOSDGrpRgnAttr {
    #[doc = "< "]
    pub show: libc::c_int,
    #[doc = "< "]
    pub offPos: IMPPoint,
    #[doc = "< x"]
    pub scalex: f32,
    #[doc = "< y"]
    pub scaley: f32,
    #[doc = "< Alpha"]
    pub gAlphaEn: libc::c_int,
    #[doc = "< Alpha"]
    pub fgAlhpa: libc::c_int,
    #[doc = "< Alpha"]
    pub bgAlhpa: libc::c_int,
    #[doc = "< "]
    pub layer: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPOSDGrpRgnAttr"][::core::mem::size_of::<IMPOSDGrpRgnAttr>() - 36usize];
    ["Alignment of IMPOSDGrpRgnAttr"][::core::mem::align_of::<IMPOSDGrpRgnAttr>() - 4usize];
    ["Offset of field: IMPOSDGrpRgnAttr::show"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, show) - 0usize];
    ["Offset of field: IMPOSDGrpRgnAttr::offPos"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, offPos) - 4usize];
    ["Offset of field: IMPOSDGrpRgnAttr::scalex"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, scalex) - 12usize];
    ["Offset of field: IMPOSDGrpRgnAttr::scaley"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, scaley) - 16usize];
    ["Offset of field: IMPOSDGrpRgnAttr::gAlphaEn"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, gAlphaEn) - 20usize];
    ["Offset of field: IMPOSDGrpRgnAttr::fgAlhpa"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, fgAlhpa) - 24usize];
    ["Offset of field: IMPOSDGrpRgnAttr::bgAlhpa"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, bgAlhpa) - 28usize];
    ["Offset of field: IMPOSDGrpRgnAttr::layer"]
        [::core::mem::offset_of!(IMPOSDGrpRgnAttr, layer) - 32usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stRgnCreateStat {
    #[doc = "< osd01"]
    pub status: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stRgnCreateStat"][::core::mem::size_of::<stRgnCreateStat>() - 4usize];
    ["Alignment of stRgnCreateStat"][::core::mem::align_of::<stRgnCreateStat>() - 4usize];
    ["Offset of field: stRgnCreateStat::status"]
        [::core::mem::offset_of!(stRgnCreateStat, status) - 0usize];
};
pub type IMPOSDRgnCreateStat = stRgnCreateStat;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stRgnRigsterStat {
    #[doc = "< osd01"]
    pub status: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stRgnRigsterStat"][::core::mem::size_of::<stRgnRigsterStat>() - 4usize];
    ["Alignment of stRgnRigsterStat"][::core::mem::align_of::<stRgnRigsterStat>() - 4usize];
    ["Offset of field: stRgnRigsterStat::status"]
        [::core::mem::offset_of!(stRgnRigsterStat, status) - 0usize];
};
pub type IMPOSDRgnRegisterStat = stRgnRigsterStat;
extern "C" {
    #[doc = " @fn int IMP_OSD_SetPoolSize(int size);\n\n OSD rmem\n\n\n @retval  0 \n @retval -1 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_SetPoolSize(size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetMosaic(unsigned char *frame_virAddr, IMPOSDMosaicAttr *mosaicAttr);\n\n OSD \n\n\n @retval  0 \n @retval -1 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_SetMosaic(
        frame_virAddr: *mut libc::c_uchar,
        mosaicAttr: *mut IMPOSDMosaicAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRegionLuma(IMPRgnHandle handle,IMPOSDRgnAttr *prAttr)\n\n OSD \n\n\n @retval  0 \n @retval -1 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_GetRegionLuma(handle: IMPRgnHandle, prAttr: *mut IMPOSDRgnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RgnCreate_Query(IMPRgnHandle handle,IMPOSDRgnCreateStat *pstStatus)\n\n osd\n\n @param[in] handleIMPOSDRgnCreateStat \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_RgnCreate_Query(
        handle: IMPRgnHandle,
        pstStatus: *mut IMPOSDRgnCreateStat,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RgnRegister_Query(IMPRgnHandle handle,int grpNum,IMPOSDRgnRegisterStat *pstStatus)\n\n osd\n\n @param[in] handle grpNum OSD,: [0, @ref NR_MAX_OSD_GROUPS - 1]IMPOSDRgnRegisterStat \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_RgnRegister_Query(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pstStatus: *mut IMPOSDRgnRegisterStat,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_CreateGroup(int grpNum)\n\n OSD\n\n @param[in] grpNum OSD,: [0, @ref NR_MAX_OSD_GROUPS - 1]\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_CreateGroup(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_DestroyGroup(int grpNum)\n\n OSD\n\n @param[in] grpNum OSD,: [0, @ref NR_MAX_OSD_GROUPS - 1]\n\n @retval 0 \n @retval 0 \n\n @remark API\n\n @attention "]
    pub fn IMP_OSD_DestroyGroup(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_AttachToGroup(IMPCell *from, IMPCell *to)\n\n OSD\n\n @param[in] from OSD\n @param[in] to \n\n @retval 0 \n @retval 0 \n\n @remark SDKBindOSDAttachAPI\\n\n @ref bind \n\n @attention "]
    pub fn IMP_OSD_AttachToGroup(from: *mut IMPCell, to: *mut IMPCell) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMPRgnHandle IMP_OSD_CreateRgn(IMPOSDRgnAttr *prAttr)\n\n OSD\n\n @param[in] prAttr OSD\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_CreateRgn(prAttr: *mut IMPOSDRgnAttr) -> IMPRgnHandle;
}
extern "C" {
    #[doc = " @fn void IMP_OSD_DestroyRgn(IMPRgnHandle handle)\n\n OSD\n\n @param[in] prAttr IMP_OSD_CreateRgn\n\n @retval \n\n @remark \n\n @attention "]
    pub fn IMP_OSD_DestroyRgn(handle: IMPRgnHandle);
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RegisterRgn(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n OSD\n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] grpNum OSD\n @param[in] pgrAttr OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD\n\n @attention "]
    pub fn IMP_OSD_RegisterRgn(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_UnRegisterRgn(IMPRgnHandle handle, int grpNum)\n\n OSD\n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] grpNum OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD,\n\n @attention "]
    pub fn IMP_OSD_UnRegisterRgn(handle: IMPRgnHandle, grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr)\n\n \n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] prAttr OSD\n\n @retval 0 \n @retval 0 \n\n @remark API\n\n @attention "]
    pub fn IMP_OSD_SetRgnAttr(handle: IMPRgnHandle, prAttr: *mut IMPOSDRgnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttrWithTimestamp(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr, IMPOSDRgnTimestamp *prTs)\n\n \n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] prAttr OSD\n @param[in] prTs \n\n @retval 0 \n @retval 0 \n\n @remark API\n\n @attention "]
    pub fn IMP_OSD_SetRgnAttrWithTimestamp(
        handle: IMPRgnHandle,
        prAttr: *mut IMPOSDRgnAttr,
        prTs: *mut IMPOSDRgnTimestamp,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr)\n\n \n\n @param[in] handle IMP_OSD_CreateRgn\n @param[out] prAttr OSD\n\n @retval 0 \n @retval 0 \n\n @remark API\n\n @attention "]
    pub fn IMP_OSD_GetRgnAttr(handle: IMPRgnHandle, prAttr: *mut IMPOSDRgnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_UpdateRgnAttrData(IMPRgnHandle handle, IMPOSDRgnAttrData *prAttrData)\n\n OSD_REG_BITMAPOSD_REG_PIC\n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] prAttrData OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD_REG_BITMAPOSD_REG_PIC\n\n @attention "]
    pub fn IMP_OSD_UpdateRgnAttrData(
        handle: IMPRgnHandle,
        prAttrData: *mut IMPOSDRgnAttrData,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetGrpRgnAttr(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n OSD\n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] grpNum OSD\n @param[in] pgrAttr OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD,\n\n @attention "]
    pub fn IMP_OSD_SetGrpRgnAttr(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetGrpRgnAttr(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n OSD\n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] grpNum OSD\n @param[out] pgrAttr OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD,\n\n @attention "]
    pub fn IMP_OSD_GetGrpRgnAttr(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_ShowRgn(IMPRgnHandle handle, int grpNum, int showFlag)\n\n \n\n @param[in] handle IMP_OSD_CreateRgn\n @param[in] grpNum OSD\n @param[in] showFlag OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD,\n\n @attention "]
    pub fn IMP_OSD_ShowRgn(
        handle: IMPRgnHandle,
        grpNum: libc::c_int,
        showFlag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Start(int grpNum)\n\n OSD\n\n @param[in] grpNum OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD\n\n @attention "]
    pub fn IMP_OSD_Start(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Stop(int grpNum)\n\n OSD\n\n @param[in] grpNum OSD\n\n @retval 0 \n @retval 0 \n\n @remark APIOSD\n\n @attention "]
    pub fn IMP_OSD_Stop(grpNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr_ISP(IMPOSDRgnAttr *prAttr,int bosdshow);\n\n ISPOSD\n\n @param[in] prAttr OSDbosdshow osd0ISPosd1ISPosdipu/dbox/OSD \\n\n OSD_REG_ISP_PICOSD_REG_ISP_LINE_RECT\n\n @retval 0 \n @retval 0 \n\n @remark APIIMP_ISP_EnableTuning\n\n @attention "]
    pub fn IMP_OSD_SetRgnAttr_ISP(prAttr: *mut IMPOSDRgnAttr, bosdshow: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr_ISP(IMPOSDRgnAttr *prAttr,int *pbosdshow);\n\n ISPOSD\n\n @param[in]prAttrOSDIMPOSDIspDraw pbosdshow ISPosd1\n\n @retval 0 \n @retval 0 \n\n @remark APIIMP_ISP_EnableTuning\n\n @attention "]
    pub fn IMP_OSD_GetRgnAttr_ISP(
        prAttr: *mut IMPOSDRgnAttr,
        pbosdshow: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn IMPPixfmtToString(pixfmt: IMPPixelFormat) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Init_ISP(void);\n\n ISPOSDIMP_system_init\n\n @param[in]\n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_Init_ISP() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetPoolSize_ISP(int size)\n\n ISPOSDrmem\n\n @param[in]\n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_SetPoolSize_ISP(size: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_CreateRgn_ISP(int chn,IMPIspOsdAttrAsm *pIspOsdAttr)\n\n ISPOSD\n\n @param[in] chnIMPIspOsdAttrAsm \n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_CreateRgn_ISP(
        chn: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr_PicISP(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n ISPOSD \n\n @param[in] chnhandle IMPIspOsdAttrAsm \n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_SetRgnAttr_PicISP(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr_ISPPic(int chn,int handle, IMPIspOsdAttrAsm *pIspOsdAttr)\n\n ISPOSD \n\n @param[in] chn handleIMPOSDRgnCreateStat \n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_GetRgnAttr_ISPPic(
        chn: libc::c_int,
        handle: libc::c_int,
        pIspOsdAttr: *mut IMPIspOsdAttrAsm,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_ShowRgn_ISP( int chn,int handle, int showFlag)\n\n ISPOSDhandle\n\n @param[in] chnhandleshowFlag(0:1:)\n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_ShowRgn_ISP(
        chn: libc::c_int,
        handle: libc::c_int,
        showFlag: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_DestroyRgn_ISP(int chn,int handle)\n\n handle\n\n @param[in] chnhandle\n\n @retval 0 \n @retval 0 \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_DestroyRgn_ISP(chn: libc::c_int, handle: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn void IMP_OSD_Exit_ISP(void)\n\n ISPOSDIMP_System_Exit\n\n @param[in]\n\n @retval \n\n @remarks \n\n @attention "]
    pub fn IMP_OSD_Exit_ISP();
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default)]
pub struct IMP_IVS_BaseMoveParam {
    pub skipFrameCnt: libc::c_int,
    pub referenceNum: libc::c_int,
    pub sadMode: libc::c_int,
    pub sense: libc::c_int,
    #[doc = "< ,widthheight"]
    pub frameInfo: IMPFrameInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_BaseMoveParam"][::core::mem::size_of::<IMP_IVS_BaseMoveParam>() - 72usize];
    ["Alignment of IMP_IVS_BaseMoveParam"]
        [::core::mem::align_of::<IMP_IVS_BaseMoveParam>() - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::skipFrameCnt"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, skipFrameCnt) - 0usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::referenceNum"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, referenceNum) - 4usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::sadMode"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, sadMode) - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::sense"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, sense) - 12usize];
    ["Offset of field: IMP_IVS_BaseMoveParam::frameInfo"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveParam, frameInfo) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMP_IVS_BaseMoveOutput {
    pub ret: libc::c_int,
    pub data: *mut u8,
    pub datalen: libc::c_int,
    #[doc = "< "]
    pub timeStamp: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMP_IVS_BaseMoveOutput"][::core::mem::size_of::<IMP_IVS_BaseMoveOutput>() - 24usize];
    ["Alignment of IMP_IVS_BaseMoveOutput"]
        [::core::mem::align_of::<IMP_IVS_BaseMoveOutput>() - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::ret"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, ret) - 0usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::data"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, data) - 4usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::datalen"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, datalen) - 8usize];
    ["Offset of field: IMP_IVS_BaseMoveOutput::timeStamp"]
        [::core::mem::offset_of!(IMP_IVS_BaseMoveOutput, timeStamp) - 16usize];
};
impl Default for IMP_IVS_BaseMoveOutput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " \n\n @fn IMPIVSInterface *IMP_IVS_CreateBaseMoveInterface(IMP_IVS_BaseMoveParam *param);\n\n @param[in] param \n\n @retval NULL ,\n @retval NULL \n\n @attention "]
    pub fn IMP_IVS_CreateBaseMoveInterface(
        param: *mut IMP_IVS_BaseMoveParam,
    ) -> *mut IMPIVSInterface;
}
extern "C" {
    #[doc = " \n\n @fn void IMP_IVS_DestroyBaseMoveInterface(IMPIVSInterface *moveInterface);\n\n @param[in] moveInterface \n\n @retval \n\n @attention "]
    pub fn IMP_IVS_DestroyBaseMoveInterface(moveInterface: *mut IMPIVSInterface);
}
#[repr(u32)]
#[doc = " Channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderRcMode {
    #[doc = "< Fixqp "]
    ENC_RC_MODE_FIXQP = 0,
    #[doc = "< CBR "]
    ENC_RC_MODE_CBR = 1,
    #[doc = "< VBR "]
    ENC_RC_MODE_VBR = 2,
    #[doc = "< Smart "]
    ENC_RC_MODE_SMART = 3,
    #[doc = "< INV "]
    ENC_RC_MODE_INV = 4,
}
#[doc = " channel,frmRateNumfrmRateDen64"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderFrmRate {
    #[doc = "< , "]
    pub frmRateNum: u32,
    #[doc = "< , "]
    pub frmRateDen: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderFrmRate"][::core::mem::size_of::<IMPEncoderFrmRate>() - 8usize];
    ["Alignment of IMPEncoderFrmRate"][::core::mem::align_of::<IMPEncoderFrmRate>() - 4usize];
    ["Offset of field: IMPEncoderFrmRate::frmRateNum"]
        [::core::mem::offset_of!(IMPEncoderFrmRate, frmRateNum) - 0usize];
    ["Offset of field: IMPEncoderFrmRate::frmRateDen"]
        [::core::mem::offset_of!(IMPEncoderFrmRate, frmRateDen) - 4usize];
};
#[doc = " H.264Channel Fixqp"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264FixQP {
    #[doc = "< Qp"]
    pub qp: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264FixQP"][::core::mem::size_of::<IMPEncoderAttrH264FixQP>() - 4usize];
    ["Alignment of IMPEncoderAttrH264FixQP"]
        [::core::mem::align_of::<IMPEncoderAttrH264FixQP>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264FixQP::qp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264FixQP, qp) - 0usize];
};
#[doc = " H.264Channel CBR"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264CBR {
    #[doc = "< QP"]
    pub maxQp: u32,
    #[doc = "< QP"]
    pub minQp: u32,
    #[doc = "< ,kbps"]
    pub outBitRate: u32,
    #[doc = "< IQPI,:[-3,3]"]
    pub iBiasLvl: libc::c_int,
    #[doc = "< QP"]
    pub frmQPStep: u32,
    #[doc = "< GOPQP"]
    pub gopQPStep: u32,
    #[doc = "< "]
    pub adaptiveMode: bool,
    #[doc = "< GOP"]
    pub gopRelation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264CBR"][::core::mem::size_of::<IMPEncoderAttrH264CBR>() - 28usize];
    ["Alignment of IMPEncoderAttrH264CBR"]
        [::core::mem::align_of::<IMPEncoderAttrH264CBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264CBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH264CBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH264CBR::outBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, outBitRate) - 8usize];
    ["Offset of field: IMPEncoderAttrH264CBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, iBiasLvl) - 12usize];
    ["Offset of field: IMPEncoderAttrH264CBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, frmQPStep) - 16usize];
    ["Offset of field: IMPEncoderAttrH264CBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, gopQPStep) - 20usize];
    ["Offset of field: IMPEncoderAttrH264CBR::adaptiveMode"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, adaptiveMode) - 24usize];
    ["Offset of field: IMPEncoderAttrH264CBR::gopRelation"]
        [::core::mem::offset_of!(IMPEncoderAttrH264CBR, gopRelation) - 25usize];
};
#[doc = " H.264Channel VBR"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264VBR {
    #[doc = "< QP"]
    pub maxQp: u32,
    #[doc = "< QP"]
    pub minQp: u32,
    #[doc = "< ,"]
    pub staticTime: u32,
    #[doc = "< ,kbps"]
    pub maxBitRate: u32,
    #[doc = "< IQPI,:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "< VBR  Qp ,:[50, 100]"]
    pub changePos: u32,
    #[doc = "< , [0-7], , , minBitRate = maxBitRate * quality[qualityLvl], quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< QP"]
    pub frmQPStep: u32,
    #[doc = "< GOPQP"]
    pub gopQPStep: u32,
    #[doc = "< gop"]
    pub gopRelation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264VBR"][::core::mem::size_of::<IMPEncoderAttrH264VBR>() - 40usize];
    ["Alignment of IMPEncoderAttrH264VBR"]
        [::core::mem::align_of::<IMPEncoderAttrH264VBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264VBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH264VBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH264VBR::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH264VBR::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH264VBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH264VBR::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH264VBR::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH264VBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH264VBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH264VBR::gopRelation"]
        [::core::mem::offset_of!(IMPEncoderAttrH264VBR, gopRelation) - 36usize];
};
#[doc = " H.264Channel Smart"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH264Smart {
    #[doc = "< QP"]
    pub maxQp: u32,
    #[doc = "< QP"]
    pub minQp: u32,
    #[doc = "< ,"]
    pub staticTime: u32,
    #[doc = "< ,kbps"]
    pub maxBitRate: u32,
    #[doc = "< IQPI,:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "<  Qp ,:[50, 100]"]
    pub changePos: u32,
    #[doc = "< , [0-7], , . minBitRate = maxBitRate * quality[qualityLvl], quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< QP"]
    pub frmQPStep: u32,
    #[doc = "< gopQP"]
    pub gopQPStep: u32,
    #[doc = "< gop"]
    pub gopRelation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH264Smart"]
        [::core::mem::size_of::<IMPEncoderAttrH264Smart>() - 40usize];
    ["Alignment of IMPEncoderAttrH264Smart"]
        [::core::mem::align_of::<IMPEncoderAttrH264Smart>() - 4usize];
    ["Offset of field: IMPEncoderAttrH264Smart::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH264Smart::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH264Smart::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH264Smart::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH264Smart::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH264Smart::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH264Smart::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH264Smart::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH264Smart::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH264Smart::gopRelation"]
        [::core::mem::offset_of!(IMPEncoderAttrH264Smart, gopRelation) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265FixQP {
    #[doc = "< Qp"]
    pub qp: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265FixQP"][::core::mem::size_of::<IMPEncoderAttrH265FixQP>() - 4usize];
    ["Alignment of IMPEncoderAttrH265FixQP"]
        [::core::mem::align_of::<IMPEncoderAttrH265FixQP>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265FixQP::qp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265FixQP, qp) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265CBR {
    #[doc = "< QP"]
    pub maxQp: u32,
    #[doc = "< QP"]
    pub minQp: u32,
    #[doc = "< ,"]
    pub staticTime: u32,
    #[doc = "< ,kbps"]
    pub outBitRate: u32,
    #[doc = "< IQPI,:[-3,3]"]
    pub iBiasLvl: libc::c_int,
    #[doc = "< QP"]
    pub frmQPStep: u32,
    #[doc = "< GOPQP"]
    pub gopQPStep: u32,
    #[doc = "< ,:[0,4]"]
    pub flucLvl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265CBR"][::core::mem::size_of::<IMPEncoderAttrH265CBR>() - 32usize];
    ["Alignment of IMPEncoderAttrH265CBR"]
        [::core::mem::align_of::<IMPEncoderAttrH265CBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265CBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH265CBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH265CBR::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH265CBR::outBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, outBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH265CBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH265CBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, frmQPStep) - 20usize];
    ["Offset of field: IMPEncoderAttrH265CBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, gopQPStep) - 24usize];
    ["Offset of field: IMPEncoderAttrH265CBR::flucLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265CBR, flucLvl) - 28usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265VBR {
    #[doc = "< QP"]
    pub maxQp: u32,
    #[doc = "< QP"]
    pub minQp: u32,
    #[doc = "< ,"]
    pub staticTime: u32,
    #[doc = "< ,kbps"]
    pub maxBitRate: u32,
    #[doc = "< IQPI,:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "< VBR  Qp ,:[50, 100]"]
    pub changePos: u32,
    #[doc = "< , [0-7], , , minBitRate = maxBitRate * quality[qualityLvl], quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< QP"]
    pub frmQPStep: u32,
    #[doc = "< GOPQP"]
    pub gopQPStep: u32,
    #[doc = "< ,:[0,4]"]
    pub flucLvl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265VBR"][::core::mem::size_of::<IMPEncoderAttrH265VBR>() - 40usize];
    ["Alignment of IMPEncoderAttrH265VBR"]
        [::core::mem::align_of::<IMPEncoderAttrH265VBR>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265VBR::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH265VBR::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH265VBR::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH265VBR::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH265VBR::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH265VBR::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH265VBR::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH265VBR::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH265VBR::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH265VBR::flucLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265VBR, flucLvl) - 36usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrH265Smart {
    #[doc = "< QP"]
    pub maxQp: u32,
    #[doc = "< QP"]
    pub minQp: u32,
    #[doc = "< ,"]
    pub staticTime: u32,
    #[doc = "< ,kbps"]
    pub maxBitRate: u32,
    #[doc = "< IQPI,:[-3,3]"]
    pub iBiasLvl: i32,
    #[doc = "<  Qp ,:[50, 100]"]
    pub changePos: u32,
    #[doc = "< , [0-7], , . minBitRate = maxBitRate * quality[qualityLvl], quality[] = {0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1}"]
    pub qualityLvl: u32,
    #[doc = "< QP"]
    pub frmQPStep: u32,
    #[doc = "< gopQP"]
    pub gopQPStep: u32,
    #[doc = "< ,:[0,4]"]
    pub flucLvl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrH265Smart"]
        [::core::mem::size_of::<IMPEncoderAttrH265Smart>() - 40usize];
    ["Alignment of IMPEncoderAttrH265Smart"]
        [::core::mem::align_of::<IMPEncoderAttrH265Smart>() - 4usize];
    ["Offset of field: IMPEncoderAttrH265Smart::maxQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, maxQp) - 0usize];
    ["Offset of field: IMPEncoderAttrH265Smart::minQp"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, minQp) - 4usize];
    ["Offset of field: IMPEncoderAttrH265Smart::staticTime"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, staticTime) - 8usize];
    ["Offset of field: IMPEncoderAttrH265Smart::maxBitRate"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, maxBitRate) - 12usize];
    ["Offset of field: IMPEncoderAttrH265Smart::iBiasLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, iBiasLvl) - 16usize];
    ["Offset of field: IMPEncoderAttrH265Smart::changePos"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, changePos) - 20usize];
    ["Offset of field: IMPEncoderAttrH265Smart::qualityLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, qualityLvl) - 24usize];
    ["Offset of field: IMPEncoderAttrH265Smart::frmQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, frmQPStep) - 28usize];
    ["Offset of field: IMPEncoderAttrH265Smart::gopQPStep"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, gopQPStep) - 32usize];
    ["Offset of field: IMPEncoderAttrH265Smart::flucLvl"]
        [::core::mem::offset_of!(IMPEncoderAttrH265Smart, flucLvl) - 36usize];
};
#[doc = " H.264Channel,,;"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderAttrDenoise {
    #[doc = "< , 0:,1:,,2:I"]
    pub enable: bool,
    #[doc = "< ,0:,1:IP,2:I"]
    pub dnType: libc::c_int,
    #[doc = "< I"]
    pub dnIQp: libc::c_int,
    #[doc = "< P"]
    pub dnPQp: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrDenoise"][::core::mem::size_of::<IMPEncoderAttrDenoise>() - 16usize];
    ["Alignment of IMPEncoderAttrDenoise"]
        [::core::mem::align_of::<IMPEncoderAttrDenoise>() - 4usize];
    ["Offset of field: IMPEncoderAttrDenoise::enable"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, enable) - 0usize];
    ["Offset of field: IMPEncoderAttrDenoise::dnType"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, dnType) - 4usize];
    ["Offset of field: IMPEncoderAttrDenoise::dnIQp"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, dnIQp) - 8usize];
    ["Offset of field: IMPEncoderAttrDenoise::dnPQp"]
        [::core::mem::offset_of!(IMPEncoderAttrDenoise, dnPQp) - 12usize];
};
#[repr(u32)]
#[doc = " H.264Channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum EncFrmUsedMode {
    #[doc = "< -"]
    ENC_FRM_BYPASS = 0,
    #[doc = "< "]
    ENC_FRM_REUSED = 1,
    #[doc = "< "]
    ENC_FRM_SKIP = 2,
}
#[doc = " H.264Channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrFrmUsed {
    #[doc = "< "]
    pub enable: bool,
    #[doc = "< "]
    pub frmUsedMode: EncFrmUsedMode,
    #[doc = "< "]
    pub frmUsedTimes: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrFrmUsed"][::core::mem::size_of::<IMPEncoderAttrFrmUsed>() - 12usize];
    ["Alignment of IMPEncoderAttrFrmUsed"]
        [::core::mem::align_of::<IMPEncoderAttrFrmUsed>() - 4usize];
    ["Offset of field: IMPEncoderAttrFrmUsed::enable"]
        [::core::mem::offset_of!(IMPEncoderAttrFrmUsed, enable) - 0usize];
    ["Offset of field: IMPEncoderAttrFrmUsed::frmUsedMode"]
        [::core::mem::offset_of!(IMPEncoderAttrFrmUsed, frmUsedMode) - 4usize];
    ["Offset of field: IMPEncoderAttrFrmUsed::frmUsedTimes"]
        [::core::mem::offset_of!(IMPEncoderAttrFrmUsed, frmUsedTimes) - 8usize];
};
impl Default for IMPEncoderAttrFrmUsed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " H.264Channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPSkipType {
    #[doc = "< 1"]
    IMP_Encoder_STYPE_N1X = 0,
    #[doc = "< 2"]
    IMP_Encoder_STYPE_N2X = 1,
    #[doc = "< 4"]
    IMP_Encoder_STYPE_N4X = 2,
    #[doc = "< N1"]
    IMP_Encoder_STYPE_HN1_FALSE = 3,
    #[doc = "< N1"]
    IMP_Encoder_STYPE_HN1_TRUE = 4,
    #[doc = "< 1M"]
    IMP_Encoder_STYPE_H1M_FALSE = 5,
    #[doc = "< 1M"]
    IMP_Encoder_STYPE_H1M_TRUE = 6,
}
#[repr(u32)]
#[doc = " H.264Channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPRefType {
    #[doc = "< (IDR)"]
    IMP_Encoder_FSTYPE_IDR = 0,
    #[doc = "< (P)"]
    IMP_Encoder_FSTYPE_LBASE = 1,
    #[doc = "< (P)"]
    IMP_Encoder_FSTYPE_SBASE = 2,
    #[doc = "< (P)"]
    IMP_Encoder_FSTYPE_ENHANCE = 3,
}
#[doc = " H.264Channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrHSkip {
    #[doc = "< "]
    pub skipType: IMPSkipType,
    #[doc = "< "]
    pub m: libc::c_int,
    #[doc = "< "]
    pub n: libc::c_int,
    #[doc = "< gop,H1M Skip,0,m"]
    pub maxSameSceneCnt: libc::c_int,
    #[doc = "< ,H1M Skip"]
    pub bEnableScenecut: libc::c_int,
    #[doc = "< "]
    pub bBlackEnhance: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrHSkip"][::core::mem::size_of::<IMPEncoderAttrHSkip>() - 24usize];
    ["Alignment of IMPEncoderAttrHSkip"][::core::mem::align_of::<IMPEncoderAttrHSkip>() - 4usize];
    ["Offset of field: IMPEncoderAttrHSkip::skipType"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, skipType) - 0usize];
    ["Offset of field: IMPEncoderAttrHSkip::m"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, m) - 4usize];
    ["Offset of field: IMPEncoderAttrHSkip::n"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, n) - 8usize];
    ["Offset of field: IMPEncoderAttrHSkip::maxSameSceneCnt"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, maxSameSceneCnt) - 12usize];
    ["Offset of field: IMPEncoderAttrHSkip::bEnableScenecut"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, bEnableScenecut) - 16usize];
    ["Offset of field: IMPEncoderAttrHSkip::bBlackEnhance"]
        [::core::mem::offset_of!(IMPEncoderAttrHSkip, bBlackEnhance) - 20usize];
};
impl Default for IMPEncoderAttrHSkip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " H.264Channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrInitHSkip {
    #[doc = "< "]
    pub hSkipAttr: IMPEncoderAttrHSkip,
    #[doc = "< rmem, N1X  N2X 2, N4X  H1M_TRUE 3, "]
    pub maxHSkipType: IMPSkipType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrInitHSkip"]
        [::core::mem::size_of::<IMPEncoderAttrInitHSkip>() - 28usize];
    ["Alignment of IMPEncoderAttrInitHSkip"]
        [::core::mem::align_of::<IMPEncoderAttrInitHSkip>() - 4usize];
    ["Offset of field: IMPEncoderAttrInitHSkip::hSkipAttr"]
        [::core::mem::offset_of!(IMPEncoderAttrInitHSkip, hSkipAttr) - 0usize];
    ["Offset of field: IMPEncoderAttrInitHSkip::maxHSkipType"]
        [::core::mem::offset_of!(IMPEncoderAttrInitHSkip, maxHSkipType) - 24usize];
};
impl Default for IMPEncoderAttrInitHSkip {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " H.264Channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderAttrRcMode {
    #[doc = "< RC "]
    pub rcMode: IMPEncoderRcMode,
    pub __anon1: IMPEncoderAttrRcMode__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderAttrRcMode__bindgen_ty_1 {
    #[doc = "< H.264 Channel Fixqp "]
    pub attrH264FixQp: IMPEncoderAttrH264FixQP,
    #[doc = "< H.264 Channel Cbr "]
    pub attrH264Cbr: IMPEncoderAttrH264CBR,
    #[doc = "< H.264 Channel Vbr "]
    pub attrH264Vbr: IMPEncoderAttrH264VBR,
    #[doc = "< H.264 Channel Smart "]
    pub attrH264Smart: IMPEncoderAttrH264Smart,
    #[doc = "<  H.265"]
    pub attrH265FixQp: IMPEncoderAttrH265FixQP,
    #[doc = "<  H.265"]
    pub attrH265Cbr: IMPEncoderAttrH265CBR,
    #[doc = "<  H.265"]
    pub attrH265Vbr: IMPEncoderAttrH265VBR,
    #[doc = "<  H.265"]
    pub attrH265Smart: IMPEncoderAttrH265Smart,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrRcMode__bindgen_ty_1"]
        [::core::mem::size_of::<IMPEncoderAttrRcMode__bindgen_ty_1>() - 40usize];
    ["Alignment of IMPEncoderAttrRcMode__bindgen_ty_1"]
        [::core::mem::align_of::<IMPEncoderAttrRcMode__bindgen_ty_1>() - 4usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264FixQp"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264FixQp) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264Cbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264Cbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264Vbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264Vbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH264Smart"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH264Smart) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265FixQp"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265FixQp) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265Cbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265Cbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265Vbr"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265Vbr) - 0usize];
    ["Offset of field: IMPEncoderAttrRcMode__bindgen_ty_1::attrH265Smart"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode__bindgen_ty_1, attrH265Smart) - 0usize];
};
impl Default for IMPEncoderAttrRcMode__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttrRcMode"][::core::mem::size_of::<IMPEncoderAttrRcMode>() - 44usize];
    ["Alignment of IMPEncoderAttrRcMode"][::core::mem::align_of::<IMPEncoderAttrRcMode>() - 4usize];
    ["Offset of field: IMPEncoderAttrRcMode::rcMode"]
        [::core::mem::offset_of!(IMPEncoderAttrRcMode, rcMode) - 0usize];
};
impl Default for IMPEncoderAttrRcMode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " H.264Channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderRcAttr {
    #[doc = "< Channel"]
    pub outFrmRate: IMPEncoderFrmRate,
    #[doc = "< gop"]
    pub maxGop: u32,
    #[doc = "< "]
    pub attrRcMode: IMPEncoderAttrRcMode,
    #[doc = "< "]
    pub attrFrmUsed: IMPEncoderAttrFrmUsed,
    #[doc = "< "]
    pub attrDenoise: IMPEncoderAttrDenoise,
    #[doc = "< "]
    pub attrHSkip: IMPEncoderAttrInitHSkip,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderRcAttr"][::core::mem::size_of::<IMPEncoderRcAttr>() - 112usize];
    ["Alignment of IMPEncoderRcAttr"][::core::mem::align_of::<IMPEncoderRcAttr>() - 4usize];
    ["Offset of field: IMPEncoderRcAttr::outFrmRate"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, outFrmRate) - 0usize];
    ["Offset of field: IMPEncoderRcAttr::maxGop"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, maxGop) - 8usize];
    ["Offset of field: IMPEncoderRcAttr::attrRcMode"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrRcMode) - 12usize];
    ["Offset of field: IMPEncoderRcAttr::attrFrmUsed"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrFrmUsed) - 56usize];
    ["Offset of field: IMPEncoderRcAttr::attrDenoise"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrDenoise) - 68usize];
    ["Offset of field: IMPEncoderRcAttr::attrHSkip"]
        [::core::mem::offset_of!(IMPEncoderRcAttr, attrHSkip) - 84usize];
};
impl Default for IMPEncoderRcAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " H.264NALU"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderH264NaluType {
    #[doc = "< "]
    IMP_H264_NAL_UNKNOWN = 0,
    #[doc = "< IDR"]
    IMP_H264_NAL_SLICE = 1,
    #[doc = "< A"]
    IMP_H264_NAL_SLICE_DPA = 2,
    #[doc = "< B"]
    IMP_H264_NAL_SLICE_DPB = 3,
    #[doc = "< C"]
    IMP_H264_NAL_SLICE_DPC = 4,
    #[doc = "< IDR"]
    IMP_H264_NAL_SLICE_IDR = 5,
    #[doc = "<  (SEI)"]
    IMP_H264_NAL_SEI = 6,
    #[doc = "< "]
    IMP_H264_NAL_SPS = 7,
    #[doc = "< "]
    IMP_H264_NAL_PPS = 8,
    #[doc = "< "]
    IMP_H264_NAL_AUD = 9,
    #[doc = "< "]
    IMP_H264_NAL_FILLER = 12,
}
#[repr(u32)]
#[doc = " H.265NALU"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderH265NaluType {
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_TRAIL_N = 0,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_TRAIL_R = 1,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_TSA_N = 2,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_TSA_R = 3,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_STSA_N = 4,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_STSA_R = 5,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_RADL_N = 6,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_RADL_R = 7,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_RASL_N = 8,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_RASL_R = 9,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_BLA_W_LP = 16,
    #[doc = "< , RADL"]
    IMP_H265_NAL_SLICE_BLA_W_RADL = 17,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_BLA_N_LP = 18,
    #[doc = "< , RADL"]
    IMP_H265_NAL_SLICE_IDR_W_RADL = 19,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_IDR_N_LP = 20,
    #[doc = "< , "]
    IMP_H265_NAL_SLICE_CRA = 21,
    #[doc = "< "]
    IMP_H265_NAL_VPS = 32,
    #[doc = "< "]
    IMP_H265_NAL_SPS = 33,
    #[doc = "< "]
    IMP_H265_NAL_PPS = 34,
    #[doc = "< "]
    IMP_H265_NAL_AUD = 35,
    #[doc = "< "]
    IMP_H265_NAL_EOS = 36,
    #[doc = "< "]
    IMP_H265_NAL_EOB = 37,
    #[doc = "< "]
    IMP_H265_NAL_FILLER_DATA = 38,
    #[doc = "<  (SEI)"]
    IMP_H265_NAL_PREFIX_SEI = 39,
    #[doc = "<  (SEI)"]
    IMP_H265_NAL_SUFFIX_SEI = 40,
    #[doc = "< NAL"]
    IMP_H265_NAL_INVALID = 64,
}
#[doc = " H.264ChannelNAL"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderDataType {
    #[doc = "< H264E NALU "]
    pub h264Type: IMPEncoderH264NaluType,
    #[doc = "< H265E NALU , H265"]
    pub h265Type: IMPEncoderH265NaluType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderDataType"][::core::mem::size_of::<IMPEncoderDataType>() - 4usize];
    ["Alignment of IMPEncoderDataType"][::core::mem::align_of::<IMPEncoderDataType>() - 4usize];
    ["Offset of field: IMPEncoderDataType::h264Type"]
        [::core::mem::offset_of!(IMPEncoderDataType, h264Type) - 0usize];
    ["Offset of field: IMPEncoderDataType::h265Type"]
        [::core::mem::offset_of!(IMPEncoderDataType, h265Type) - 0usize];
};
impl Default for IMPEncoderDataType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderPack {
    #[doc = "< "]
    pub phyAddr: u32,
    #[doc = "< "]
    pub virAddr: u32,
    #[doc = "< "]
    pub length: u32,
    #[doc = "< us"]
    pub timestamp: i64,
    #[doc = "< "]
    pub frameEnd: bool,
    #[doc = "< H.264ChannelNAL"]
    pub dataType: IMPEncoderDataType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderPack"][::core::mem::size_of::<IMPEncoderPack>() - 32usize];
    ["Alignment of IMPEncoderPack"][::core::mem::align_of::<IMPEncoderPack>() - 8usize];
    ["Offset of field: IMPEncoderPack::phyAddr"]
        [::core::mem::offset_of!(IMPEncoderPack, phyAddr) - 0usize];
    ["Offset of field: IMPEncoderPack::virAddr"]
        [::core::mem::offset_of!(IMPEncoderPack, virAddr) - 4usize];
    ["Offset of field: IMPEncoderPack::length"]
        [::core::mem::offset_of!(IMPEncoderPack, length) - 8usize];
    ["Offset of field: IMPEncoderPack::timestamp"]
        [::core::mem::offset_of!(IMPEncoderPack, timestamp) - 16usize];
    ["Offset of field: IMPEncoderPack::frameEnd"]
        [::core::mem::offset_of!(IMPEncoderPack, frameEnd) - 24usize];
    ["Offset of field: IMPEncoderPack::dataType"]
        [::core::mem::offset_of!(IMPEncoderPack, dataType) - 28usize];
};
impl Default for IMPEncoderPack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderStream {
    #[doc = "< "]
    pub pack: *mut IMPEncoderPack,
    #[doc = "< "]
    pub packCount: u32,
    #[doc = "< "]
    pub seq: u32,
    #[doc = "< , H264"]
    pub refType: IMPRefType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderStream"][::core::mem::size_of::<IMPEncoderStream>() - 16usize];
    ["Alignment of IMPEncoderStream"][::core::mem::align_of::<IMPEncoderStream>() - 4usize];
    ["Offset of field: IMPEncoderStream::pack"]
        [::core::mem::offset_of!(IMPEncoderStream, pack) - 0usize];
    ["Offset of field: IMPEncoderStream::packCount"]
        [::core::mem::offset_of!(IMPEncoderStream, packCount) - 4usize];
    ["Offset of field: IMPEncoderStream::seq"]
        [::core::mem::offset_of!(IMPEncoderStream, seq) - 8usize];
    ["Offset of field: IMPEncoderStream::refType"]
        [::core::mem::offset_of!(IMPEncoderStream, refType) - 12usize];
};
impl Default for IMPEncoderStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderCropCfg {
    #[doc = "< ,:[FALSE, TRUE],TRUE:,FALSE:"]
    pub enable: bool,
    #[doc = "< ,x"]
    pub x: u32,
    #[doc = "< ,y"]
    pub y: u32,
    #[doc = "< ,"]
    pub w: u32,
    #[doc = "< ,"]
    pub h: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderCropCfg"][::core::mem::size_of::<IMPEncoderCropCfg>() - 20usize];
    ["Alignment of IMPEncoderCropCfg"][::core::mem::align_of::<IMPEncoderCropCfg>() - 4usize];
    ["Offset of field: IMPEncoderCropCfg::enable"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, enable) - 0usize];
    ["Offset of field: IMPEncoderCropCfg::x"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, x) - 4usize];
    ["Offset of field: IMPEncoderCropCfg::y"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, y) - 8usize];
    ["Offset of field: IMPEncoderCropCfg::w"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, w) - 12usize];
    ["Offset of field: IMPEncoderCropCfg::h"]
        [::core::mem::offset_of!(IMPEncoderCropCfg, h) - 16usize];
};
#[doc = " ,H264"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderUserDataCfg {
    #[doc = "< ,0-2"]
    pub maxUserDataCnt: u32,
    #[doc = "< ,16-1024"]
    pub maxUserDataSize: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderUserDataCfg"][::core::mem::size_of::<IMPEncoderUserDataCfg>() - 8usize];
    ["Alignment of IMPEncoderUserDataCfg"]
        [::core::mem::align_of::<IMPEncoderUserDataCfg>() - 4usize];
    ["Offset of field: IMPEncoderUserDataCfg::maxUserDataCnt"]
        [::core::mem::offset_of!(IMPEncoderUserDataCfg, maxUserDataCnt) - 0usize];
    ["Offset of field: IMPEncoderUserDataCfg::maxUserDataSize"]
        [::core::mem::offset_of!(IMPEncoderUserDataCfg, maxUserDataSize) - 4usize];
};
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttr {
    #[doc = "< "]
    pub enType: IMPPayloadType,
    #[doc = "<  buffer :1.50IMP"]
    pub bufSize: u32,
    #[doc = "< , 0: baseline; 1:MP; 2:HP"]
    pub profile: u32,
    #[doc = "< "]
    pub picWidth: u32,
    #[doc = "< "]
    pub picHeight: u32,
    #[doc = "< "]
    pub crop: IMPEncoderCropCfg,
    #[doc = "< ,H264"]
    pub userData: IMPEncoderUserDataCfg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderAttr"][::core::mem::size_of::<IMPEncoderAttr>() - 48usize];
    ["Alignment of IMPEncoderAttr"][::core::mem::align_of::<IMPEncoderAttr>() - 4usize];
    ["Offset of field: IMPEncoderAttr::enType"]
        [::core::mem::offset_of!(IMPEncoderAttr, enType) - 0usize];
    ["Offset of field: IMPEncoderAttr::bufSize"]
        [::core::mem::offset_of!(IMPEncoderAttr, bufSize) - 4usize];
    ["Offset of field: IMPEncoderAttr::profile"]
        [::core::mem::offset_of!(IMPEncoderAttr, profile) - 8usize];
    ["Offset of field: IMPEncoderAttr::picWidth"]
        [::core::mem::offset_of!(IMPEncoderAttr, picWidth) - 12usize];
    ["Offset of field: IMPEncoderAttr::picHeight"]
        [::core::mem::offset_of!(IMPEncoderAttr, picHeight) - 16usize];
    ["Offset of field: IMPEncoderAttr::crop"]
        [::core::mem::offset_of!(IMPEncoderAttr, crop) - 20usize];
    ["Offset of field: IMPEncoderAttr::userData"]
        [::core::mem::offset_of!(IMPEncoderAttr, userData) - 40usize];
};
impl Default for IMPEncoderAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderCHNAttr {
    #[doc = "< "]
    pub encAttr: IMPEncoderAttr,
    #[doc = "< ,H264"]
    pub rcAttr: IMPEncoderRcAttr,
    #[doc = "< ISP VPU Direct Connect"]
    pub bEnableIvdc: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderCHNAttr"][::core::mem::size_of::<IMPEncoderCHNAttr>() - 164usize];
    ["Alignment of IMPEncoderCHNAttr"][::core::mem::align_of::<IMPEncoderCHNAttr>() - 4usize];
    ["Offset of field: IMPEncoderCHNAttr::encAttr"]
        [::core::mem::offset_of!(IMPEncoderCHNAttr, encAttr) - 0usize];
    ["Offset of field: IMPEncoderCHNAttr::rcAttr"]
        [::core::mem::offset_of!(IMPEncoderCHNAttr, rcAttr) - 48usize];
    ["Offset of field: IMPEncoderCHNAttr::bEnableIvdc"]
        [::core::mem::offset_of!(IMPEncoderCHNAttr, bEnableIvdc) - 160usize];
};
impl Default for IMPEncoderCHNAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Channel"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderCHNStat {
    #[doc = "< Group:{TRUE, FALSE}TRUE:FALSE:"]
    pub registered: bool,
    #[doc = "< "]
    pub leftPics: u32,
    #[doc = "< bufferbyte"]
    pub leftStreamBytes: u32,
    #[doc = "< buffer"]
    pub leftStreamFrames: u32,
    #[doc = "< "]
    pub curPacks: u32,
    #[doc = "< 01"]
    pub work_done: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderCHNStat"][::core::mem::size_of::<IMPEncoderCHNStat>() - 24usize];
    ["Alignment of IMPEncoderCHNStat"][::core::mem::align_of::<IMPEncoderCHNStat>() - 4usize];
    ["Offset of field: IMPEncoderCHNStat::registered"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, registered) - 0usize];
    ["Offset of field: IMPEncoderCHNStat::leftPics"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, leftPics) - 4usize];
    ["Offset of field: IMPEncoderCHNStat::leftStreamBytes"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, leftStreamBytes) - 8usize];
    ["Offset of field: IMPEncoderCHNStat::leftStreamFrames"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, leftStreamFrames) - 12usize];
    ["Offset of field: IMPEncoderCHNStat::curPacks"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, curPacks) - 16usize];
    ["Offset of field: IMPEncoderCHNStat::work_done"]
        [::core::mem::offset_of!(IMPEncoderCHNStat, work_done) - 20usize];
};
#[doc = " (C2G)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderColor2GreyCfg {
    #[doc = "< "]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderColor2GreyCfg"][::core::mem::size_of::<IMPEncoderColor2GreyCfg>() - 1usize];
    ["Alignment of IMPEncoderColor2GreyCfg"]
        [::core::mem::align_of::<IMPEncoderColor2GreyCfg>() - 1usize];
    ["Offset of field: IMPEncoderColor2GreyCfg::enable"]
        [::core::mem::offset_of!(IMPEncoderColor2GreyCfg, enable) - 0usize];
};
#[doc = " H.264ChannelEnableIDR"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderEnIDRCfg {
    #[doc = "< EnableIDR"]
    pub enable: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderEnIDRCfg"][::core::mem::size_of::<IMPEncoderEnIDRCfg>() - 1usize];
    ["Alignment of IMPEncoderEnIDRCfg"][::core::mem::align_of::<IMPEncoderEnIDRCfg>() - 1usize];
    ["Offset of field: IMPEncoderEnIDRCfg::enable"]
        [::core::mem::offset_of!(IMPEncoderEnIDRCfg, enable) - 0usize];
};
#[doc = " H.264Channelgopsize"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderGOPSizeCfg {
    #[doc = "< IDR"]
    pub gopsize: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderGOPSizeCfg"][::core::mem::size_of::<IMPEncoderGOPSizeCfg>() - 4usize];
    ["Alignment of IMPEncoderGOPSizeCfg"][::core::mem::align_of::<IMPEncoderGOPSizeCfg>() - 4usize];
    ["Offset of field: IMPEncoderGOPSizeCfg::gopsize"]
        [::core::mem::offset_of!(IMPEncoderGOPSizeCfg, gopsize) - 0usize];
};
#[doc = " H.264ChannelROI"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderROICfg {
    #[doc = "< ROI0-7"]
    pub u32Index: u32,
    #[doc = "< ROI"]
    pub bEnable: bool,
    #[doc = "< 0ROI1ROI"]
    pub bRelatedQp: bool,
    #[doc = "< ROIqp"]
    pub s32Qp: libc::c_int,
    #[doc = "< "]
    pub rect: IMPRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderROICfg"][::core::mem::size_of::<IMPEncoderROICfg>() - 28usize];
    ["Alignment of IMPEncoderROICfg"][::core::mem::align_of::<IMPEncoderROICfg>() - 4usize];
    ["Offset of field: IMPEncoderROICfg::u32Index"]
        [::core::mem::offset_of!(IMPEncoderROICfg, u32Index) - 0usize];
    ["Offset of field: IMPEncoderROICfg::bEnable"]
        [::core::mem::offset_of!(IMPEncoderROICfg, bEnable) - 4usize];
    ["Offset of field: IMPEncoderROICfg::bRelatedQp"]
        [::core::mem::offset_of!(IMPEncoderROICfg, bRelatedQp) - 5usize];
    ["Offset of field: IMPEncoderROICfg::s32Qp"]
        [::core::mem::offset_of!(IMPEncoderROICfg, s32Qp) - 8usize];
    ["Offset of field: IMPEncoderROICfg::rect"]
        [::core::mem::offset_of!(IMPEncoderROICfg, rect) - 12usize];
};
#[repr(u32)]
#[doc = " H.264Channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderSuperFrmMode {
    #[doc = "< , "]
    IMP_RC_SUPERFRM_NONE = 0,
    #[doc = "< , , "]
    IMP_RC_SUPERFRM_DISCARD = 1,
    #[doc = "< , "]
    IMP_RC_SUPERFRM_REENCODE = 2,
    IMP_RC_SUPERFRM_BUTT = 3,
}
#[repr(u32)]
#[doc = " H.264Channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderRcPriority {
    #[doc = "< "]
    IMP_RC_PRIORITY_RDO = 0,
    #[doc = "< "]
    IMP_RC_PRIORITY_BITRATE_FIRST = 1,
    #[doc = "< "]
    IMP_RC_PRIORITY_FRAMEBITS_FIRST = 2,
    IMP_RC_PRIORITY_BUTT = 3,
}
#[doc = " H.264Channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderSuperFrmCfg {
    #[doc = "< , SUPERFRM_REENCODE"]
    pub superFrmMode: IMPEncoderSuperFrmMode,
    #[doc = "< I , w*h*3/2*8/ratio, ratio: 6, 3"]
    pub superIFrmBitsThr: u32,
    #[doc = "< P , I1.4"]
    pub superPFrmBitsThr: u32,
    #[doc = "< B , P1.3, B"]
    pub superBFrmBitsThr: u32,
    #[doc = "< ,  IMP_RC_PRIORITY_RDO"]
    pub rcPriority: IMPEncoderRcPriority,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderSuperFrmCfg"][::core::mem::size_of::<IMPEncoderSuperFrmCfg>() - 20usize];
    ["Alignment of IMPEncoderSuperFrmCfg"]
        [::core::mem::align_of::<IMPEncoderSuperFrmCfg>() - 4usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superFrmMode"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superFrmMode) - 0usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superIFrmBitsThr"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superIFrmBitsThr) - 4usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superPFrmBitsThr"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superPFrmBitsThr) - 8usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::superBFrmBitsThr"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, superBFrmBitsThr) - 12usize];
    ["Offset of field: IMPEncoderSuperFrmCfg::rcPriority"]
        [::core::mem::offset_of!(IMPEncoderSuperFrmCfg, rcPriority) - 16usize];
};
impl Default for IMPEncoderSuperFrmCfg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  H.264 "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderH264TransCfg {
    #[doc = "<  H.264 ,  0; :[-12, 12]"]
    pub chroma_qp_index_offset: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderH264TransCfg"][::core::mem::size_of::<IMPEncoderH264TransCfg>() - 4usize];
    ["Alignment of IMPEncoderH264TransCfg"]
        [::core::mem::align_of::<IMPEncoderH264TransCfg>() - 4usize];
    ["Offset of field: IMPEncoderH264TransCfg::chroma_qp_index_offset"]
        [::core::mem::offset_of!(IMPEncoderH264TransCfg, chroma_qp_index_offset) - 0usize];
};
#[doc = "  H.265 "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPEncoderH265TransCfg {
    #[doc = "< H.265"]
    pub chroma_cr_qp_offset: libc::c_int,
    #[doc = "< H.265"]
    pub chroma_cb_qp_offset: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderH265TransCfg"][::core::mem::size_of::<IMPEncoderH265TransCfg>() - 8usize];
    ["Alignment of IMPEncoderH265TransCfg"]
        [::core::mem::align_of::<IMPEncoderH265TransCfg>() - 4usize];
    ["Offset of field: IMPEncoderH265TransCfg::chroma_cr_qp_offset"]
        [::core::mem::offset_of!(IMPEncoderH265TransCfg, chroma_cr_qp_offset) - 0usize];
    ["Offset of field: IMPEncoderH265TransCfg::chroma_cb_qp_offset"]
        [::core::mem::offset_of!(IMPEncoderH265TransCfg, chroma_cb_qp_offset) - 4usize];
};
#[repr(u32)]
#[doc = " , H2641-4"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPEncoderQpgMode {
    #[doc = "< "]
    ENC_QPG_CLOSE = 0,
    #[doc = "< CRP()"]
    ENC_QPG_CRP = 1,
    #[doc = "< SAS"]
    ENC_QPG_SAS = 2,
    #[doc = "< SAS"]
    ENC_QPG_SASM = 3,
    #[doc = "< "]
    ENC_QPG_MBRC = 4,
    #[doc = "< CRPQP_TAB"]
    ENC_QPG_CRP_TAB = 5,
    #[doc = "< SASQP_TAB"]
    ENC_QPG_SAS_TAB = 6,
    #[doc = "< SASQP_TAB"]
    ENC_QPG_SASM_TAB = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderJpegeQl {
    #[doc = "< 0: ; 1:"]
    pub user_ql_en: bool,
    #[doc = "< "]
    pub qmem_table: [u8; 128usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPEncoderJpegeQl"][::core::mem::size_of::<IMPEncoderJpegeQl>() - 129usize];
    ["Alignment of IMPEncoderJpegeQl"][::core::mem::align_of::<IMPEncoderJpegeQl>() - 1usize];
    ["Offset of field: IMPEncoderJpegeQl::user_ql_en"]
        [::core::mem::offset_of!(IMPEncoderJpegeQl, user_ql_en) - 0usize];
    ["Offset of field: IMPEncoderJpegeQl::qmem_table"]
        [::core::mem::offset_of!(IMPEncoderJpegeQl, qmem_table) - 1usize];
};
impl Default for IMPEncoderJpegeQl {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_CreateGroup(int encGroup)\n\n Group\n\n @param[in] encGroup Group,:[0, @ref NR_MAX_ENC_GROUPS - 1]\n\n @retval 0 \n @retval 0 \n\n @remark GroupGroupGroup2channel\n\n @attention Group"]
    pub fn IMP_Encoder_CreateGroup(encGroup: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_DestroyGroup(int encGroup)\n\n Grouop.\n\n @param[in] encGroup Group,:[0, @ref NR_MAX_ENC_GROUPS - 1]\n\n @retval 0 \n @retval 0 \n\n @remark GroupGroupChannelGroupGroupChannel\n\n @attention Group"]
    pub fn IMP_Encoder_DestroyGroup(encGroup: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_CreateChn(int encChn, const IMPEncoderCHNAttr *attr)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] attr Channel\n\n @retval 0 \n @retval 0 \n\n @remark Channel\n @remark "]
    pub fn IMP_Encoder_CreateChn(
        encChn: libc::c_int,
        attr: *const IMPEncoderCHNAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_DestroyChn(int encChn)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @attention Channel\n @attention ChannelGroup"]
    pub fn IMP_Encoder_DestroyChn(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnAttr(int encChn, IMPEncoderCHNAttr * const attr)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] attr Channel\n\n @retval 0 \n @retval 0 "]
    pub fn IMP_Encoder_GetChnAttr(encChn: libc::c_int, attr: *mut IMPEncoderCHNAttr)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_RegisterChn(int encGroup, int encChn)\n\n ChannelGroup\n\n @param[in] encGroup Group,: [0, @ref NR_MAX_ENC_GROUPS - 1]\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @attention Channel\n @attention ChannelGroup\n @attention ChannelGroupChannelGroup\n @attention GroupGroupChannel"]
    pub fn IMP_Encoder_RegisterChn(encGroup: libc::c_int, encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_UnRegisterChn(int encChn)\n\n ChannelGroup\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark ChannelChannelChannelbufferbufferbuffer\n @remark IMP_Encoder_QueryChannelbufferbufferChannel\n\n @attention Channel\n @attention Channel\n @attention Channel"]
    pub fn IMP_Encoder_UnRegisterChn(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_StartRecvPic(int encChn)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark Channel\n\n @attention Channel\n @attention ChannelGroup"]
    pub fn IMP_Encoder_StartRecvPic(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_StopRecvPic(int encChn)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark \n @remark buffer\n\n @attention Channel\n @attention ChannelGroup"]
    pub fn IMP_Encoder_StopRecvPic(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_Query(int encChn, IMPEncoderCHNStat *stat)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] stat Channel\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_Encoder_Query(encChn: libc::c_int, stat: *mut IMPEncoderCHNStat) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetStream(int encChn, IMPEncoderStream *stream, bool blockFlag)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] stream \n @param[in] blockFlag 01\n\n @retval 0 \n @retval 0 \n\n @remark \n @remark ,Channel, \\n\n ,,,   \\n\n ,,,   \\n\n  buffer ,\n @remark H264\n @remark JPEGJPEG\n\n \n @code\n int ret;\n ret = IMP_Encoder_PollingStream(ENC_H264_CHANNEL, 1000); //PollingBuffer\n if (ret < 0) {\n     printf(\"Polling stream timeout\\n\");\n     return -1;\n }\n\n IMPEncoderStream stream;\n ret = IMP_Encoder_GetStream(ENC_H264_CHANNEL, &stream, 1); //\n if (ret < 0) {\n     printf(\"Get Stream failed\\n\");\n     return -1;\n }\n\n int i, nr_pack = stream.packCount;\n for (i = 0; i < nr_pack; i++) { //\n     ret = write(stream_fd, (void *)stream.pack[i].virAddr,\n                stream.pack[i].length);\n     if (ret != stream.pack[i].length) {\n         printf(\"stream write error:%s\\n\", strerror(errno));\n         return -1;\n     }\n }\n @endcode\n\n @attention pstStreamNULL,\n @attention Channel"]
    pub fn IMP_Encoder_GetStream(
        encChn: libc::c_int,
        stream: *mut IMPEncoderStream,
        blockFlag: bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_ReleaseStream(int encChn, IMPEncoderStream *stream)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] stream \n\n @retval 0 \n @retval 0 \n\n @remark IMP_Encoder_GetStream\\n\n buffer\\n\n \n @remark Channel\n\n @attention pstStreamNULL,\n @attention Channel\n @attention "]
    pub fn IMP_Encoder_ReleaseStream(
        encChn: libc::c_int,
        stream: *mut IMPEncoderStream,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_PollingStream(int encChn, uint32_t timeoutMsec)\n\n Polling\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] timeoutMsec \n\n @retval 0 \n @retval 0 \n\n @remark APIPolling\n\n @attention "]
    pub fn IMP_Encoder_PollingStream(encChn: libc::c_int, timeoutMsec: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetFd(int encChn)\n\n Channel\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval >=0 , \n @retval < 0 \n\n @remark IMP_Encoder_PollingStreamPollingchannel, \\n\n select, poll\n @remark API\n\n @attention "]
    pub fn IMP_Encoder_GetFd(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetMaxStreamCnt(int encChn, int nrMaxStream)\n\n Buffer\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] nrMaxStream Buffer,: [1, @ref NR_MAX_ENC_CHN_STREAM]\n\n @retval 0 \n @retval 0 \n\n @remark BufferAPI\n @remark APIBufferSDKbuffer\n\n @attention "]
    pub fn IMP_Encoder_SetMaxStreamCnt(
        encChn: libc::c_int,
        nrMaxStream: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetMaxStreamCnt(int encChn, int *nrMaxStream)\n\n Buffer\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] nrMaxStream Buffer\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_Encoder_GetMaxStreamCnt(
        encChn: libc::c_int,
        nrMaxStream: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_RequestIDR(int encChn)\n\n IDR\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark APIIDR\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_RequestIDR(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_FlushStream(int encChn)\n\n IDR\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark APIIDR\n\n @attention "]
    pub fn IMP_Encoder_FlushStream(encChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnColor2Grey(int encChn, const IMPEncoderColor2GreyCfg *pstColor2Grey).\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstColor2Grey \n\n @retval 0 \n @retval 0 \n\n @remark APIIDRP\n @remark API\n\n @attention "]
    pub fn IMP_Encoder_SetChnColor2Grey(
        encChn: libc::c_int,
        pstColor2Grey: *const IMPEncoderColor2GreyCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnColor2Grey(int encChn, IMPEncoderColor2GreyCfg *pstColor2Grey).\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstColor2Grey \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnColor2Grey(
        encChn: libc::c_int,
        pstColor2Grey: *mut IMPEncoderColor2GreyCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnAttrRcMode(int encChn, const IMPEncoderAttrRcMode *pstRcModeCfg).\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstRcCfg \n\n @retval 0 \n @retval 0 \n\n @remark APIIDR,API\n\n @attention ENC_RC_MODE_FIXQP, ENC_RC_MODE_CBR, ENC_RC_MODE_VBR  ENC_RC_MODE_SMART\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnAttrRcMode(
        encChn: libc::c_int,
        pstRcModeCfg: *const IMPEncoderAttrRcMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnAttrRcMode(int encChn, IMPEncoderAttrRcMode *pstRcModeCfg).\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstRcCfg \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnAttrRcMode(
        encChn: libc::c_int,
        pstRcModeCfg: *mut IMPEncoderAttrRcMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnFrmRate(int encChn, const IMPEncoderFrmRate *pstFps)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg \n\n @retval 0 \n @retval 0 \n\n @remark APIGOP1API\n @remark IMP_FrameSource_SetChnFPS()\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnFrmRate(
        encChn: libc::c_int,
        pstFps: *const IMPEncoderFrmRate,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnFrmRate(int encChn, IMPEncoderFrmRate *pstFps)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnFrmRate(
        encChn: libc::c_int,
        pstFps: *mut IMPEncoderFrmRate,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnROI(int encChn, const IMPEncoderROICfg *pstVencRoiCfg)\n\n ROI\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg ROI\n\n @retval 0 \n @retval 0 \n\n @remark APIROIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnROI(
        encChn: libc::c_int,
        pstVencRoiCfg: *const IMPEncoderROICfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnROI(int encChn, IMPEncoderROICfg *pstVencRoiCfg)\n\n ROI\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstFpsCfg ROI\n\n @retval 0 \n @retval 0 \n\n @remark APIROIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnROI(
        encChn: libc::c_int,
        pstVencRoiCfg: *mut IMPEncoderROICfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetGOPSize(int encChn, IMPEncoderGOPSizeCfg *pstGOPSizeCfg)\n\n GOP\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstGOPSizeCfg GOPSize\n\n @retval 0 \n @retval 0 \n\n @remark APIGOPSizeAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetGOPSize(
        encChn: libc::c_int,
        pstGOPSizeCfg: *mut IMPEncoderGOPSizeCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetGOPSize(int encChn, const IMPEncoderGOPSizeCfg *pstGOPSizeCfg)\n\n GOP\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstGOPSizeCfg GOP\n\n @retval 0 \n @retval 0 \n\n @remark APIGOPSizeAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetGOPSize(
        encChn: libc::c_int,
        pstGOPSizeCfg: *const IMPEncoderGOPSizeCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnFrmUsedMode(int encChn, const IMPEncoderAttrFrmUsed *pfrmUsedAttr)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pfrmUsedAttr \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnFrmUsedMode(
        encChn: libc::c_int,
        pfrmUsedAttr: *const IMPEncoderAttrFrmUsed,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnFrmUsedMode(int encChn, IMPEncoderAttrFrmUsed *pfrmUsedAttr)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pfrmUsedAttr \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnFrmUsedMode(
        encChn: libc::c_int,
        pfrmUsedAttr: *mut IMPEncoderAttrFrmUsed,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnDenoise(int encChn, const IMPEncoderAttrDenoise *pdenoiseAttr)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pdenoiseAttr \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnDenoise(
        encChn: libc::c_int,
        pdenoiseAttr: *const IMPEncoderAttrDenoise,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnDenoise(int encChn, IMPEncoderAttrDenoise *pdenoiseAttr)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pdenoiseAttr \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnDenoise(
        encChn: libc::c_int,
        pdenoiseAttr: *mut IMPEncoderAttrDenoise,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnHSkip(int encChn, const IMPEncoderAttrHSkip *phSkipAttr)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] phSkipAttr \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n @remark  IMP_Encoder_STYPE_N1X  IMP_Encoder_STYPE_N2X , \\n\n API IMP_Encoder_STYPE_N1X  IMP_Encoder_STYPE_N2X \n @remark  IMP_Encoder_STYPE_N4X  IMP_Encoder_STYPE_H1M_TRUE \\n\n \n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnHSkip(
        encChn: libc::c_int,
        phSkipAttr: *const IMPEncoderAttrHSkip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnHSkip(int encChn, IMPEncoderAttrHSkip *phSkipAttr)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] phSkipAttr \n\n @retval 0 \n @retval 0 \n\n @remark APIAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChnHSkip(
        encChn: libc::c_int,
        phSkipAttr: *mut IMPEncoderAttrHSkip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnHSkipBlackEnhance(int encChn, const int bBlackEnhance)\n\n bBlackEnhance\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] bBlackEnhance IMPEncoderAttrHSkipbBlackEnhance\n\n @retval 0 \n @retval 0 \n\n @remark APIbBlackEnhanceAPI\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChnHSkipBlackEnhance(
        encChn: libc::c_int,
        bBlackEnhance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_InsertUserData(int encChn, void *userData, uint32_t userDataLen)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] userData \n @param[in] userDataLen , :(0, 1024], byte \n\n @retval 0 \n @retval 0 \n\n @remark API\n @remark ,\n @remark userDatauserDataLen0,\n @remark ,H.264\n @remark 2,1k byte\\n\n 2,1k byte ,\n @remark SEI, \\n\n ,\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_InsertUserData(
        encChn: libc::c_int,
        userData: *mut libc::c_void,
        userDataLen: u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetFisheyeEnableStatus(int encChn, int enable)\n\n Ingenic\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] enable 0:(),1:\n\n @retval 0 \n @retval 0 \n\n @remark API\n @remark APIIngenic,\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetFisheyeEnableStatus(
        encChn: libc::c_int,
        enable: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetFisheyeEnableStatus(int encChn, int *enable)\n\n Ingenic\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] enable Ingenic,0:,1:\n\n @retval 0 \n @retval 0 \n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetFisheyeEnableStatus(
        encChn: libc::c_int,
        enable: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChangeRef(int encChn, int bEnable)\n\n BASE\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] enable 01()\n\n @retval 0 \n @retval 0 \n\n @remark API\n @remark APISMART\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetChangeRef(encChn: libc::c_int, bEnable: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChangeRef(int encChn, int *bEnable)\n\n BASE\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] enable BASE01\n\n @retval 0 \n @retval 0 \n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetChangeRef(encChn: libc::c_int, bEnable: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetMbRC(int encChn, int bEnable)\n\n qp\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] bEnable 0:(), 1:\n\n @retval 0 \n @retval 0 \n\n @remark API\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetMbRC(encChn: libc::c_int, bEnable: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetMbRC(int encChn, int *bEnable)\n\n qp\n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] bEnable qp, 0:, 1:\n\n @retval 0 \n @retval 0 \n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetMbRC(encChn: libc::c_int, bEnable: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetSuperFrameCfg(int encChn, const IMPEncoderSuperFrmCfg *pstSuperFrmParam)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstSuperFrmParam \n\n @retval 0 \n @retval 0 \n\n @remark ,\n\n @attention APIH264channel"]
    pub fn IMP_Encoder_SetSuperFrameCfg(
        encChn: libc::c_int,
        pstSuperFrmParam: *const IMPEncoderSuperFrmCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetSuperFrameCfg(int encChn, IMPEncoderSuperFrmCfg *pstSuperFrmParam)\n\n \n\n @param[in] encChn Channel, : [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstSuperFrmParam \n\n @retval 0 \n @retval 0 \n\n @remark , \n\n @attention APIH264channel"]
    pub fn IMP_Encoder_GetSuperFrameCfg(
        encChn: libc::c_int,
        pstSuperFrmParam: *mut IMPEncoderSuperFrmCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetH264TransCfg(int encChn, const IMPEncoderH264TransCfg *pstH264TransCfg)\n\n  H.264 \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstH264TransCfg H.264 \n\n @retval 0 \n @retval 0 \n\n @remark ,\n @remark APIH264\n @remark channelstartRecvPic, GetH264TransCfgSetH264TransCfg\n\n @attention "]
    pub fn IMP_Encoder_SetH264TransCfg(
        encChn: libc::c_int,
        pstH264TransCfg: *const IMPEncoderH264TransCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetH264TransCfg(int encChn, IMPEncoderH264TransCfg *pstH264TransCfg)\n\n  H.264 \n\n @param[in] encChn Channel, : [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstH264TransCfg H.264 \n\n @retval 0 \n @retval 0 \n\n @remark , \n @remark APIH264\n\n @attention "]
    pub fn IMP_Encoder_GetH264TransCfg(
        encChn: libc::c_int,
        pstH264TransCfg: *mut IMPEncoderH264TransCfg,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetQpgMode(int encChn, const IMPEncoderQpgMode *pstQpgMode)\n\n \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstQpgMode \n\n @retval 0 \n @retval 0 \n\n @remark ,\n @remark APIH264\n\n @attention "]
    pub fn IMP_Encoder_SetQpgMode(
        encChn: libc::c_int,
        pstQpgMode: *const IMPEncoderQpgMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetQpgMode(int encChn, IMPEncoderQpgMode *pstQpgMode)\n\n \n\n @param[in] encChn Channel, : [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstQpgMode \n\n @retval 0 \n @retval 0 \n\n @remark , \n @remark APIH264\n\n @attention "]
    pub fn IMP_Encoder_GetQpgMode(
        encChn: libc::c_int,
        pstQpgMode: *mut IMPEncoderQpgMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnEncType(int encChn, IMPPayloadType *payLoadType)\n\n \n\n @param[in] encChn Channel, : [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] payLoadType \n\n @retval 0 \n @retval 0 \n\n @remark , \n\n @attention "]
    pub fn IMP_Encoder_GetChnEncType(
        encChn: libc::c_int,
        payLoadType: *mut IMPPayloadType,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetJpegeQl(int encChn, const IMPEncoderJpegeQl *pstJpegeQl)\n\n  JPEG \n\n @param[in] encChn Channel,: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pstJpegeQl JPEG ,128\n\n @retval 0 \n @retval 0 \n\n @remark ,\n @remark APIJPEG\n\n @attention "]
    pub fn IMP_Encoder_SetJpegeQl(
        encChn: libc::c_int,
        pstJpegeQl: *const IMPEncoderJpegeQl,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetJpegeQl(int encChn, IMPEncoderJpegeQl *pstJpegeQl)\n\n  JPEG \n\n @param[in] encChn Channel, : [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pstJpegeQl JPEG \n\n @retval 0 \n @retval 0 \n\n @remark , \n @remark APIJPEG\n\n @attention "]
    pub fn IMP_Encoder_GetJpegeQl(
        encChn: libc::c_int,
        pstJpegeQl: *mut IMPEncoderJpegeQl,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief int IMP_Encoder_SetPool(int chnNum, int poolID);\n\n chnnel Encodermempool.\n\n @param[in] chnNum\t\t.\n @param[in] poolID\t\t.\n\n @retval 0\t\t\t\t.\n @retval 0\t\t\t\t.\n\n @remarks\t  rmemchannel Encodermempool\n , Encoder memmempoolEncoderrmem\n rmem\n\n @attention ChannelId 0 32"]
    pub fn IMP_Encoder_SetPool(chnNum: libc::c_int, poolID: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_GetPool(int chnNum);\n\n channel ID poolID.\n\n @param[in] chnNum       .\n\n @retval  >=0 && < 32    .\n @retval  <0\t\t\t   .\n\n @remarks   ChannelId PoolId\n\n @attention ."]
    pub fn IMP_Encoder_GetPool(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief int IMP_Encoder_InputJpege(uint8_t *src, uint8_t *dst, int src_w, int src_h, int q,int *stream_length);\n\n IVPU NV12JPEG\n\n @param[in] *src \n @param[in] *dst \n @param[in] src_w \n @param[in] src_h \n @param[in] q <>\n @param[out] stream_length \n\n @retval 0 \n @retval 0 \n\n @remarks API32,8NV12JPEG\n\n @attention "]
    pub fn IMP_Encoder_InputJpege(
        src: *mut u8,
        dst: *mut u8,
        src_w: libc::c_int,
        src_h: libc::c_int,
        q: libc::c_int,
        stream_length: *mut libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " "]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPBlock {
    #[doc = "< "]
    BLOCK = 0,
    #[doc = "< "]
    NOBLOCK = 1,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioSampleRate {
    #[doc = "< 8KHz"]
    AUDIO_SAMPLE_RATE_8000 = 8000,
    #[doc = "< 12KHz"]
    AUDIO_SAMPLE_RATE_12000 = 12000,
    #[doc = "< 16KHz"]
    AUDIO_SAMPLE_RATE_16000 = 16000,
    #[doc = "< 24KHz"]
    AUDIO_SAMPLE_RATE_24000 = 24000,
    #[doc = "< 32KHz"]
    AUDIO_SAMPLE_RATE_32000 = 32000,
    #[doc = "< 44.1KHz"]
    AUDIO_SAMPLE_RATE_44100 = 44100,
    #[doc = "< 48KHz"]
    AUDIO_SAMPLE_RATE_48000 = 48000,
    #[doc = "< 96KHz"]
    AUDIO_SAMPLE_RATE_96000 = 96000,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioBitWidth {
    #[doc = "< 16bit"]
    AUDIO_BIT_WIDTH_16 = 16,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioSoundMode {
    #[doc = "< "]
    AUDIO_SOUND_MODE_MONO = 1,
    #[doc = "< "]
    AUDIO_SOUND_MODE_STEREO = 2,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioAecChn {
    #[doc = "< 1"]
    AUDIO_AEC_CHANNEL_FIRST_LEFT = 0,
    #[doc = "< 2"]
    AUDIO_AEC_CHANNEL_SECOND_RIGHT = 1,
    #[doc = "< 3"]
    AUDIO_AEC_CHANNEL_THIRD = 2,
    #[doc = "< 4"]
    AUDIO_AEC_CHANNEL_FOURTH = 3,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioPalyloadType {
    PT_PCM = 0,
    PT_G711A = 1,
    PT_G711U = 2,
    PT_G726 = 3,
    PT_AEC = 4,
    PT_ADPCM = 5,
    PT_MAX = 6,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPAudioDecMode {
    #[doc = "< Pack "]
    ADEC_MODE_PACK = 0,
    #[doc = "< Stream "]
    ADEC_MODE_STREAM = 1,
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioIOAttr {
    #[doc = "< "]
    pub samplerate: IMPAudioSampleRate,
    #[doc = "< "]
    pub bitwidth: IMPAudioBitWidth,
    #[doc = "< "]
    pub soundmode: IMPAudioSoundMode,
    #[doc = "< , :[2, MAX_AUDIO_FRAME_NUM]"]
    pub frmNum: libc::c_int,
    #[doc = "< "]
    pub numPerFrm: libc::c_int,
    #[doc = "< "]
    pub chnCnt: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioIOAttr"][::core::mem::size_of::<IMPAudioIOAttr>() - 24usize];
    ["Alignment of IMPAudioIOAttr"][::core::mem::align_of::<IMPAudioIOAttr>() - 4usize];
    ["Offset of field: IMPAudioIOAttr::samplerate"]
        [::core::mem::offset_of!(IMPAudioIOAttr, samplerate) - 0usize];
    ["Offset of field: IMPAudioIOAttr::bitwidth"]
        [::core::mem::offset_of!(IMPAudioIOAttr, bitwidth) - 4usize];
    ["Offset of field: IMPAudioIOAttr::soundmode"]
        [::core::mem::offset_of!(IMPAudioIOAttr, soundmode) - 8usize];
    ["Offset of field: IMPAudioIOAttr::frmNum"]
        [::core::mem::offset_of!(IMPAudioIOAttr, frmNum) - 12usize];
    ["Offset of field: IMPAudioIOAttr::numPerFrm"]
        [::core::mem::offset_of!(IMPAudioIOAttr, numPerFrm) - 16usize];
    ["Offset of field: IMPAudioIOAttr::chnCnt"]
        [::core::mem::offset_of!(IMPAudioIOAttr, chnCnt) - 20usize];
};
impl Default for IMPAudioIOAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioFrame {
    #[doc = "< "]
    pub bitwidth: IMPAudioBitWidth,
    #[doc = "< "]
    pub soundmode: IMPAudioSoundMode,
    #[doc = "< "]
    pub virAddr: *mut u32,
    #[doc = "< "]
    pub phyAddr: u32,
    #[doc = "< "]
    pub timeStamp: i64,
    #[doc = "< "]
    pub seq: libc::c_int,
    #[doc = "< "]
    pub len: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioFrame"][::core::mem::size_of::<IMPAudioFrame>() - 32usize];
    ["Alignment of IMPAudioFrame"][::core::mem::align_of::<IMPAudioFrame>() - 8usize];
    ["Offset of field: IMPAudioFrame::bitwidth"]
        [::core::mem::offset_of!(IMPAudioFrame, bitwidth) - 0usize];
    ["Offset of field: IMPAudioFrame::soundmode"]
        [::core::mem::offset_of!(IMPAudioFrame, soundmode) - 4usize];
    ["Offset of field: IMPAudioFrame::virAddr"]
        [::core::mem::offset_of!(IMPAudioFrame, virAddr) - 8usize];
    ["Offset of field: IMPAudioFrame::phyAddr"]
        [::core::mem::offset_of!(IMPAudioFrame, phyAddr) - 12usize];
    ["Offset of field: IMPAudioFrame::timeStamp"]
        [::core::mem::offset_of!(IMPAudioFrame, timeStamp) - 16usize];
    ["Offset of field: IMPAudioFrame::seq"][::core::mem::offset_of!(IMPAudioFrame, seq) - 24usize];
    ["Offset of field: IMPAudioFrame::len"][::core::mem::offset_of!(IMPAudioFrame, len) - 28usize];
};
impl Default for IMPAudioFrame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioIChnParam {
    #[doc = "< "]
    pub usrFrmDepth: libc::c_int,
    #[doc = "< "]
    pub aecChn: IMPAudioAecChn,
    #[doc = "< "]
    pub Rev: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioIChnParam"][::core::mem::size_of::<IMPAudioIChnParam>() - 12usize];
    ["Alignment of IMPAudioIChnParam"][::core::mem::align_of::<IMPAudioIChnParam>() - 4usize];
    ["Offset of field: IMPAudioIChnParam::usrFrmDepth"]
        [::core::mem::offset_of!(IMPAudioIChnParam, usrFrmDepth) - 0usize];
    ["Offset of field: IMPAudioIChnParam::aecChn"]
        [::core::mem::offset_of!(IMPAudioIChnParam, aecChn) - 4usize];
    ["Offset of field: IMPAudioIChnParam::Rev"]
        [::core::mem::offset_of!(IMPAudioIChnParam, Rev) - 8usize];
};
impl Default for IMPAudioIChnParam {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPAudioOChnState {
    #[doc = "< "]
    pub chnTotalNum: libc::c_int,
    #[doc = "< "]
    pub chnFreeNum: libc::c_int,
    #[doc = "< "]
    pub chnBusyNum: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioOChnState"][::core::mem::size_of::<IMPAudioOChnState>() - 12usize];
    ["Alignment of IMPAudioOChnState"][::core::mem::align_of::<IMPAudioOChnState>() - 4usize];
    ["Offset of field: IMPAudioOChnState::chnTotalNum"]
        [::core::mem::offset_of!(IMPAudioOChnState, chnTotalNum) - 0usize];
    ["Offset of field: IMPAudioOChnState::chnFreeNum"]
        [::core::mem::offset_of!(IMPAudioOChnState, chnFreeNum) - 4usize];
    ["Offset of field: IMPAudioOChnState::chnBusyNum"]
        [::core::mem::offset_of!(IMPAudioOChnState, chnBusyNum) - 8usize];
};
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioStream {
    #[doc = "< "]
    pub stream: *mut u8,
    #[doc = "< "]
    pub phyAddr: u32,
    #[doc = "< "]
    pub len: libc::c_int,
    #[doc = "< "]
    pub timeStamp: i64,
    #[doc = "< "]
    pub seq: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioStream"][::core::mem::size_of::<IMPAudioStream>() - 32usize];
    ["Alignment of IMPAudioStream"][::core::mem::align_of::<IMPAudioStream>() - 8usize];
    ["Offset of field: IMPAudioStream::stream"]
        [::core::mem::offset_of!(IMPAudioStream, stream) - 0usize];
    ["Offset of field: IMPAudioStream::phyAddr"]
        [::core::mem::offset_of!(IMPAudioStream, phyAddr) - 4usize];
    ["Offset of field: IMPAudioStream::len"][::core::mem::offset_of!(IMPAudioStream, len) - 8usize];
    ["Offset of field: IMPAudioStream::timeStamp"]
        [::core::mem::offset_of!(IMPAudioStream, timeStamp) - 16usize];
    ["Offset of field: IMPAudioStream::seq"]
        [::core::mem::offset_of!(IMPAudioStream, seq) - 24usize];
};
impl Default for IMPAudioStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioEncChnAttr {
    #[doc = "< "]
    pub type_: IMPAudioPalyloadType,
    #[doc = "<  buf [2MAX_AUDIO_FRAME_NUM]"]
    pub bufSize: libc::c_int,
    #[doc = "< "]
    pub value: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioEncChnAttr"][::core::mem::size_of::<IMPAudioEncChnAttr>() - 12usize];
    ["Alignment of IMPAudioEncChnAttr"][::core::mem::align_of::<IMPAudioEncChnAttr>() - 4usize];
    ["Offset of field: IMPAudioEncChnAttr::type_"]
        [::core::mem::offset_of!(IMPAudioEncChnAttr, type_) - 0usize];
    ["Offset of field: IMPAudioEncChnAttr::bufSize"]
        [::core::mem::offset_of!(IMPAudioEncChnAttr, bufSize) - 4usize];
    ["Offset of field: IMPAudioEncChnAttr::value"]
        [::core::mem::offset_of!(IMPAudioEncChnAttr, value) - 8usize];
};
impl Default for IMPAudioEncChnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioEncEncoder {
    #[doc = "< "]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< "]
    pub maxFrmLen: libc::c_int,
    #[doc = "< "]
    pub name: [libc::c_char; 16usize],
    pub openEncoder: ::core::option::Option<
        unsafe extern "C" fn(
            encoderAttr: *mut libc::c_void,
            encoder: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub encoderFrm: ::core::option::Option<
        unsafe extern "C" fn(
            encoder: *mut libc::c_void,
            data: *mut IMPAudioFrame,
            outbuf: *mut libc::c_uchar,
            outLen: *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub closeEncoder:
        ::core::option::Option<unsafe extern "C" fn(encoder: *mut libc::c_void) -> libc::c_int>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioEncEncoder"][::core::mem::size_of::<IMPAudioEncEncoder>() - 36usize];
    ["Alignment of IMPAudioEncEncoder"][::core::mem::align_of::<IMPAudioEncEncoder>() - 4usize];
    ["Offset of field: IMPAudioEncEncoder::type_"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, type_) - 0usize];
    ["Offset of field: IMPAudioEncEncoder::maxFrmLen"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, maxFrmLen) - 4usize];
    ["Offset of field: IMPAudioEncEncoder::name"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, name) - 8usize];
    ["Offset of field: IMPAudioEncEncoder::openEncoder"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, openEncoder) - 24usize];
    ["Offset of field: IMPAudioEncEncoder::encoderFrm"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, encoderFrm) - 28usize];
    ["Offset of field: IMPAudioEncEncoder::closeEncoder"]
        [::core::mem::offset_of!(IMPAudioEncEncoder, closeEncoder) - 32usize];
};
impl Default for IMPAudioEncEncoder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioDecChnAttr {
    #[doc = "< "]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< "]
    pub bufSize: libc::c_int,
    #[doc = "< "]
    pub mode: IMPAudioDecMode,
    #[doc = "< "]
    pub value: *mut libc::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioDecChnAttr"][::core::mem::size_of::<IMPAudioDecChnAttr>() - 16usize];
    ["Alignment of IMPAudioDecChnAttr"][::core::mem::align_of::<IMPAudioDecChnAttr>() - 4usize];
    ["Offset of field: IMPAudioDecChnAttr::type_"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, type_) - 0usize];
    ["Offset of field: IMPAudioDecChnAttr::bufSize"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, bufSize) - 4usize];
    ["Offset of field: IMPAudioDecChnAttr::mode"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, mode) - 8usize];
    ["Offset of field: IMPAudioDecChnAttr::value"]
        [::core::mem::offset_of!(IMPAudioDecChnAttr, value) - 12usize];
};
impl Default for IMPAudioDecChnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioDecDecoder {
    #[doc = "< "]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< "]
    pub name: [libc::c_char; 16usize],
    pub openDecoder: ::core::option::Option<
        unsafe extern "C" fn(
            decoderAttr: *mut libc::c_void,
            decoder: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub decodeFrm: ::core::option::Option<
        unsafe extern "C" fn(
            decoder: *mut libc::c_void,
            inbuf: *mut libc::c_uchar,
            inLen: libc::c_int,
            outbuf: *mut libc::c_ushort,
            outLen: *mut libc::c_int,
            chns: *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub getFrmInfo: ::core::option::Option<
        unsafe extern "C" fn(decoder: *mut libc::c_void, info: *mut libc::c_void) -> libc::c_int,
    >,
    pub closeDecoder:
        ::core::option::Option<unsafe extern "C" fn(decoder: *mut libc::c_void) -> libc::c_int>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioDecDecoder"][::core::mem::size_of::<IMPAudioDecDecoder>() - 36usize];
    ["Alignment of IMPAudioDecDecoder"][::core::mem::align_of::<IMPAudioDecDecoder>() - 4usize];
    ["Offset of field: IMPAudioDecDecoder::type_"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, type_) - 0usize];
    ["Offset of field: IMPAudioDecDecoder::name"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, name) - 4usize];
    ["Offset of field: IMPAudioDecDecoder::openDecoder"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, openDecoder) - 20usize];
    ["Offset of field: IMPAudioDecDecoder::decodeFrm"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, decodeFrm) - 24usize];
    ["Offset of field: IMPAudioDecDecoder::getFrmInfo"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, getFrmInfo) - 28usize];
    ["Offset of field: IMPAudioDecDecoder::closeDecoder"]
        [::core::mem::offset_of!(IMPAudioDecDecoder, closeDecoder) - 32usize];
};
impl Default for IMPAudioDecDecoder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " AGC."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPAudioAgcConfig {
    #[doc = "< ,[0, 31], ,db,.,."]
    pub TargetLevelDbfs: libc::c_int,
    #[doc = "< ,[0, 90],0,,."]
    pub CompressionGaindB: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPAudioAgcConfig"][::core::mem::size_of::<IMPAudioAgcConfig>() - 8usize];
    ["Alignment of IMPAudioAgcConfig"][::core::mem::align_of::<IMPAudioAgcConfig>() - 4usize];
    ["Offset of field: IMPAudioAgcConfig::TargetLevelDbfs"]
        [::core::mem::offset_of!(IMPAudioAgcConfig, TargetLevelDbfs) - 0usize];
    ["Offset of field: IMPAudioAgcConfig::CompressionGaindB"]
        [::core::mem::offset_of!(IMPAudioAgcConfig, CompressionGaindB) - 4usize];
};
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum Level_ns {
    #[doc = "< "]
    NS_LOW = 0,
    #[doc = "< "]
    NS_MODERATE = 1,
    #[doc = "< "]
    NS_HIGH = 2,
    #[doc = "< "]
    NS_VERYHIGH = 3,
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n .\n\n @param[in] audioDevId .\n @param[in] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n int devID = 1;\n IMPAudioIOAttr attr;\n attr.samplerate = AUDIO_SAMPLE_RATE_8000;\n attr.bitwidth = AUDIO_BIT_WIDTH_16;\n attr.soundmode = AUDIO_SOUND_MODE_MONO;\n attr.frmNum = 20;\n attr.numPerFrm = 400;\n attr.chnCnt = 1;\n ret = IMP_AI_SetPubAttr(devID, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Set Audio in %d attr err: %d\\n\", devID, ret);\n\t\treturn ret;\n }\n @endcode\n\n @attention IMP_AI_Enable."]
    pub fn IMP_AI_SetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n .\n\n @param[in] audioDevId .\n @param[out] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_GetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_Enable(int audioDevId)\n\n .\n\n @param[in] audioDevId .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention  IMP_AI_SetPubAttr()."]
    pub fn IMP_AI_Enable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_Disable(int audioDevId)\n\n .\n\n @param[in] audioDevId .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AI_Enable,IMP_AI_Disable."]
    pub fn IMP_AI_Disable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableChn(int audioDevId, int aiChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention device."]
    pub fn IMP_AI_EnableChn(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableChn(int audioDevId, int aiChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AI_EnableChn."]
    pub fn IMP_AI_DisableChn(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_PollingFrame(int audioDevId, int aiChn, unsigned int timeout_ms)\n\n Polling.\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[in] timeout_ms Polling.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AI_GetFrame\n\t\t\t  IMP_AI_GetFrame."]
    pub fn IMP_AI_PollingFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        timeout_ms: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetFrame(int audioDevId, int aiChn, IMPAudioFrame *frm, IMPBlock block)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[out] frm .\n @param[in] block /.\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n IMPAudioFrame frm;\n // \n ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Get Frame Data error\\n\");\n\t\treturn ret;\n }\n\n fwrite(frm.virAddr, 1, frm.len, record_file); // \n\n // \n ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio release frame data error\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention ."]
    pub fn IMP_AI_GetFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        frm: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_ReleaseFrame(int audioDevId, int aiChn, IMPAudioFrame *frm)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[in] frm .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AI_GetFrame."]
    pub fn IMP_AI_ReleaseFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        frm: *mut IMPAudioFrame,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetChnParam(int audioDevId, int aiChn, IMPAudioIChnParam *chnParam)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[in] chnParam .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n int chnID = 0;\n IMPAudioIChnParam chnParam;\n chnParam.usrFrmDepth = 20;\t// the range of valid value is [2, MAX_AUDIO_FRAME_NUM].\n ret = IMP_AI_SetChnParam(devID, chnID, &chnParam);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"set ai %d channel %d attr err: %d\\n\", devID, chnID, ret);\n\t\treturn ret;\n }\n @endcode\n\n @attention IMP_AI_EnableChn."]
    pub fn IMP_AI_SetChnParam(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        chnParam: *mut IMPAudioIChnParam,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetChnParam(int audioDevId, int aiChn, IMPAudioIChnParam *chnParam)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[out] chnParam .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_GetChnParam(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        chnParam: *mut IMPAudioIChnParam,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAec(int aiDevId, int aiChn, int aoDevId, int aoChn)\n\n .\n\n @param[in] aiDevId .\n @param[in] aiChn .\n @param[in] aoDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n @remarks ,\n @remarks \n @remarks /etc/webrtc_profile.ini .\n @remarks ():\n @remarks [Set_Far_Frame]\n @remarks Frame_V=0.3\n @remarks [Set_Near_Frame]\n @remarks Frame_V=0.1\n @remarks delay_ms=150\n\n @remarks [Set_Far_Frame],SPK.\n @remarks Fram_V ,().\n @remarks [Set_Near_Frame],MIC.\n @remarks Fram_V ,().\n @remarks delay_ms ,SPKMIC,SPKMIC,SPKMIC.\n @remarks .\n\n @attention aiDevIdaiChn.. \\n\n ,.."]
    pub fn IMP_AI_EnableAec(
        aiDevId: libc::c_int,
        aiChn: libc::c_int,
        aoDevId: libc::c_int,
        aoChn: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "@fn  int IMP_AI_Set_WebrtcProfileIni_Path(char *path)\nAEC\" webrtc_profile.ini\" .\n\npath.\n /system  IMP_AI_Set_WebrtcProfileIni_Path(\"/system\");\n\n   IMP_AI_EnableAec(int aiDevId, int aiChn, int aoDevId, int aoChn)\n   IMP_AI_EnableAlgo(int audioDevId, int aiChn)\n   IMP_AO_EnableAlgo(int audioDevId, int aoChn)\n0"]
    pub fn IMP_AI_Set_WebrtcProfileIni_Path(path: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAec(int aiDevId, int aiChn)\n\n .\n\n @param[in] aiDevId .\n @param[in] aiChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_DisableAec(aiDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableNs(IMPAudioIOAttr *attr, int mode)\n\n .\n\n @param[in] attr .\n @param[in] mode 0  3, Level_ns.\n\n @retval 0 .\n @retval 0 .\n\n @remarks mode,[0 ~ 3],,.\n @remarks ,,,\n @remarks .\n\n @attention ,,."]
    pub fn IMP_AI_EnableNs(attr: *mut IMPAudioIOAttr, mode: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableNs(void)\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_DisableNs() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableHs(void)\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_EnableHs() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableHs(void)\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_DisableHs() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAgc(IMPAudioIOAttr *attr, IMPAudioAgcConfig agcConfig)\n\n .\n\n @param[in] attr .\n @param[in] agcConfig ,.\n\n @retval 0 .\n @retval 0 .\n\n @remarks agcConfig,AGC,IMPAudioAgcConfig.\n @remarks ,AGC,,,.\n\n @attention  AGC ,,."]
    pub fn IMP_AI_EnableAgc(attr: *mut IMPAudioIOAttr, agcConfig: IMPAudioAgcConfig)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAgc(void)\n\n AI.\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_DisableAgc() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableAgc(IMPAudioIOAttr *attr, IMPAudioAgcConfig agcConfig)\n\n .\n\n @param[in] attr .\n @param[in] agcConfig ,.\n\n @retval 0 .\n @retval 0 .\n\n @remarks agcConfig,AGC,IMPAudioAgcConfig.\n @remarks ,AGC,,,.\n\n @attention  AGC ,,."]
    pub fn IMP_AO_EnableAgc(attr: *mut IMPAudioIOAttr, agcConfig: IMPAudioAgcConfig)
        -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableAgc(void)\n\n AO.\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_DisableAgc() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableHpf(IMPAudioIOAttr *attr)\n\n .\n\n @param[in] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention  HPF ,, HPF."]
    pub fn IMP_AI_EnableHpf(attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetHpfCoFrequency(int cofrequency)\n\n .\n\n @param[in] cofrequency \n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention "]
    pub fn IMP_AI_SetHpfCoFrequency(cofrequency: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableHpf(void)\n\n AI.\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_DisableHpf() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableHpf(IMPAudioIOAttr *attr)\n\n .\n\n @param[in] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention  HPF ,, HPF."]
    pub fn IMP_AO_EnableHpf(attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetHpfCoFrequency(int cofrequency)\n\n .\n\n @param[in] cofrequency \n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_SetHpfCoFrequency(cofrequency: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableHpf(void)\n\n AO.\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_DisableHpf() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n .\n\n @param[in] audioDevId .\n @param[in] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_SetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n .\n\n @param[in] audioDevId .\n @param[out] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_GetPubAttr(audioDevId: libc::c_int, attr: *mut IMPAudioIOAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Enable(int audioDevId)\n\n .\n\n @param[in] audioDevId .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AO_SetPubAttr."]
    pub fn IMP_AO_Enable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Disable(int audioDevId)\n\n .\n\n @param[in] audioDevId .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_Disable(audioDevId: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableChn(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_EnableChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableChn(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_DisableChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SendFrame(int audioDevId, int aoChn, IMPAudioFrame *data, IMPBlock block)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[in] data .\n @param[in] block /.\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n while(1) {\n\t\tsize = fread(buf, 1, IMP_AUDIO_BUF_SIZE, play_file);\n\t\tif(size < IMP_AUDIO_BUF_SIZE)\n\t\t\tbreak;\n\n\t\tIMPAudioFrame frm;\n\t\tfrm.virAddr = (uint32_t *)buf;\n\t\tfrm.len = size;\n\t\tret = IMP_AO_SendFrame(devID, chnID, &frm, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"send Frame Data error\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention ."]
    pub fn IMP_AO_SendFrame(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        data: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_PauseChn(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_PauseChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_ResumeChn(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_ResumeChn(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_ClearChnBuf(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_ClearChnBuf(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_QueryChnStat(int audioDevId, int aoChn, IMPAudioOChnState *status)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[out] status .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_QueryChnStat(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        status: *mut IMPAudioOChnState,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_CreateChn(int aeChn, IMPAudioEncChnAttr *attr)\n\n .\n\n @param[in] aeChn .\n @param[in] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n int AeChn = 0;\n IMPAudioEncChnAttr attr;\n attr.type = PT_G711A;\n attr.bufSize = 20;\n ret = IMP_AENC_CreateChn(AeChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio encode create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention SDKPT_G711APT_G711UPT_G726. \\n\n SDK,attr.type = PT_G711A. \\n\n ,,."]
    pub fn IMP_AENC_CreateChn(aeChn: libc::c_int, attr: *mut IMPAudioEncChnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_DestroyChn(int aeChn)\n\n .\n\n @param[in] aeChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AENC_CreateChn."]
    pub fn IMP_AENC_DestroyChn(aeChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_SendFrame(int aeChn, IMPAudioFrame *frm)\n\n .\n\n @param[in] aeChn .\n @param[in] frm .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n while(1) {\n\t\t// \n\t\tret = fread(buf_pcm, 1, IMP_AUDIO_BUF_SIZE, file_pcm);\n\t\tif(ret < IMP_AUDIO_BUF_SIZE)\n\t\t\tbreak;\n\n\t\t// \n\t\tIMPAudioFrame frm;\n\t\tfrm.virAddr = (uint32_t *)buf_pcm;\n\t\tfrm.len = ret;\n\t\tret = IMP_AENC_SendFrame(AeChn, &frm);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode send frame failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// \n\t\tIMPAudioStream stream;\n\t\tret = IMP_AENC_GetStream(AeChn, &stream, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode get stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// \n\t\tfwrite(stream.stream, 1, stream.len, file_g711);\n\n\t\t// \n\t\tret = IMP_AENC_ReleaseStream(AeChn, &stream);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode release stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention ."]
    pub fn IMP_AENC_SendFrame(aeChn: libc::c_int, frm: *mut IMPAudioFrame) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_PollingStream(int AeChn, unsigned int timeout_ms)\n\n Polling.\n\n @param[in] AeChn .\n @param[in] timeout_ms Polling.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_AENC_GetStream\n\t\t\t  IMP_AENC_GetStream."]
    pub fn IMP_AENC_PollingStream(AeChn: libc::c_int, timeout_ms: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_GetStream(int aeChn, IMPAudioStream *stream ,IMPBlock block)\n\n .\n\n @param[in] aeChn .\n @param[in] stream .\n @param[in] block /.\n\n @retval 0 .\n @retval 0 .\n\n @remarks IMP_AENC_SendFrame.\n\n @attention ."]
    pub fn IMP_AENC_GetStream(
        aeChn: libc::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_ReleaseStream(int aeChn,IMPAudioStream *stream)\n\n .\n\n @param[in] aeChn .\n @param[in] stream .\n\n @retval 0 .\n @retval 0 .\n\n @remarks IMP_AENC_SendFrame.\n\n @attention ."]
    pub fn IMP_AENC_ReleaseStream(aeChn: libc::c_int, stream: *mut IMPAudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_RegisterEncoder(int *handle, IMPAudioEncEncoder *encoder)\n\n .\n\n @param[in] ps32handle .\n @param[in] encoder .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n int handle_g711a = 0;\n IMPAudioEncEncoder my_encoder;\n my_encoder.maxFrmLen = 1024;\n sprintf(my_encoder.name, \"%s\", \"MY_G711A\");\n my_encoder.openEncoder = NULL; // \n my_encoder.encoderFrm = MY_G711A_Encode_Frm; // \n my_encoder.closeEncoder = NULL; // \n\n ret = IMP_AENC_RegisterEncoder(&handle_g711a, &my_encoder);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"IMP_AENC_RegisterEncoder failed\\n\");\n\t\treturn ret;\n }\n\n // \n int AeChn = 0;\n IMPAudioEncChnAttr attr;\n attr.type = handle_g711a; // typehandle_g711a.\n attr.bufSize = 20;\n ret = IMP_AENC_CreateChn(AeChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio encode create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention SDK."]
    pub fn IMP_AENC_RegisterEncoder(
        handle: *mut libc::c_int,
        encoder: *mut IMPAudioEncEncoder,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_UnRegisterEncoder(int *handle)\n\n .\n\n @param[in] ps32handle ().\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AENC_UnRegisterEncoder(handle: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_CreateChn(int adChn, IMPAudioDecChnAttr *attr)\n\n .\n\n @param[in] adChn .\n @param[in] attr .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n int adChn = 0;\n IMPAudioDecChnAttr attr;\n attr.type = PT_G711A;\n attr.bufSize = 20;\n attr.mode = ADEC_MODE_PACK;\n ret = IMP_ADEC_CreateChn(adChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio decoder create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention ."]
    pub fn IMP_ADEC_CreateChn(adChn: libc::c_int, attr: *mut IMPAudioDecChnAttr) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_DestroyChn(int adChn)\n\n .\n\n @param[in] adChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_ADEC_DestroyChn(adChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_SendStream(int adChn, IMPAudioStream *stream, IMPBlock block)\n\n .\n\n @param[in] adChn .\n @param[in] stream .\n @param[in] block /.\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n while(1) {\n\t\t// \n\t\tret = fread(buf_g711, 1, IMP_AUDIO_BUF_SIZE/2, file_g711);\n\t\tif(ret < IMP_AUDIO_BUF_SIZE/2)\n\t\t\tbreak;\n\n\t\t// \n\t\tIMPAudioStream stream_in;\n\t\tstream_in.stream = (uint8_t *)buf_g711;\n\t\tstream_in.len = ret;\n\t\tret = IMP_ADEC_SendStream(adChn, &stream_in, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode send frame failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// \n\t\tIMPAudioStream stream_out;\n\t\tret = IMP_ADEC_GetStream(adChn, &stream_out, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio decoder get stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// \n\t\tfwrite(stream_out.stream, 1, stream_out.len, file_pcm);\n\n\t\t// \n\t\tret = IMP_ADEC_ReleaseStream(adChn, &stream_out);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio decoder release stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention ."]
    pub fn IMP_ADEC_SendStream(
        adChn: libc::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_PollingStream(int AdChn, unsigned int timeout_ms)\n\n Polling.\n\n @param[in] AdChn .\n @param[in] timeout_ms Polling.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention IMP_ADEC_GetStream\n\t\t\t  IMP_ADEC_GetStream."]
    pub fn IMP_ADEC_PollingStream(AdChn: libc::c_int, timeout_ms: libc::c_uint) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_GetStream(int adChn, IMPAudioStream *stream ,IMPBlock block)\n\n .\n\n @param[in] adChn .\n @param[in] stream .\n @param[in] block /.\n\n @retval 0 .\n @retval 0 .\n\n @remarks IMP_ADEC_SendStream.\n\n @attention ."]
    pub fn IMP_ADEC_GetStream(
        adChn: libc::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_ReleaseStream(int adChn,IMPAudioStream *stream)\n .\n\n @param[in] adChn .\n @param[in] stream .\n\n @retval 0 .\n @retval 0 .\n\n @remarks IMP_ADEC_SendStream.\n\n @attention ."]
    pub fn IMP_ADEC_ReleaseStream(adChn: libc::c_int, stream: *mut IMPAudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_ClearChnBuf(int adChn)\n\n .\n\n @param[in] adChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_ADEC_ClearChnBuf(adChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_RegisterDecoder(int *handle, IMPAudioDecDecoder *decoder)\n\n .\n\n @param[in] ps32handle .\n @param[in] decoder .\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n int handle_g711a = 0;\n IMPAudioDecDecoder my_decoder;\n sprintf(my_decoder.name, \"%s\", \"MY_G711A\");\n my_decoder.openDecoder = NULL; // \n my_decoder.decodeFrm = MY_G711A_Decode_Frm; // \n my_decoder.getFrmInfo = NULL; // \n my_decoder.closeDecoder = NULL; // \n\n // \n ret = IMP_ADEC_RegisterDecoder(&handle_g711a, &my_decoder);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"IMP_ADEC_RegisterDecoder failed\\n\");\n\t\treturn ret;\n }\n\n // \n int adChn = 0;\n IMPAudioDecChnAttr attr;\n attr.type = handle_g711a; // typehandle_g711a.\n attr.bufSize = 20;\n attr.mode = ADEC_MODE_PACK;\n // \n ret = IMP_ADEC_CreateChn(adChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio decoder create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention SDK."]
    pub fn IMP_ADEC_RegisterDecoder(
        handle: *mut libc::c_int,
        decoder: *mut IMPAudioDecDecoder,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_UnRegisterDecoder(int *handle)\n\n .\n\n @param[in] ps32handle ().\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_ADEC_UnRegisterDecoder(handle: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " ACODEC.\n/\n/**\n @fn int IMP_AI_SetVol(int audioDevId, int aiChn, int aiVol)\n\n .\n\n @param[in] aiDevId .\n @param[in] aiChn .\n @param[in] aiVol .\n\n @retval 0 .\n @retval 0 .\n\n @remarks [-30 ~ 120]. -30,12030dB,0.5dB.\n @remarks 606010.5dB6010.5dB\n\n \n @code\n int volume = 60;\n ret = IMP_AI_SetVol(devID, chnID, volume);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Record set volume failed\\n\");\n\t\treturn ret;\n }\n @endcode\n @attention aiVol[-30 ~ 120],-30-30,120120."]
    pub fn IMP_AI_SetVol(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        aiVol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetVol(int audioDevId, int aiChn, int *vol)\n\n .\n\n @param[in] aiDevId .\n @param[in] aiChn .\n @param[out] vol .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_GetVol(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        vol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetVolMute(int audioDevId, int aiChn, int mute)\n\n .\n\n @param[in] aiDevId .\n @param[in] aiChn .\n @param[out] mute , mute = 0:, mute = 1:.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_SetVolMute(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        mute: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetVol(int audioDevId, int aoChn, int aoVol)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[in] aoVol .\n\n @retval 0 .\n @retval 0 .\n\n @remarks [-30 ~ 120]. -30,12030dB,0.5dB.\n @remarks 606010.5dB6010.5dB\n\n @attention aoVol[-30 ~ 120],-30-30,120120."]
    pub fn IMP_AO_SetVol(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        aoVol: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetVol(int audioDevId, int aoChn, int *vol)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[out] aoVol .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_GetVol(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        vol: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetVolMute(int audioDevId, int aoChn, int mute)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[out] mute , mute = 0:, mute = 1:.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_SetVolMute(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        mute: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetGain(int audioDevId, int aiChn, int aiGain)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[in] aigain .\n\n [0 ~ 31],[-18dB ~ 28.5dB],1.5dB.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention aiGain[0 ~ 31],0,aiGain\\n\n 0.31,aiGain31.\n"]
    pub fn IMP_AI_SetGain(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        aigain: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetGain(int audioDevId, int aiChn, int *aiGain)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[out] aigain .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AI_GetGain(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        aigain: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetGain(int audioDevId, int aoChn, int aoGain)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[out] aoGain ,[0 ~ 0x1f],[-39dB ~ 6dB],1.5dB.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention aoGain[0 ~ 31],0,aoGain\\n\n 0.31,aoGain31.\n"]
    pub fn IMP_AO_SetGain(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        aoGain: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetGain(int audioDevId, int aoChn, int *aoGain)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n @param[out] aoGain .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_GetGain(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        aoGain: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Soft_Mute(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_Soft_Mute(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Soft_UNMute(int audioDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn IMP_AO_Soft_UNMute(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetFrameAndRef(int audioDevId, int aiChn, IMPAudioFrame *frm, IMPAudioFrame *ref, IMPBlock block)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[out] frm .\n @param[out] ref .\n @param[in] block /.\n\n @retval 0 .\n @retval 0 .\n\n @remarks \n @code\n IMPAudioFrame frm;\n IMPAudioFrame ref;\n // \n ret = IMP_AI_GetFrameAndRef(devID, chnID, &frm, &ref, BLOCK);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Get Frame Data error\\n\");\n\t\treturn ret;\n }\n\n fwrite(frm.virAddr, 1, frm.len, record_file); // \n fwrite(ref.virAddr, 1, ref.len, ref_file); // \n\n // \n ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio release frame data error\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention ."]
    pub fn IMP_AI_GetFrameAndRef(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        frm: *mut IMPAudioFrame,
        ref_: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAecRefFrame(int audioDevId, int aiChn, int audioAoDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[in] audioAoDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks IMP_AI_GetFrameAndRef.\n @attention ."]
    pub fn IMP_AI_EnableAecRefFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        audioAoDevId: libc::c_int,
        aoChn: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAecRefFrame(int audioDevId, int aiChn, int audioAoDevId, int aoChn)\n\n .\n\n @param[in] audioDevId .\n @param[in] aiChn .\n @param[in] audioAoDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n @attention ."]
    pub fn IMP_AI_DisableAecRefFrame(
        audioDevId: libc::c_int,
        aiChn: libc::c_int,
        audioAoDevId: libc::c_int,
        aoChn: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_CacheSwitch(int audioDevId, int aoChn, int cache_en)\n \n @param[in] audioDevId .\n @param[in] aoChn .\n @param[in] cache_en \n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n @attention ."]
    pub fn IMP_AO_CacheSwitch(
        audioDevId: libc::c_int,
        aoChn: libc::c_int,
        cache_en: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_FlushChnBuf(int audioDevId, int aoChn);\n ;\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n @attention ."]
    pub fn IMP_AO_FlushChnBuf(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAlgo(int audioDevId, int aiChn)\n\n NS/AGC/HPF.\n\n @param[in] audioDevId .\n @param[in] aiChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention device."]
    pub fn IMP_AI_EnableAlgo(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAlgo(void)\n\n NS/AGC/HPF.\n @param[in] audioDevId .\n @param[in] aiChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attentio ."]
    pub fn IMP_AI_DisableAlgo(audioDevId: libc::c_int, aiChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableAlgo(int audioDevId, int aoChn)\n\n NS/AGC/HPF.\n\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention device."]
    pub fn IMP_AO_EnableAlgo(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableAlgo(void)\n\n NS/AGC/HPF.\n @param[in] audioDevId .\n @param[in] aoChn .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attentio ."]
    pub fn IMP_AO_DisableAlgo(audioDevId: libc::c_int, aoChn: libc::c_int) -> libc::c_int;
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderAttr {
    #[doc = "< "]
    pub decType: IMPPayloadType,
    #[doc = "< "]
    pub maxWidth: u32,
    #[doc = "< "]
    pub maxHeight: u32,
    #[doc = "< "]
    pub pixelFormat: IMPPixelFormat,
    #[doc = "< "]
    pub nrKeepStream: u32,
    #[doc = "< , "]
    pub frmRateNum: u32,
    #[doc = "< , "]
    pub frmRateDen: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderAttr"][::core::mem::size_of::<IMPDecoderAttr>() - 28usize];
    ["Alignment of IMPDecoderAttr"][::core::mem::align_of::<IMPDecoderAttr>() - 4usize];
    ["Offset of field: IMPDecoderAttr::decType"]
        [::core::mem::offset_of!(IMPDecoderAttr, decType) - 0usize];
    ["Offset of field: IMPDecoderAttr::maxWidth"]
        [::core::mem::offset_of!(IMPDecoderAttr, maxWidth) - 4usize];
    ["Offset of field: IMPDecoderAttr::maxHeight"]
        [::core::mem::offset_of!(IMPDecoderAttr, maxHeight) - 8usize];
    ["Offset of field: IMPDecoderAttr::pixelFormat"]
        [::core::mem::offset_of!(IMPDecoderAttr, pixelFormat) - 12usize];
    ["Offset of field: IMPDecoderAttr::nrKeepStream"]
        [::core::mem::offset_of!(IMPDecoderAttr, nrKeepStream) - 16usize];
    ["Offset of field: IMPDecoderAttr::frmRateNum"]
        [::core::mem::offset_of!(IMPDecoderAttr, frmRateNum) - 20usize];
    ["Offset of field: IMPDecoderAttr::frmRateDen"]
        [::core::mem::offset_of!(IMPDecoderAttr, frmRateDen) - 24usize];
};
impl Default for IMPDecoderAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderCHNAttr {
    #[doc = "< "]
    pub decAttr: IMPDecoderAttr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderCHNAttr"][::core::mem::size_of::<IMPDecoderCHNAttr>() - 28usize];
    ["Alignment of IMPDecoderCHNAttr"][::core::mem::align_of::<IMPDecoderCHNAttr>() - 4usize];
    ["Offset of field: IMPDecoderCHNAttr::decAttr"]
        [::core::mem::offset_of!(IMPDecoderCHNAttr, decAttr) - 0usize];
};
impl Default for IMPDecoderCHNAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderNal {
    #[doc = "< "]
    pub i_payload: libc::c_int,
    #[doc = "< "]
    pub p_payload: *mut u8,
    #[doc = "< "]
    pub timeStamp: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderNal"][::core::mem::size_of::<IMPDecoderNal>() - 16usize];
    ["Alignment of IMPDecoderNal"][::core::mem::align_of::<IMPDecoderNal>() - 8usize];
    ["Offset of field: IMPDecoderNal::i_payload"]
        [::core::mem::offset_of!(IMPDecoderNal, i_payload) - 0usize];
    ["Offset of field: IMPDecoderNal::p_payload"]
        [::core::mem::offset_of!(IMPDecoderNal, p_payload) - 4usize];
    ["Offset of field: IMPDecoderNal::timeStamp"]
        [::core::mem::offset_of!(IMPDecoderNal, timeStamp) - 8usize];
};
impl Default for IMPDecoderNal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderStream {
    #[doc = "< "]
    pub decoderNal: IMPDecoderNal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPDecoderStream"][::core::mem::size_of::<IMPDecoderStream>() - 16usize];
    ["Alignment of IMPDecoderStream"][::core::mem::align_of::<IMPDecoderStream>() - 8usize];
    ["Offset of field: IMPDecoderStream::decoderNal"]
        [::core::mem::offset_of!(IMPDecoderStream, decoderNal) - 0usize];
};
impl Default for IMPDecoderStream {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_CreateChn(int decChn, const IMPDecoderCHNAttr *attr)\n\n Channel\n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] attr Channel\n\n @retval 0 \n @retval 0 \n\n @remark \n @attention "]
    pub fn IMP_Decoder_CreateChn(
        decChn: libc::c_int,
        attr: *const IMPDecoderCHNAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_DestroyChn(int decChn)\n\n Channel\n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark \n @attention "]
    pub fn IMP_Decoder_DestroyChn(decChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_StartRecvPic(int decChn)\n\n Channel\n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark Channel\n\n @attention Channel"]
    pub fn IMP_Decoder_StartRecvPic(decChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_StopRecvPic(int decChn)\n\n Channel\n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 \n @retval 0 \n\n @remark Channel\n\n @attention Channel"]
    pub fn IMP_Decoder_StopRecvPic(decChn: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_SendStreamTimeout(int decChn, IMPDecoderStream *stream, uint32_t timeoutMsec)\n\n \n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] stream \n @param[in] timeoutMsec  ms\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention Channel"]
    pub fn IMP_Decoder_SendStreamTimeout(
        decChn: libc::c_int,
        stream: *mut IMPDecoderStream,
        timeoutMsec: u32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_PollingFrame(int decChn, uint32_t timeoutMsec)\n\n Polling \n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] timeoutMsec  ms\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention Channel"]
    pub fn IMP_Decoder_PollingFrame(decChn: libc::c_int, timeoutMsec: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_GetFrame(int decChn, IMPFrameInfo **frame)\n\n \n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[out] frame \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention buffer"]
    pub fn IMP_Decoder_GetFrame(decChn: libc::c_int, frame: *mut *mut IMPFrameInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_ReleaseFrame(int decChn, IMPFrameInfo *frame)\n\n \n\n @param[in] decChn Channel,: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] frame \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_Decoder_ReleaseFrame(decChn: libc::c_int, frame: *mut IMPFrameInfo) -> libc::c_int;
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPFSChnCrop {
    #[doc = "< "]
    pub enable: libc::c_int,
    #[doc = "< "]
    pub left: libc::c_int,
    #[doc = "< "]
    pub top: libc::c_int,
    #[doc = "< "]
    pub width: libc::c_int,
    #[doc = "< "]
    pub height: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnCrop"][::core::mem::size_of::<IMPFSChnCrop>() - 20usize];
    ["Alignment of IMPFSChnCrop"][::core::mem::align_of::<IMPFSChnCrop>() - 4usize];
    ["Offset of field: IMPFSChnCrop::enable"]
        [::core::mem::offset_of!(IMPFSChnCrop, enable) - 0usize];
    ["Offset of field: IMPFSChnCrop::left"][::core::mem::offset_of!(IMPFSChnCrop, left) - 4usize];
    ["Offset of field: IMPFSChnCrop::top"][::core::mem::offset_of!(IMPFSChnCrop, top) - 8usize];
    ["Offset of field: IMPFSChnCrop::width"]
        [::core::mem::offset_of!(IMPFSChnCrop, width) - 12usize];
    ["Offset of field: IMPFSChnCrop::height"]
        [::core::mem::offset_of!(IMPFSChnCrop, height) - 16usize];
};
#[doc = " "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMPFSChnScaler {
    #[doc = "< "]
    pub enable: libc::c_int,
    #[doc = "< "]
    pub outwidth: libc::c_int,
    #[doc = "< "]
    pub outheight: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnScaler"][::core::mem::size_of::<IMPFSChnScaler>() - 12usize];
    ["Alignment of IMPFSChnScaler"][::core::mem::align_of::<IMPFSChnScaler>() - 4usize];
    ["Offset of field: IMPFSChnScaler::enable"]
        [::core::mem::offset_of!(IMPFSChnScaler, enable) - 0usize];
    ["Offset of field: IMPFSChnScaler::outwidth"]
        [::core::mem::offset_of!(IMPFSChnScaler, outwidth) - 4usize];
    ["Offset of field: IMPFSChnScaler::outheight"]
        [::core::mem::offset_of!(IMPFSChnScaler, outheight) - 8usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPFSChnType {
    #[doc = "< "]
    FS_PHY_CHANNEL = 0,
    #[doc = "< "]
    FS_EXT_CHANNEL = 1,
}
#[repr(u32)]
#[doc = " FIFO"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IMPFSChnFifoType {
    #[doc = "< FIFO "]
    FIFO_CACHE_PRIORITY = 0,
    #[doc = "< FIFO "]
    FIFO_DATA_PRIORITY = 1,
}
#[doc = " FIFO"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnFifoAttr {
    #[doc = "< FIFO "]
    pub maxdepth: libc::c_int,
    #[doc = "< FIFO"]
    pub type_: IMPFSChnFifoType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnFifoAttr"][::core::mem::size_of::<IMPFSChnFifoAttr>() - 8usize];
    ["Alignment of IMPFSChnFifoAttr"][::core::mem::align_of::<IMPFSChnFifoAttr>() - 4usize];
    ["Offset of field: IMPFSChnFifoAttr::maxdepth"]
        [::core::mem::offset_of!(IMPFSChnFifoAttr, maxdepth) - 0usize];
    ["Offset of field: IMPFSChnFifoAttr::type_"]
        [::core::mem::offset_of!(IMPFSChnFifoAttr, type_) - 4usize];
};
impl Default for IMPFSChnFifoAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnAttr {
    #[doc = "< "]
    pub picWidth: libc::c_int,
    #[doc = "< "]
    pub picHeight: libc::c_int,
    #[doc = "< "]
    pub pixFmt: IMPPixelFormat,
    #[doc = "< "]
    pub crop: IMPFSChnCrop,
    #[doc = "< "]
    pub scaler: IMPFSChnScaler,
    #[doc = "< "]
    pub outFrmRateNum: libc::c_int,
    #[doc = "< "]
    pub outFrmRateDen: libc::c_int,
    #[doc = "< Video buffer"]
    pub nrVBs: libc::c_int,
    #[doc = "< "]
    pub type_: IMPFSChnType,
    #[doc = "< "]
    pub mirr_enable: libc::c_int,
    #[doc = "< "]
    pub fcrop: IMPFSChnCrop,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IMPFSChnAttr"][::core::mem::size_of::<IMPFSChnAttr>() - 84usize];
    ["Alignment of IMPFSChnAttr"][::core::mem::align_of::<IMPFSChnAttr>() - 4usize];
    ["Offset of field: IMPFSChnAttr::picWidth"]
        [::core::mem::offset_of!(IMPFSChnAttr, picWidth) - 0usize];
    ["Offset of field: IMPFSChnAttr::picHeight"]
        [::core::mem::offset_of!(IMPFSChnAttr, picHeight) - 4usize];
    ["Offset of field: IMPFSChnAttr::pixFmt"]
        [::core::mem::offset_of!(IMPFSChnAttr, pixFmt) - 8usize];
    ["Offset of field: IMPFSChnAttr::crop"][::core::mem::offset_of!(IMPFSChnAttr, crop) - 12usize];
    ["Offset of field: IMPFSChnAttr::scaler"]
        [::core::mem::offset_of!(IMPFSChnAttr, scaler) - 32usize];
    ["Offset of field: IMPFSChnAttr::outFrmRateNum"]
        [::core::mem::offset_of!(IMPFSChnAttr, outFrmRateNum) - 44usize];
    ["Offset of field: IMPFSChnAttr::outFrmRateDen"]
        [::core::mem::offset_of!(IMPFSChnAttr, outFrmRateDen) - 48usize];
    ["Offset of field: IMPFSChnAttr::nrVBs"]
        [::core::mem::offset_of!(IMPFSChnAttr, nrVBs) - 52usize];
    ["Offset of field: IMPFSChnAttr::type_"]
        [::core::mem::offset_of!(IMPFSChnAttr, type_) - 56usize];
    ["Offset of field: IMPFSChnAttr::mirr_enable"]
        [::core::mem::offset_of!(IMPFSChnAttr, mirr_enable) - 60usize];
    ["Offset of field: IMPFSChnAttr::fcrop"]
        [::core::mem::offset_of!(IMPFSChnAttr, fcrop) - 64usize];
};
impl Default for IMPFSChnAttr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_CreateChn(int chnNum, IMPFSChnAttr *chnAttr)\n\n \n\n @param[in] chnNum \n @param[in] chnAttr \n\n @retval 0 \n @retval 0 \n\n @remark ; \\n\n , buf\\n\n T10012,3\n\n @attention "]
    pub fn IMP_FrameSource_CreateChn(
        chnNum: libc::c_int,
        chn_attr: *mut IMPFSChnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_DestroyChn(int chnNum)\n\n \n\n @param[in] chnNum \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention IMP_FrameSource_EnableChnIMP_FrameSource_DisableChn"]
    pub fn IMP_FrameSource_DestroyChn(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_EnableChn(int chnNum)\n\n \n\n @param[in] chnNum \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention ."]
    pub fn IMP_FrameSource_EnableChn(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_DisableChn(int chnNum)\n\n \n\n @param[in] chnNum \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn IMP_FrameSource_DisableChn(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_GetChnAttr(int chnNum, IMPFSChnAttr *chnAttr)\n\n \n\n @param[in] chnNum \n\n @param[out] chnAttr \n\n @retval 0 \n @retval 0 \n\n @remark , buf.\n\n @attention "]
    pub fn IMP_FrameSource_GetChnAttr(
        chnNum: libc::c_int,
        chnAttr: *mut IMPFSChnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_SetChnAttr(int chnNum, const IMPFSChnAttr *chnAttr)\n\n \n\n @param[in] chnNum \n\n @param[in] chnAttr \n\n @retval 0 \n @retval 0 \n\n @remark , buf.\n\n @attention "]
    pub fn IMP_FrameSource_SetChnAttr(
        chnNum: libc::c_int,
        chnAttr: *const IMPFSChnAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetFrameDepth(int chnNum, int depth)\n\n \n\n @param[in] chnNum \n @param[in] depth \n\n @retval 0 \n @retval 0 \n\n @remark \n @remark depth0depth0\n @remark \n @remark \n @remark \n @remark \n\n @attention ."]
    pub fn IMP_FrameSource_SetFrameDepth(chnNum: libc::c_int, depth: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetFrameDepth(int chnNum, int *depth);\n\n \n\n @param[in] chnNum \n @param[out] depth \n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention ."]
    pub fn IMP_FrameSource_GetFrameDepth(
        chnNum: libc::c_int,
        depth: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetFrame(int chnNum, IMPFrameInfo **frame);\n\n \n\n @param[in] chnNum \n @param[out] frame \n\n @retval 0 \n @retval 0 \n\n @remark \n @remark \n @remark \n @remark  2s2s \n\n @attention ."]
    pub fn IMP_FrameSource_GetFrame(
        chnNum: libc::c_int,
        frame: *mut *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetTimedFrame(int chnNum, IMPFrameTimestamp *framets, int block, void *framedata, IMPFrameInfo *frame);\n\n \n\n @param[in] chnNum \n @param[in] framets \n @param[in] block \n @param[in] framedata \n @param[in] frame \n\n @retval 0 \n @retval 0 \n\n @remark \n @remark \n @remark IMP_FrameSource_SetMaxDelayIMP_FrameSource_SetDelay\n\n @attention ."]
    pub fn IMP_FrameSource_GetTimedFrame(
        chnNum: libc::c_int,
        framets: *mut IMPFrameTimestamp,
        block: libc::c_int,
        framedata: *mut libc::c_void,
        frame: *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_ReleaseFrame(int chnNum, IMPFrameInfo *frame);\n\n \n\n @param[in] chnNum \n @param[in] frame \n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention ."]
    pub fn IMP_FrameSource_ReleaseFrame(
        chnNum: libc::c_int,
        frame: *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SnapFrame(int chnNum, IMPPixelFormat fmt, int width, int height, void *framedata, IMPFrameInfo *frame);\n\n \n\n @param[in] chnNum \n @param[in] fmt    \n @param[in] width  \n @param[in] height \n @param[in] framedata \n @param[in] frame \n\n @retval 0 \n @retval 0 \n\n @remark NV12YUYV422\\n\n IMP_FrameSource_SetFrameDepth.\n @remark \n\n\n @attention ."]
    pub fn IMP_FrameSource_SnapFrame(
        chnNum: libc::c_int,
        fmt: IMPPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        framedata: *mut libc::c_void,
        frame: *mut IMPFrameInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetMaxDelay(int chnNum, int maxcnt);\n\n \n\n @param[in] chnNum \n @param[in] maxcnt \n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention IMP_FrameSource_CreateChnIMP_FrameSource_EnableChn."]
    pub fn IMP_FrameSource_SetMaxDelay(chnNum: libc::c_int, maxcnt: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetMaxDelay(int chnNum, int *maxcnt);\n\n \n\n @param[in] chnNum \n @param[out] maxcnt \n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention IMP_FrameSource_CreateChn."]
    pub fn IMP_FrameSource_GetMaxDelay(
        chnNum: libc::c_int,
        maxcnt: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetDelay(int chnNum, int cnt);\n\n \n\n @param[in] chnNum \n @param[in] cnt \n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention IMP_FrameSource_SetMaxDelay."]
    pub fn IMP_FrameSource_SetDelay(chnNum: libc::c_int, cnt: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetDelay(int chnNum, int *cnt);\n\n \n\n @param[in] chnNum \n @param[out] cnt \n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention IMP_FrameSource_CreateChn."]
    pub fn IMP_FrameSource_GetDelay(chnNum: libc::c_int, cnt: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetChnFifoAttr(int chnNum, IMPFSChnFifoAttr *attr);\n\n FIFO\n\n @param[in] chnNum \n @param[in] attr\tFIFO FIFOFIFO .\n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention IMP_FrameSource_CreateChnIMP_FrameSource_EnableChn."]
    pub fn IMP_FrameSource_SetChnFifoAttr(
        chnNum: libc::c_int,
        attr: *mut IMPFSChnFifoAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetChnFifoAttr(int chnNum, IMPFSChnFifoAttr *attr);\n\n FIFO\n\n @param[in] chnNum \n @param[out] attr\tFIFO.\n\n @retval 0 \n @retval 0 \n\n @remark .\n\n @attention IMP_FrameSource_CreateChn."]
    pub fn IMP_FrameSource_GetChnFifoAttr(
        chnNum: libc::c_int,
        attr: *mut IMPFSChnFifoAttr,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_SetPool(int chnNum, int poolID);\n\n chnnel FrameSourcemempool.\n\n @param[in] chnNum\t\t.\n @param[in] poolID\t\t.\n\n @retval 0\t\t\t\t.\n @retval 0\t\t\t\t.\n\n @remark  rmemchannel FrameSource mempool  \\n\n , FramSource memmempoolFramSourcermem \\n\n rmem\n\n @attention ChannelId 0 32."]
    pub fn IMP_FrameSource_SetPool(chnNum: libc::c_int, poolID: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_GetPool(int chnNum);\n\n channel ID poolID.\n\n @param[in] chnNum       .\n\n @retval  >=0 && < 32    .\n @retval  <0\t\t\t   .\n\n @remark ChannelId poolId, \n\n @attention ."]
    pub fn IMP_FrameSource_GetPool(chnNum: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_SetDirectModeAttr(int chnNum, int data_threshold)\n\n .\n\n @param[in] chnNum          .\n @param[in] data_threshold  \n\n @retval 0                  .\n @retval 0                .\n\n @attention IMP_FrameSource_CreateChn."]
    pub fn IMP_FrameSource_SetDirectModeAttr(
        chnNum: libc::c_int,
        data_threshold: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_GetDirectModeAttr(int chnNum, int *data_threshold)\n\n .\n\n @param[in] chnNum           .\n @param[out] data_threshold  \n\n @retval 0                   .\n @retval 0                 .\n\n @attention IMP_FrameSource_CreateChn."]
    pub fn IMP_FrameSource_GetDirectModeAttr(
        chnNum: libc::c_int,
        data_threshold: *mut libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " .\n @remarks AESDES."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_ALG_E {
    IN_UNF_CIPHER_ALG_AES = 0,
    IN_UNF_CIPHER_ALG_DES = 1,
}
#[doc = " .\n @remarks AESDES."]
pub use self::IN_UNF_CIPHER_ALG_E as IN_UNF_CIPHER_ALG;
#[repr(u32)]
#[doc = " .\n @remarks CBCECB."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_WORK_MODE_E {
    IN_UNF_CIPHER_WORK_MODE_ECB = 0,
    IN_UNF_CIPHER_WORK_MODE_CBC = 1,
    IN_UNF_CIPHER_WORK_MODE_OTHER = 2,
}
#[doc = " .\n @remarks CBCECB."]
pub use self::IN_UNF_CIPHER_WORK_MODE_E as IN_UNF_CIPHER_WORK_MODE;
#[repr(u32)]
#[doc = " .\n @remarks ,128bitKEY."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_KEY_LENGTH_E {
    IN_UNF_CIPHER_KEY_AES_128BIT = 0,
}
#[doc = " .\n @remarks ,128bitKEY."]
pub use self::IN_UNF_CIPHER_KEY_LENGTH_E as IN_UNF_CIPHER_KEY_LENGTH;
#[repr(u32)]
#[doc = " .\n @remarks ,128bit."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IN_UNF_CIPHER_BIT_WIDTH_E {
    IN_UNF_CIPHER_BIT_WIDTH_128BIT = 0,
}
#[doc = " .\n @remarks ,128bit."]
pub use self::IN_UNF_CIPHER_BIT_WIDTH_E as IN_UNF_CIPHER_BIT_WIDTH;
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IN_UNF_CIPHER_CTRL_S {
    #[doc = "< "]
    pub key: [libc::c_uint; 4usize],
    #[doc = "< IV"]
    pub IV: [libc::c_uint; 4usize],
    #[doc = "< "]
    pub enDataLen: libc::c_uint,
    #[doc = "< "]
    pub enAlg: IN_UNF_CIPHER_ALG,
    #[doc = "< "]
    pub enBitWidth: IN_UNF_CIPHER_BIT_WIDTH,
    #[doc = "< "]
    pub enWorkMode: IN_UNF_CIPHER_WORK_MODE,
    #[doc = "< KEY"]
    pub enKeyLen: IN_UNF_CIPHER_KEY_LENGTH,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IN_UNF_CIPHER_CTRL_S"][::core::mem::size_of::<IN_UNF_CIPHER_CTRL_S>() - 52usize];
    ["Alignment of IN_UNF_CIPHER_CTRL_S"][::core::mem::align_of::<IN_UNF_CIPHER_CTRL_S>() - 4usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::key"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, key) - 0usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::IV"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, IV) - 16usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enDataLen"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enDataLen) - 32usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enAlg"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enAlg) - 36usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enBitWidth"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enBitWidth) - 40usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enWorkMode"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enWorkMode) - 44usize];
    ["Offset of field: IN_UNF_CIPHER_CTRL_S::enKeyLen"]
        [::core::mem::offset_of!(IN_UNF_CIPHER_CTRL_S, enKeyLen) - 48usize];
};
impl Default for IN_UNF_CIPHER_CTRL_S {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
pub type IN_UNF_CIPHER_CTRL = IN_UNF_CIPHER_CTRL_S;
extern "C" {
    #[doc = " @fn int SU_CIPHER_Init(void)\n\n .\n\n @param\t.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_CIPHER_Init() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Exit(void)\n\n .\n\n @param\t.\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_CIPHER_Exit() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_CreateHandle(void)\n\n .\n\n @param\t.\n\n @retval  : .\n @retval  : retval <  0.\n\n @remarks .\n\n @attention ,.\n N,NSU_CIPHER_DestroyHandle()\n .\n"]
    pub fn SU_CIPHER_CreateHandle() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_DestroyHandle(int fd)\n\n .\n\n @param[in] fd \n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ,.\n"]
    pub fn SU_CIPHER_DestroyHandle(fd: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_ConfigHandle(int hCipher, IN_UNF_CIPHER_CTRL* Ctrl)\n\n .\n\n @param[in] hCipher .\n @param[in] Ctrl .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention  .\n"]
    pub fn SU_CIPHER_ConfigHandle(
        hCipher: libc::c_int,
        Ctrl: *mut IN_UNF_CIPHER_CTRL,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Encrypt(int hCipher, unsigned int * srcAddr, unsigned int * dstAddr, unsigned int dataLen)\n\n .\n\n @param[in] hCipher .\n @param[in] srcAddr .\n @param[in] dstAddr .\n @param[in] dataLen .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention  dataLen1Mbyte (1024*1024).\n"]
    pub fn SU_CIPHER_Encrypt(
        hCipher: libc::c_int,
        srcAddr: *mut libc::c_uint,
        dstAddr: *mut libc::c_uint,
        dataLen: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Decrypt(int hCipher, unsigned int * srcAddr, unsigned int * dstAddr, unsigned int dataLen);\n\n .\n\n @param[in] hCipher .\n @param[in] srcAddr .\n @param[in] dstAddr .\n @param[in] dataLen .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention  dataLen1Mbyte (1024*1024).\n"]
    pub fn SU_CIPHER_Decrypt(
        hCipher: libc::c_int,
        srcAddr: *mut libc::c_uint,
        dstAddr: *mut libc::c_uint,
        dataLen: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_Init(void);\n\n ADC\n\n @retval 0 \n @retval 0 \n\n @remark ADC\n\n @attention "]
    pub fn SU_ADC_Init() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_Exit(void);\n\n ADC\n\n @retval 0 \n @retval 0 \n\n @remark ADC\n\n @attention "]
    pub fn SU_ADC_Exit() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_EnableChn(uint32_t chn_num);\n\n \n\n @param[in] chn_num \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention ."]
    pub fn SU_ADC_EnableChn(chn_num: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_DisableChn(uint32_t chn_num);\n\n \n\n @param[in] chn_num \n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn SU_ADC_DisableChn(chn_num: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_GetChnValue(uint32_t chn_num, int *value);\n\n chn_numADC\n\n @param[in] chn_num \n\n @param[out] value ADC\n\n @retval 0 \n @retval 0 \n\n @remark \n\n @attention "]
    pub fn SU_ADC_GetChnValue(chn_num: u32, value: *mut libc::c_int) -> libc::c_int;
}
#[repr(i32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SUBatStatus {
    #[doc = "< "]
    Unknown = -1,
    #[doc = "< "]
    Charging = 0,
    #[doc = "< "]
    Discharging = 1,
    #[doc = "< "]
    Full = 2,
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SUBatEvent {
    #[doc = "< AC Adapter"]
    AC_ONLINE = 0,
    #[doc = "< AC Adapter"]
    AC_OFFLINE = 1,
    #[doc = "< USB"]
    USB_ONLINE = 2,
    #[doc = "< USB"]
    USB_OFFLINE = 3,
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetStatus(SUBatStatus *status)\n\n .\n\n @param[in] status .\n\n @retval 0 .\n @retval 0 .\n\n @remarks ,.\n\n @attention ."]
    pub fn SU_Battery_GetStatus(status: *mut SUBatStatus) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetEvent(SUBatEvent *event)\n\n .\n\n @param[out] event .\n\n @retval 0 .\n @retval 0 .\n\n @remarks ,.\n\n @attention ."]
    pub fn SU_Battery_GetEvent(event: *mut SUBatEvent) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetCapacity(void)\n\n .\n\n @param .\n\n @retval >=0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Battery_GetCapacity() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetVoltageUV(void)\n\n .\n\n @param .\n\n @retval >=0 ,uV.\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Battery_GetVoltageUV() -> libc::c_int;
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUModelNum {
    #[doc = "< "]
    pub chr: [libc::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUModelNum"][::core::mem::size_of::<SUModelNum>() - 64usize];
    ["Alignment of SUModelNum"][::core::mem::align_of::<SUModelNum>() - 1usize];
    ["Offset of field: SUModelNum::chr"][::core::mem::offset_of!(SUModelNum, chr) - 0usize];
};
impl Default for SUModelNum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUVersion {
    #[doc = "< "]
    pub chr: [libc::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUVersion"][::core::mem::size_of::<SUVersion>() - 64usize];
    ["Alignment of SUVersion"][::core::mem::align_of::<SUVersion>() - 1usize];
    ["Offset of field: SUVersion::chr"][::core::mem::offset_of!(SUVersion, chr) - 0usize];
};
impl Default for SUVersion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ID.IDCPU"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUDevID {
    #[doc = "< ID"]
    pub chr: [libc::c_char; 64usize],
    #[doc = "< ID"]
    pub hex: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUDevID"][::core::mem::size_of::<SUDevID>() - 64usize];
    ["Alignment of SUDevID"][::core::mem::align_of::<SUDevID>() - 1usize];
    ["Offset of field: SUDevID::chr"][::core::mem::offset_of!(SUDevID, chr) - 0usize];
    ["Offset of field: SUDevID::hex"][::core::mem::offset_of!(SUDevID, hex) - 0usize];
};
impl Default for SUDevID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " ."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SUTime {
    #[doc = "< 0~59"]
    pub sec: libc::c_int,
    #[doc = "< 0~59"]
    pub min: libc::c_int,
    #[doc = "< 0~23"]
    pub hour: libc::c_int,
    #[doc = "< 1~31"]
    pub mday: libc::c_int,
    #[doc = "< 1~12"]
    pub mon: libc::c_int,
    #[doc = "< >1900"]
    pub year: libc::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SUTime"][::core::mem::size_of::<SUTime>() - 24usize];
    ["Alignment of SUTime"][::core::mem::align_of::<SUTime>() - 4usize];
    ["Offset of field: SUTime::sec"][::core::mem::offset_of!(SUTime, sec) - 0usize];
    ["Offset of field: SUTime::min"][::core::mem::offset_of!(SUTime, min) - 4usize];
    ["Offset of field: SUTime::hour"][::core::mem::offset_of!(SUTime, hour) - 8usize];
    ["Offset of field: SUTime::mday"][::core::mem::offset_of!(SUTime, mday) - 12usize];
    ["Offset of field: SUTime::mon"][::core::mem::offset_of!(SUTime, mon) - 16usize];
    ["Offset of field: SUTime::year"][::core::mem::offset_of!(SUTime, year) - 20usize];
};
extern "C" {
    #[doc = " @fn int SU_Base_GetModelNumber(SUModelNum *modelNum)\n\n .\n\n @param[out] modelNum .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_GetModelNumber(modelNum: *mut SUModelNum) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetVersion(SUVersion *version)\n\n .\n\n @param[out] version .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_GetVersion(version: *mut SUVersion) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetDevID(SUDevID *devID)\n\n ID.\n\n @param[out] devID ID.\n\n @retval 0 .\n @retval 0 .\n\n @remarks CPUID.\n\n @attention ."]
    pub fn SU_Base_GetDevID(devID: *mut SUDevID) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetTime(SUTime *time)\n\n .\n\n @param[in] time .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_GetTime(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SetTime(SUTime *time)\n\n .\n\n @param[out] time .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_SetTime(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SUTime2Raw(SUTime *suTime, uint32_t *rawTime)\n\n SUTimeRaw.\n\n @param[in] suTime .\n @param[out] rawTime Raw(1970-01-01 00:00:00).\n\n @retval 0 .\n @retval 0 .\n\n @remarks Alarm.\n\n @attention ."]
    pub fn SU_Base_SUTime2Raw(suTime: *mut SUTime, rawTime: *mut u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Raw2SUTime(uint32_t *rawTime, SUTime *suTime)\n\n RawSUTime.\n\n @param[in] rawTime Raw(1970-01-01 00:00:00).\n @param[out] suTime .\n\n @retval 0 .\n @retval 0 .\n\n @remarks Alarm.\n\n @attention ."]
    pub fn SU_Base_Raw2SUTime(rawTime: *mut u32, suTime: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SetAlarm(SUTime *time)\n\n .\n\n @param[in] time .\n\n @retval 0 .\n @retval 0 .\n\n @remarks 24.\n\n @attention ."]
    pub fn SU_Base_SetAlarm(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetAlarm(SUTime *time)\n\n .\n\n @param[out] time .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_GetAlarm(time: *mut SUTime) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_EnableAlarm()\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks SU_Base_GetAlarmSUTime *time.\n\n @attention ."]
    pub fn SU_Base_EnableAlarm() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_DisableAlarm()\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_DisableAlarm() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_PollingAlarm(uint32_t timeoutMsec)\n\n .\n\n @param[in] .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_PollingAlarm(timeoutMsec: u32) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Shutdown(void)\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_Shutdown() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Reboot(void)\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n\n @attention ."]
    pub fn SU_Base_Reboot() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Suspend(void)\n\n .\n\n @param .\n\n @retval 0 .\n @retval 0 .\n\n @remarks ,.\n\n @attention ."]
    pub fn SU_Base_Suspend() -> libc::c_int;
}
#[repr(u32)]
#[doc = " ."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SUKeyEvent {
    #[doc = "< "]
    KEY_RELEASED = 0,
    #[doc = "< "]
    KEY_PRESSED = 1,
}
#[repr(u32)]
#[doc = " LED."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum SULedCmd {
    #[doc = "< LED"]
    LED_OFF = 0,
    #[doc = "< LED"]
    LED_ON = 1,
}
extern "C" {
    #[doc = " @fn int SU_Key_OpenEvent(void)\n\n .\n\n @param \n\n @retval >0 .\n @retval <=0 .\n\n @remarks \n @remarks \n @remarks \n \n\n @attention "]
    pub fn SU_Key_OpenEvent() -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_CloseEvent(int evfd)\n\n .\n\n @param[in] evfd \n\n @retval 0 .\n @retval 0 .\n\n @remarks \n\n @attention "]
    pub fn SU_Key_CloseEvent(evfd: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_ReadEvent(int evfd, int *keyCode, SUKeyEvent *event)\n\n .\n\n @param[in] evfd \n @param[in] keyCode \n @param[out] event .\n\n @retval 0 .\n @retval 0 .\n\n @remarks .\n @remarks linux/input.hGPIOkernel\n @remarks \n @code\n#define KEY_HOME                102 //HOME\n#define KEY_POWER               116 //\n#define KEY_WAKEUP              143 //POWER\n#define KEY_F13                 183 //PIRF13\n @endcode\n\n @remarks GPIO\n\n @code\nstruct gpio_keys_button __attribute__((weak)) board_buttons[] = {\n#ifdef GPIO_HOME\n{\n.gpio           = GPIO_HOME,\t\t//GPIO\n.code           = KEY_HOME,\t\t\t//\n.desc           = \"home key\",\n.active_low     = ACTIVE_LOW_HOME,\t//\n#ifdef WAKEUP_HOME\n.wakeup         = WAKEUP_HOME,\t\t//1suspend\n#endif\n#ifdef CAN_DISABLE_HOME\n.can_disable    = CAN_DISABLE_HOME,\t//Disable\n#endif\n},\n#endif\n#ifdef GPIO_POWER\n{\n.gpio           = GPIO_POWER,\n.code           = KEY_POWER,\n.desc           = \"power key\",\n.active_low     = ACTIVE_LOW_POWER,\n#ifdef WAKEUP_POWER\n.wakeup         = WAKEUP_POWER,\n#endif\n#ifdef CAN_DISABLE_POWER\n.can_disable    = CAN_DISABLE_POWER,\n#endif\n},\n#endif\n}\n @endcode\n @remarks PIRPIRPIR(@ref KEY_PRESSED)\n PIR(@ref KEY_RELEASED)PIRPIR\n @remarks APIsample-keyevent.c.\n\n @attention "]
    pub fn SU_Key_ReadEvent(
        evfd: libc::c_int,
        keyCode: *mut libc::c_int,
        event: *mut SUKeyEvent,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_DisableEvent(int keyCode)\n\n Disable.\n\n @param[in] keyCode \n\n @retval 0 .\n @retval 0 .\n\n @remarks suspend(Open)\n Disable\n @remarks APIDisable PIR\"\"\n\n @attention "]
    pub fn SU_Key_DisableEvent(keyCode: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_EnableEvent(int keyCode)\n\n Enable.\n\n @param[in] keyCode \n\n @retval 0 .\n @retval 0 .\n\n @remarks Disable@ref SU_Key_DisableEvent(int keyCode)\n\n @attention "]
    pub fn SU_Key_EnableEvent(keyCode: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " @fn int SU_LED_Command(int ledNum, SULedCmd cmd)\n\n LED.\n\n @param[in] ledNum LED.\n @param[in] cmd LED.\n\n @retval 0 .\n @retval 0 .\n\n @remarks LEDLEDLinux\n Fixed RegulatorLEDGPIO\n LED fixed regulator\n @code\nFIXED_REGULATOR_DEF(  //fixed regulator\nled0,\n\"LED0\",         3300000,        GPIO_PA(14),\nHIGH_ENABLE,    UN_AT_BOOT,     0,\n\"ldo7\",         \"vled0\",        NULL);\n\nFIXED_REGULATOR_DEF(\nled1,\n\"LED1\",         3300000,        GPIO_PA(15),\nHIGH_ENABLE,    UN_AT_BOOT,     0,\n\"ldo7\",         \"vled1\",        NULL);\n\nstatic struct platform_device *fixed_regulator_devices[] __initdata = {\n&gsensor_regulator_device,\n&led0_regulator_device,\n&led1_regulator_device,\n};\n\nstatic int __init fix_regulator_init(void)  //subsys_initcall_syncregulator\n{\nint i;\n\nfor (i = 0; i < ARRAY_SIZE(fixed_regulator_devices); i++)\nfixed_regulator_devices[i]->id = i;\n\nreturn platform_add_devices(fixed_regulator_devices,\nARRAY_SIZE(fixed_regulator_devices));\n}\nsubsys_initcall_sync(fix_regulator_init);\n @endcode\n @remarks API\n @code\nif (SU_LED_Command(0, LED_ON) < 0)  //LED0\nprintf(\"LED0 turn on error\\n\");\nif (SU_LED_Command(1, LED_ON) < 0)  //LED1\nprintf(\"LED0 turn on error\\n\");\nif (SU_LED_Command(0, LED_OFF) < 0)  //LED0\nprintf(\"LED1 turn off error\\n\");\nif (SU_LED_Command(1, LED_OFF) < 0)  //LED1\nprintf(\"LED1 turn off error\\n\");\n @endcode\n @attention "]
    pub fn SU_LED_Command(ledNum: libc::c_int, cmd: SULedCmd) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut libc::c_void;
